<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <h1>Fundamentos de Bases de Datos. Tipo Test Parcial II</h1>
<p><strong>Autor</strong>: Elías Monge Sánchez</p>
<p><strong>Autor</strong>: Arturo Olivares Martos</p>
<hr>
<ul>
<li><strong>Asignatura:</strong> Fundamentos de Bases de Datos
<!--- Curso Académico: Actualizado al curso 2024-25-->
<!--- Grado: Preguntas comunes para el Grado en Ingeniería Informática y los Dobles Grados-->
<!--- Grupo: A.-->
<!--- Profesor: Ignacio Rojas Ruiz.-->
<!--- Fecha: 19-10-2023.--></li>
<li><strong>Descripción</strong>: Recopilación de preguntas Tipo Test del Parcial II (Tema 4 y Seminarios 3-4).<br>
Si encuentran algún error o pregunta repetida, rogamos nos lo comuniquen.</li>
</ul>
<hr>
<ol>
<li>
<p>Al aplicar <code>DROP TABLE</code> sobre una tabla <code>T</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se borrarán las tuplas de la tabla, aunque se mantenga la tabla en nuestro esquema.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es posible que se produzca un error, aunque la tabla <code>T</code> exista en nuestro esquema.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere la tabla <code>PIEZA (codpie, nompie, color)</code>, cuya clave primaria es <code>codpie</code>; considere la consulta: <em>encontrar los colores que cumplen que el número de piezas de la tabla que tienen ese color es exactamente 2</em>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La consulta se puede resolver tanto con SQL como con Álgebra Relacional.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La consulta no se puede resolver con SQL.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La consulta se puede resolver con SQL, pero no se puede resolver con Álgebra Relacional.</label></li>
</ul>
</li>
<li>
<p>Considere una tabla \(T(A,B)\). En relación con los operadores del Álgebra Relacional:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La consulta \(\pi_A(T) \cup \pi_B(T)\) equivale a \(\pi_{A,B}(T)\)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La consulta \( \sigma_{A=a_1}(T) \cap \sigma_{B=b_1}(T)\) se puede plantear con una sola selección sobre la tabla \(T\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>Cuando operamos con dos tablas que están conectadas por una clave externa formada por dos atributos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es posible que su producto cartesiano devuelva menos tuplas que su reunión.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es imposible que su producto cartesiano devuelva más tuplas que su reunión.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere la siguiente consulta en SQL: <code>SELECT codpro FROM ventas</code>.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El resultado de dicha consulta coincidirá, en cualquier caso, con la proyección por el campo <code>codpro</code> de la tabla <code>ventas</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El resultado de dicha consulta coincidirá, en cualquier caso, con el de la siguiente consulta:<br><code>SELECT codpro FROM ventas WHERE cantidad &gt;= 1000<br>UNION<br>SELECT codpro FROM ventas WHERE cantidad &lt; 1000;</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere dos tablas \(T_1\) y \(T_2\) con esquemas equivalentes. Considere la siguiente expresión en Álgebra Relacional: \((T_1 - T_2) \cup T_2\). El resultado de aplicar dicha operación sobre dos instancias \(t_1\) y \(t_2\) de las tablas:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Producirá siempre como resultado una instancia \(t\) contenida en o igual a \(t_2\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Producirá siempre como resultado la instancia \(t_1\).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>En relación con la capacidad de consulta:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Todas las consultas que se pueden resolver con Álgebra Relacional, se pueden resolver con SQL.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todas las consultas que se pueden resolver con SQL, se pueden resolver con Álgebra Relacional.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No sabe o no contesta.</label></li>
</ul>
</li>
<li>
<p>Considere dos tablas \(T_1\) y \(T_2\) tales que el esquema de \(T_2\) está contenido en el de \(T_1\). Considere la siguiente expresión en Álgebra Relacional: \((T_1 \div T_2) \times T_2\). El resultado de aplicar dicha operación sobre dos instancias \(t_1\) y \(t_2\) de las tablas:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Producirá como resultado una instancia \(t\) contenida en o igual a \(t_1\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Producirá siempre como resultado la instancia \(t_1\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>Cuando operamos con dos tablas que están conectadas por una clave externa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Su producto cartesiano siempre devuelve la misma cantidad de tuplas que su reunión.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Su producto cartesiano puede devolver más tuplas que la reunión, aunque no siempre.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su producto cartesiano puede devolver menos tuplas que su reunión, aunque no siempre.</label></li>
</ul>
</li>
<li>
<p>En relación con los operadores fundamentales y no fundamentales del Álgebra Relacional:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solo una parte de los operadores no fundamentales pueden reproducirse utilizando operadores fundamentales.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Todos los operadores no fundamentales pueden reproducirse utilizando operadores fundamentales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los operadores fundamentales pueden reproducirse utilizando operadores no fundamentales.</label></li>
</ul>
</li>
<li>
<p>En general, en Oracle si añadimos un índice a una tabla:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Habrá que reescribir todas las sentencias de consulta que hayamos planteado previamente sobre dicha tabla, puesto que pueden dar errores sintácticos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Habrá que reescribir solo las sentencias de consulta en las que aparezca la tabla más de una vez, puesto que darán errores sintácticos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>En relación con el comando <code>DESCRIBE</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se trata de un comando fundamental, puesto que la información que proporciona sobre dichas tablas es imposible de obtener de otra manera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La información que proporciona el comando <code>DESCRIBE</code> sobre dichas tablas está almacenada en el catálogo de la base de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras opciones es cierta.</label></li>
</ul>
</li>
<li>
<p>Un índice primario:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Nunca puede ser denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Nunca puede ser no denso.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En general para acceder a los datos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Ni índices ni acceso directo son mejores en términos absolutos frente al otro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El acceso directo es siempre la mejor alternativa si está disponible en el SGBD.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los índices son siempre la mejor alternativa si está disponible en el SGBD.</label></li>
</ul>
</li>
<li>
<p>En un índice de mapa de bits:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El número de entradas es el doble del número de valores que tiene la clave por la que se quiere indexar el fichero.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El número de entradas coincide con el número de registros que hay en el fichero que se quiere indexar.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El número de entradas coincide con el número de valores que tiene la clave por la que se quiere indexar el fichero.</label></li>
</ul>
</li>
<li>
<p>En la aproximación del método de acceso a la base de datos vista en clase:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El gestor de archivos y el gestor de disco son dos elementos del S.O. que permiten la transformación entre páginas almacenadas y sectores de disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El gestor de archivos y el gestor de disco son dos formas de decir lo mismo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Cuando se utilizan técnicas de hashing básico:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Deja de ser necesario usar estrategias para solventar colisiones, puesto que estas no pueden presentarse.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En general, no ayuda a conocer zonas del dominio del campo clave donde pueden presentarse más valores.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es posible que se produzcan huecos.</label></li>
</ul>
</li>
<li>
<p>En relación con los índices:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No se pueden utilizar si el fichero de datos no está ordenador por la clave del índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantos más campos añadamos a la clave de búsqueda, más rápido será el proceso de búsqueda en el índice por uno de esos campos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>En general, cuanto mayor es el número de colisiones que produce una función hash</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Las búsquedas tenderán a ser más lentas</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Menos huecos se producirán</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>Un objetivo primordial en relación con el método de acceso es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Evitar la aparición de valores nulos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ocultar al usuario el verdadero valor de la clave física</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>Considere las tablas organizadas por índice (IOT):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Son la forma de implementar los arboles B+ en bases de datos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La clave de búsqueda del índice no tiene nada que ver con la clave física</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>En el nivel interno</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El almacenamiento persistente de los datos se hace con dispositivos de memoria de las primeras posiciones de la jerarquía de memoria para que las operaciones sean más rápidas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El almacenamiento persistente de los datos se hace con dispositivos de memoria de las primeras posiciones de la jerarquía de memoria para que sea más barata la implantación del sistema.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>Considere que se está usando Hashing dinámico. En un momento dado, al insertar un nuevo registro en un cubo con profundidad local igual a la profundidad global:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En ningún caso habrá que desdoblar la tabla índice.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es posible que no haya que desdoblar la tabla índice</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Necesariamente habrá que desdoblar la tabla índice.</label></li>
</ul>
</li>
<li>
<p>Considere un fichero secuencial indexado:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cuanto mas grandes sean los registros del fichero índice, más se ayudará a acelerar el proceso de búsqueda.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cuando más pequeños sean los registros del fichero índice, más se ayudará a acelerar el proceso de búsqueda.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta</label></li>
</ul>
</li>
<li>
<p>El Hashing dinámico:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Va asignando más espacio en disco a zonas del dominio de la clave donde se van presentando más valores en la instancia de la base de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asigna mas espacio en disco a aquellas zonas del dominio de la clave que teóricamente van a presentar más valores en la instancia de la base de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No utiliza ninguna estructura auxiliar, aparte del propio fichero que almacena los registros.</label></li>
</ul>
</li>
<li>
<p>En un árbol B+:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Cuanto menor es \(M\), mayor tiende a ser el número de niveles.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuanto mayor es \(M\), mayor tiende a ser el número de niveles</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>La BD en el nivel interno se puede representar de distintas formas, pero:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Nunca deben ubicarse juntos registros de distinto tipo para facilitar operaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando se ponen juntos los registros del mismo tipo, se optimizan operaciones como las de reunión de tablas.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Cuando se utiliza Hashing dinámico:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede utilizar una función de direccionamiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es imposible que se produzcan colisiones.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En relación con el método de acceso a la BD, las páginas o bloques de la BD deben tener un tamaño múltiplo de las páginas o bloques del sistema operativo...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Para garantizar que la memoria y el disco duro sean compatibles.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Para aprovechar bien cada operación de E/S en disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Para que sea fácil hacer cuentas a la hora de organizar los datos.</label></li>
</ul>
</li>
<li>
<p>Cuando se organiza el acceso a los datos de un fichero mediante el uso de índices:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En general, lo mejor es usar tantos índices como configuraciones de consulta pueden plantearse.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el espacio de disco no es un problema, lo mejor es usar tantos índices como configuraciones de consulta puedan plantearse.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Al respecto de los índices jerárquicos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El número de niveles depende, entre otras cosas, del número de registros del fichero de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los arboles B+ no son un ejemplo de índice jerárquico.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los arboles B no son un ejemplo de índice jerárquico.</label></li>
</ul>
</li>
<li>
<p>En general, cuando se utiliza un índice denso:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Al realizar una operación de borrado de un registro en el fichero nunca hay que actualizar el índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Al realizar una operación de inserción de un nuevo registro en el fichero nunca hay que actualizar el índice.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En la indexación con árboles B:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El orden de un árbol influye directamente en el número de niveles.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El orden de un árbol se determina por el tamaño de página/bloque que se asigna a los nodos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se puede montar un árbol B sobre cualquier campo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las otras respuestas indicadas son ciertas.</label></li>
</ul>
</li>
<li>
<p>La técnica de acceso directo:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No utiliza área de desbordamiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza siempre que encuentro una fila con una sola lectura de bloque.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> No permite realizar la lectura secuencial de datos en un rango.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No necesita una estimación previa del número de registros.</label></li>
</ul>
</li>
<li>
<p>El objetivo principal de los mecanismo de indexación y métodos de acceso es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Localizar datos requeridos con el número mínimo de operaciones de lectura en disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantizar que no se duplique la clave primaria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Acceder a los datos de una tabla de forma ordenada.</label></li>
</ul>
</li>
<li>
<p>El clúster:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Perjudica la lectura individual de las tablas que contiene</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Acelera las consultas que involucran la reunion natural de las tablas que contiene.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es una estructura inter-archivo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Todo lo anterior es cierto.</label></li>
</ul>
</li>
<li>
<p>En un índice denso:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El índice ocupa lo mismo que la tabla indexada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El número de registros del índice es menor que el número de registros de la tabla indexada.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El número de registros del índice es igual al número de registros de la tabla indexada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras respuestas propuestas es cierta.</label></li>
</ul>
</li>
<li>
<p>En el Hashing extendido:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Lo mejor es que la pseudollave se ajuste al tamaño del índice que se guarda en memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Lo mejor es que la pseudollave tenga muchos dígitos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Hay que reservar de antemano un número fijo de bloques.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No hay que tener una estimación del número de registros a almacenar.</label></li>
</ul>
</li>
<li>
<p>Las páginas que componen un archivo almacenado:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Contienen siempre registros de una misma tabla.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Pueden ser de distinto tamaño dependiendo del tamaño de los registros que se almacenen en ellas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Tienen que estar consecutivas en disco.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Todo lo anterior es falso.</label></li>
</ul>
</li>
<li>
<p>Sean \(F\) y \(D\) las tablas procedentes de una entidad fuerte y una débil, respectivamente. Las filas de \(D\) se recuperan con las de \(F\), y rara vez, por separado. La mejor opción sería:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Indexar \(D\) por el atributo que tiene en común con \(F\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Crear una vista en la que aparezcan los datos de ambas tablas en el formato adecuado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Almacenarlas conjuntamente en un clúster.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Poner en \(D\) como clave externa el atributo que tiene en común con \(F\).</label></li>
</ul>
</li>
<li>
<p>Indica la afirmación verdadera:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Se pueden montar tantos índices densos como se necesiten.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En ficheros no ordenados físicamente se pueden montar índices no densos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El índice no denso es el único mecanismo de indexación posible cuando los datos están ordenados físicamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un árbol B solo se puede montar sobre la clave física de un archivo.</label></li>
</ul>
</li>
<li>
<p>La sentencia <code>CREATE TABLE</code> provoca:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La creación de un nuevo archivo almacenado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La creación de un nuevo fichero en disco.</label></li>
</ul>
</li>
<li>
<p>Un índice no denso:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Permite realizar preguntas de tipo existencial sin acceder al fichero de datos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exige que los registros esten ordenados físicamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El rendimiento desciende considerablemente cuando se realizan muchas inserciones o borrados en la tabla.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es adecuado para consultas por rangos de valores del campo clave.</label></li>
</ul>
</li>
<li>
<p>El <em>record identifier</em> (RID):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es un campo de un índice denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es un campo de un indice no denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Puede servir para identificar varios registros.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se calculan mediante un algoritmo de direccionamiento.</label></li>
</ul>
</li>
<li>
<p>El índice por clave invertida:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se puede montar sobre cualquier campo de la tabla.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ayuda a distribuir mejor los datos en el espacio de almacenamiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es útil para recorrer una tabla por el campo clave en orden inverso al establecido.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todo lo anterior es cierto.</label></li>
</ul>
</li>
<li>
<p>En Hashing dinámico si el número de registros por bloque es 4 y tengo alrededor de 1000 registros, el número de bits necesario para la tabla hash es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 8</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 5</label></li>
</ul>
</li>
<li>
<p>Cuando se necesita acceder a la tabla <code>alumnos</code> por rangos de notas (sin decimales) el mejor mecanismo es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un índice no denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un índice denso</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un índice de mapa de bits</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Hashing básico.</label></li>
</ul>
</li>
<li>
<p>Cuando la cardinalidad del campo por el que se indexa una tabla es muy baja, el mejor mecanismo de indexación es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un árbol B donde el conjunto secuencia sea denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un árbol B donde el conjunto secuencia sea no denso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Algún mecanismo de acceso directo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un índice de mapa de bits.</label></li>
</ul>
</li>
<li>
<p>Indica cual de estas afirmaciones es verdadera:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El tamaño de los bloques físicos y de las páginas deben ser independientes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El nivel interno de una base de datos está enteramente gestionado por el SO del ordenador.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las páginas que componen un archivo almacenado no tienen porque estar consecutivas en disco.</label></li>
</ul>
</li>
<li>
<p>Con la consulta <code>SELECT codpro, sum(cantidad) FROM ventas GROUP BY codpro</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Se puede crear una vista, pero no será actualizable.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede crear una vista por estar agrupada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se puede crear una vista y será actualizable porque solo usa una tabla.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores es cierta.</label></li>
</ul>
</li>
<li>
<p>Las tablas organizadas por índice (IOT):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No admiten ningún tipo de índice</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No tienen llave primaria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No pueden recuperarse de forma ordenada.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se organizan como un árbol B cuyas hojas contienen las tuplas.</label></li>
</ul>
</li>
<li>
<p>Indica cual de estas afirmaciones es <strong>FALSA</strong>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En el Hashing extendido una mala elección en el tamaño de las páginas puede obligar a reorganizar completamente la estructura.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El Hashing extendido es muy eficaz porque la tabla hash va en memoria principal</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El índice no denso es el único mecanismo de indexación posible cuando los datos están ordenados físicamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La actualización de los archivos puede no influir en la actualización de los índices no densos.</label></li>
</ul>
</li>
<li>
<p>En general, un algoritmo de direccionamiento:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Interesa que produzca pocos huecos, aunque da igual el número de colisiones que genere.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Interesa que produzca pocas colisiones, aunque da igual el número de huecos que genere.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Interesa que produzca pocas colisiones y pocos huecos.</label></li>
</ul>
</li>
<li>
<p>La técnica de hashing que va asignando más cubos a zonas del dominio de la clave donde se van presentando más valores en la instancia de la base de datos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es el hashing básico.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es el hashing dinámico</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere que se está usando hashing dinámico. En ese caso:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Es posible que se produzcan colisiones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Da igual la función hash que se utilice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere las tablas organizadas por índice:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solo las operaciones de borrado implican operar sobre el índice asociado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo las operaciones de actualización implican operar sobre el índice asociado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El índice asociado sirve para acelerar algunas consultas.</label></li>
</ul>
</li>
<li>
<p>En los índices multinivel:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El número de accesos a disco está relacionado con el número de niveles del índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre permiten localizar el registro con un único acceso a disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo se pueden construir sobre la clave física.</label></li>
</ul>
</li>
<li>
<p>Un factor de bloqueo alto:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Aumenta la aparición de valores nulos en el campo de la clave física.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Disminuye la aparición de valores nulos en el campo de la clave física.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere un índice montado sobre los siguientes campos de un registro (en el orden que se muestran): <code>nombre, ciudad, color</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El índice es útil para consultas que tratan de localizar los registros correspondientes a un determinado nombre.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El índice es útil para consultas que tratan de localizar los registros correspondientes a una determinada ciudad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>A la hora de decidir si se crea un determinado índice en la BD:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo hay que tener en cuenta si aumenta la eficiencia de alguna consulta.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Debemos tener en cuenta que operaciones como las de inserción se pueden ver ralentizadas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere que tengo que ubicar registros de cuentas bancarias y registros con los movimientos de dichas cuentas bancarias:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En cualquier caso, es mejor no usar ningún tipo de agrupamiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En cualquier caso, utilizaré agrupamiento interarchivo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Desde un punto de vista general, si una BD es lo suficientemente pequeña:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Nos bastará con tenerla en memoria caché, sin necesidad de respaldo de un dispositivo no volátil como el disco duro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Nos bastará con tenerla en memoria principal, sin necesidad de respaldo de un dispositivo no volátil como el disco duro.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En general, si quiero optimizar consultas del tipo "dame los registros cuyo valor del campo <code>X</code>, está comprendido entre \(x_1\) y \(x_2\), con \(x_1&lt;x_2\)":</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Debo optar por técnicas de hashing dinámico.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Debo optar por técnicas de hashing básico.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>Considere los árboles B+ (<code>Tree1</code> y <code>Tree2</code>) construidos sobre la misma clave y el mismo fichero, y que el valor de <code>M</code> en <code>Tree1</code> es mayor que el valor de <code>M</code> en el <code>Tree2</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Entonces el número de valores de la clave presentes en el nivel de las hojas de <code>Tree1</code> será menor que el número de valores de la clave presentes en el nivel de las hojas de <code>Tree2</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Entonces el número de valores de la clave presentes en el nivel de las hojas de <code>Tree1</code> será mayor que el número de valores de la clave presentes en el nivel de las hojas de <code>Tree2</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>La gestión de archivos de S.O es llevada a cabo por:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El gestor de eventos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El gestor de disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El gestor de archivos.</label></li>
</ul>
</li>
<li>
<p>Considere un índice de clave invertida sobre el código de empleado de una tabla de empleados:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En ese índice, los códigos 7698 y 8967 producen una colisión.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El índice no sirve para consultas del tipo: localizar el empleado cuyo código es 7698.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En relación a los índices de mapa de bits:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> En general, no es adecuado construirlos sobre la clave primaria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantas más tuplas tiene la tabla, más cortos son los mapas de bits asociados a un valor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En el hashing dinámico, en un momento dado:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los cubos deben tener el mismo valor de profundidad local.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La profundidad local puede variar de unos cubos a otros.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los cubos que están llenos tienen que tener el mismo valor de profundidad local.</label></li>
</ul>
</li>
<li>
<p>En relación con la forma de representar la BD en el nivel interno:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Debe estar orientada a maximizar la E/S a disco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es obligatorio que cada conjunto de registros del mismo tipo sea un fichero.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
<li>
<p>En relación con el uso de índices:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No suponen el consumo de espacio extra en disco porque sólo se almacenan en memoria principal</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Debemos analizar su conveniencia, porque puede acelerar unas operaciones, pero ralentizar otras.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Aunque ocupan espacio extra, todas las operaciones se ven mejoradas en eficiencia o se mantienen igual.</label></li>
</ul>
</li>
<li>
<p>Considere un índice denso que no sea jerárquico:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Nunca puede ser un índice secundario.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Nunca puede ser un índice primario.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las otras es cierta.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-warning');
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-warning');
            } else {
                self.removeClass('text-warning'); // Eliminar la marca de respuesta parcialmente correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>