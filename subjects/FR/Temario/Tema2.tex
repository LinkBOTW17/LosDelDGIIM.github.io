\chapter{Capa de red}

\subsubsection{Objetivos}

\begin{itemize}
    \item Comprender las funcionalidades y servicios de la capa de red.
        \begin{itemize}
            \item Concepto de conmutación de paquetes y datagramas. 
            \item Direccionamiento en Internet.
            \item Encaminamiento salto a salto.
            \item Asociación con la capa de enlace a través del protocolo \acrshort{ARP}.
            \item Señalización de errores mediante el protocolo \acrshort{ICMP}.
        \end{itemize}
\end{itemize}

\subsubsection{Introducción}

En este tema estudiaremos a fondo la capa de red. Recordemos que seguimos el Modelo TCP/IP descrito en la Tabla~\ref{table:_tabla_de_capas}.

\section{Funcionalidades}

Funcionalidades y servicios TCP\@/IP\@:
\begin{itemize}
    \item \textbf{Direccionamiento:} identificación de equipos dentro de la red.
    \item \textbf{Encaminamiento:} llegar salto a salto desde el origen al destino. Especifica el camino que deben seguir los paquetes.
    \item \textbf{Fragmentación:} las tarjetas suelen tener un tamaño máximo de paquete, y si queremos enviar un paquete más grande tenemos que fragmentarlo y, en el destino, ensamblarlo. 
    \item \textbf{Conmutación.} 
    \item \textbf{Interconexión de redes.}
    \item En OSI\@: \textbf{control de gestión.}
\end{itemize}

El protocolo que desarrollaremos en este tema es \acrshort{IP} por ser el que en la actualidad se ha impuesto, aunque existen otros como \acrshort{ATM}, x25\ldots

\section{Conmutación}

\begin{definicion}[Conmutación]
    Acción de establecer o determinar caminos de extremo a extremo que permitan transmitir información.         
\end{definicion}

Uno de los primeros ejemplos claros de conmutación que se vio en la tecnología de las comunicaciones fue la conmutación de circuitos para la telefonía, que desarrollamos a continuación.
\subsection{Conmutación de circuitos}

Antiguamente existía una conmutación física de circuitos, muy usada en telefonía. De esta forma, hay muchos cables entre los usuarios y las centrales (uno por cada usuario), y menos cables entre cada par de centrales, ya que no todos los usuarios hablan al mismo tiempo. \\

La comunicación por conmutación de circuitos implica tres fases:
\begin{enumerate}
    \item El establecimiento del circuito. Cada central une los cables que correspondan y se genera el camino. 
    \item La trasferencia de datos a través del circuito dedicado.
    \item La desconexión del circuito, se libera el circuito para su reutilización.
\end{enumerate}

\subsubsection{Beneficios}
\begin{itemize}
    \item Recursos dedicados (tenemos un cable solo para nosotros), lo que facilita las comunicaciones a tiempo real y sin retardos.
    \item El recurso se mantiene dedicado toda la sesión.
    \item No hay competición por conseguir el medio.
    \item El circuito es fijo, no hay decisiones de encaminamiento una vez establecido.
    \item Simplicidad en la gestión de los nodos intermedios.
\end{itemize}

\subsubsection{Desventajas}
\begin{itemize}
    \item Cuando un usuario no usa su cable no lo usa nadie más. Uso ineficiente de recursos.
    \item Hay establecimiento de llamada (para que todos los cables se toquen).
    \item Es poco tolerable a fallos, si algo no funciona, todo deja de funcionar.
\end{itemize}

\subsection{Conmutación de paquetes}
En la actualidad, no se envía una señal analógica; sino que, como sabemos, se envía el \acrshort{SDU} junto con la cabecera. En la capa de red, vimos que el \acrshort{SDU} se denomina \emph{datagrama}, y veremos que este se ha de fragmentar en distontos bloques, a los que denominaremos \emph{paquetes}. Por tanto, los paquetes son cada uno de los bloques de un datagrama, y es lo que se envía como tal por la red.
\begin{observacion}
    En general, cuando se quiera hacer referencia a un conjunto de datos que se envía por la red, sin especificar en qué capa nos encontramos, o sin ser más precisos, también usaremos el término de \emph{paquete}.
\end{observacion}

A la hora de realizar la conmutación, hay dos formas de hacerlo, la conmutación mediante datagramas y la conmutación mediante circuitos virtuales.

\subsubsection{Conmutación de datagramas}\label{sec:conmutacion_de_datagramas}

Las características de la conmutación de datagramas son:
\begin{itemize}
    \item No hay establecimiento de conexión: enviamos un paquete y no sabemos si el otro extremo está encendido.
    \item El envío de los distintos paquetes se hace independientemente. El encaminamiento se hace paquete a paquete, por lo que se pueden seguir caminos distintos. Por este motivo, los paquetes pueden llegar desordenados, algo que controlarán otras capas.
    
    Además, si se produce fragmentación, no se ensamblarán los paquetes hasta que lleguen al destino, ya que distintos paquetes de un mismo datagrama pueden seguir distintos caminos. 
    \item En cada nodo intermedio los paquetes que llegan se almacenan en una cola, y cuando sea posible se envían al próximo nodo. 
    \item Como el encaminamiento se hace salto a salto, todos los paquetes han de tener la dirección de origen (para las respuestas o encaminamientos específicos, aunque esto no lo veremos en la asignatura) y de destino. A veces, para hacer difusiones de datos, nos puede interesar taner varias direcciones de destino.
\end{itemize}

Como el medio es común, los nodo de interconexión necesitan colas para poder gestionar los paquetes que le llegan.
A la hora de esta conmutación, se hace el mejor esfuerzo, pero si algo falla la capa de red no se encarga de gestionar el fallo.

Un protocolo que lleve a cabo esta conmutación es \acrshort{IP}, que desarrollaremos más adelante.
Este es el tipo de conmutación que se usa mayoritariamente en la actualidad, y es en el que nos centraremos en la asignatura.

\subsection{Conmutación con circuitos virtuales}

En este caso, la conmutación difiere ligeramente de la conmutación por datagramas vista, siendo una mezcla entre la conmutación de circuitos y la de paquetes.

En este caso, para enviar un paquete de un origen a un destino, aunque haya distintos caminos posibles, se establece el camino desde el principio denominado circuito (siguiendo la idea de la conmutación de circuitos). Este circuito no obstante es virtual, ya que los recursos no son dedicados completamente, sino que se reservan temporalmente pero se pueden reutilizar.

Cada router decide el camino que seguirá cada paquete, y los paquetes del mismo datagrama seguirán el mismo camino. Por tanto, el primer paquete en llegar al router reservará los recursos para los próximos paquetes.

\begin{itemize}
    \item Hay que establecer conexión para averiguar la ruta a seguir. 
    \item Si un router se cae, se cambia el camino. 
\end{itemize}

Un protocolo que lleva a cabo esta conmutación es \acrfull{ATM}, que estaba presente en el inicio de la telefonía digital.


\section{El protocolo \acrshort{IP}}

El \acrfull{IP} es un protocolo para la interconexión de redes.
Existen dos versiones:
\begin{itemize}
    \item \acrshort{IPv4}: Es la que se diseñó inicialmente, aunque tiene una limitación en la cantidad de direcciones.
    \item \acrshort{IPv6}: Pasó de 32 a 128 bits, lo que supone una cantidad en la práctica ilimitada de direcciones.
\end{itemize}
En la actualidad la limitación de direcciones se empieza a notar, por lo que hay una transición gradual hacia \acrshort{IPv6}, aunque sigue predominando \acrshort{IPv4}. Desorrallaremos \acrshort{IPv4} en este tema, aunque mencionaremos algunas diferencias con \acrshort{IPv6}.

\subsubsection{Características de \acrshort{IPv4}}
\begin{itemize}
    \item Resuelve el direccionamiento en Internet en la capa de red, ya que cada tarjeta de red tiene una dirección IP\@.
    \item Realiza el encaminamiento (o retransmisión) salto a salto entre equipos y routers.
    \item Ofrece un servicio no orientado a conexión y no fiable, ya que:
    \begin{itemize}
        \item No hay establecimiento de conexión lógica entre las entidades.
        \item No hay control de errores ni de flujos. Los errores que se produzcan tienen que arreglarlos una capa superior si se precisa.
    \end{itemize}
    \item Gestiona la fragmentación para adaptarse al \acrshort{MTU} de cada tarjeta de red, como veremos. A la unidad de datos completa se le llama datagrama y a los fragmentos paquetes. 
    \item Es un protocolo de máximo esfuerzo, los datagramas se pueden perder, duplicar, retrasar, llegar desordenados\ldots
\end{itemize}

\subsection{Direccionamiento}

Para identificar cada equipo en la red, se usan direcciones IP\@. El lector posiblemente esté más familiarizado con las direcciones red, como \verb|www.google.com|, pero estas en realidad son nombres de dominio que se traducen a direcciones IP\@, como veremos en el Capítulo dedicado a la capa de aplicación. Mientras tanto, hemos de saber que todo equipo en la red tiene una dirección IP asociada. Además, esta (a priori) es única y no se puede repetir, lo que supone una limitación. Como más adelante veremos, para solventar este problema se usan también direcciones privadas, algo que no contemplaremos por el momento.\\

Una dirección \acrshort{IP} consta de 32 bits y la nomenclatura usada es: \verb|A.B.C.D| donde cada letra es un número decimal en el rango \verb|0-255| (ya que codificará 8 bits). El rango por tanto que tenemos es \verb|0.0.0.0-255.255.255.255.| Una dirección tiene dos partes bien diferenciadas, la que identifica la red y la que identifica el equipo en cuestión (en realidad, identifica la tarjeta de red).\\

Para saber qué parte de la dirección IP identifica el equipo y cuál la red, se emplea la máscara de red.
\begin{definicion}[Máscara de red]
    Es un conjunto de $32$ bits (al igual que una dirección IP) que se usa para identificar qué parte de la dirección IP identifica la red y cuál el equipo.Contiene los primeros $n$ bits consecutivos a $1$, y el resto a $0$.
\end{definicion}
\textbf{¿Cómo se usa la máscara?}\

Para saber cuál es la dirección de la red, se hace un \verb|AND| lógico entre la dirección IP y la máscara (por lo que nos quedaremos con los primeros $n$ bits de la dirección IP\@). El resto de bits identificará al equipo dentro de dicha red.\\

Notemos por tanto que, dentro de las posibles direcciones IP de una misma red, la dirección con todos los bits de equipo a 0 está \emph{reservada} para la dirección de la red, y no podrá asignarse a ningún equipo.
\begin{notacion}
    Es común querer dar una dirección IP junto a su máscara de red. Para esto, se podrá usar la notación \verb|A.B.C.D/n|, donde \verb|A.B.C.D| es la dirección IP en sí y \verb|n| es el número de bits a $1$ de la máscara de red. Como ya hemos mencionado que estos bits han de estar al inicio y consecutivos, sabiendo el valor de \verb|n| sabremos cuál es la máscara de red.
\end{notacion}

\begin{ejemplo}
    Supongamos que tenemos una dirección IP \verb|192.168.1.27/24|, y queremos saber cuál es la dirección de la red. Pasando a binario y haciendo un \verb|AND|, tenemos:
    \begin{equation*}
        \begin{array}{rcl}
            & 1100~0000~.~1010~1000~.~0000~0001~.~0001~1011 & \text{(dirección IP)}\\
            \texttt{AND} & 1111~1111~.~1111~1111~.~1111~1111~.~0000~0000 & \text{(máscara de red)}\\ \hline
            & 1100~0000~.~1010~1000~.~0000~0001~.~0000~0000 & \text{(dirección de la red)}
        \end{array}
    \end{equation*}
    Por tanto, pasando de nuevo a decimal, la dirección de la red es \verb|192.168.1.0|.
\end{ejemplo}

\subsubsection{Direccionamiento jeráriquico}
\noindent
Internet usa direccionamiento jerárquico basado en clases. Cada clase contiene las direcciones IP de un rango determinado:
\begin{itemize}
    \item Clase A $\rightarrow$ \verb|0xx|\ldots\verb|x/8| $\Longrightarrow $ \verb|0.0.0.0 - 127.255.255.255|. Tenemos $2^7~=~128$ redes con $2^{24} \approx 16\cdot 10^6$ equipos en cada una. 
    \item Clase B $\rightarrow$ \verb|10xx|\ldots\verb|x/16| $\Longrightarrow $ \verb|128.0.0.0 - 191.255.255.255|. Tenemos $2^{14}~=~16384$ redes con $2^{16}=65536$ equipos en cada una. 
    \item Clase C $\rightarrow$ \verb|110xx|\ldots\verb|x/24| $\Longrightarrow $ \verb|192.0.0.0 - 223.255.255.255|. Tenemos $2^{21}~\approx~2\cdot 10^6$ de redes con $2^{8} = 256$ equipos en cada una. 
    \item Clase D $\rightarrow$ \verb|1110xx|\ldots\verb|x| $\Longrightarrow$ \verb|224.0.0.0 - 239.255.255.255|. No se usa para identificar equipos ni redes sino para multidifusión (\textit{multicast}). Cada dirección identifica a todo un grupo de equipos. Para gestionar esto existe el protocolo \acrshort{IGMP} para suscribirse a grupos.
    \item Clase E $\rightarrow$ \verb|1111xx|\ldots\verb|x| $\Longrightarrow $ \verb|240.0.0.0 - 255.255.255.255|. Es el rango experimental; es decir, las direcciones que se dejan para hacer pruebas. 
\end{itemize}

\subsubsection{Direcciones reservadas}
Además de las restricciones de cada clase, hay determinadas direcciones que están reservadas y no se pueden asignar a ningún equipo. Algunas de estas direcciones son:
\begin{itemize}
    \item Dirección de red: Cualquier dirección IP con todos los bits de equipo a $0$. Está dedicada para identificar la red en sí.
    \item Dirección de difusión (\textit{broadcast}): Cualquier dirección IP con todos los bits de equipo a $1$. Se usa para enviar un paquete a todos los equipos de la red.
    
    Cuando se tiene que encontrar un equipo y no se sabe cuál, se manda por la dirección de difusión y lo escuchará quien tenga que escucharlo.

    \item \verb|127.a.b.c|: Denominada dirección de \textit{loopback}, \textit{localhost} o \textit{localloop}. Se usa para hacer pruebas, y es una conexión que hacemos a nuestra propia máquina. Originalmente (y la más común) era \verb|127.0.0.1|, pero en la actualidad se ha aumentado el rango.
    Estas redes no requieren de una tarjeta de red específica, y su interfaz de red se denomina \verb|lo|.
\end{itemize}

Llegados a este punto, podemos dar una definición más correcta de router, que ya habíamos mencionado anteriormente.
\begin{definicion}[Router]
    Es un dispositivo de la capa de red cuya funcionalidad principal es conectar distintas redes y encaminar los paquetes a través de ellas.
    
    Cuenta con varias tarjetas de red (también llamadas interfaces), una por cada red a la que se conecta, y cada una cuenta con una dirección IP asociada en cada red.\\

    Como curiosidad, es posible crear routers en un ordenador con varias tarjetas de red con \verb|Linux|. Con el comando \verb|sysctl -a| podemos consultar el valor de la variable \verb|net.ipv4.ip_forward|, que nos informa sobre si redirigimos paquetes o no. Si está con el valor $1$, dicho equipo es un router.
\end{definicion}

\begin{observacion}
    Como un switch funciona a nivel de enlace, todo lo conectado a dicho switch está en la misma red. Por tanto, tampoco tiene dirección IP asignada.
\end{observacion}

% // TODO: mencionar sobre dibujos de redes, switches, router domestico .. .

\subsubsection{Direccionamiento sin clases}

Si usamos solo el direccionamiento con clases estaríamos desperdiciando muchísimas direcciones IP. Por ejemplo, si tenemos 1000 equipos ($2^8<1000<2^16$) tendríamos que usar una red de clase B, con la que desperdiciaríamos más de 60.000 direcciones. La solución a este problema es usar el direccionamiento sin clase, que nos permite usar la máscara de red deseada.

\begin{itemize}
    \item \textbf{Subredes}\

    Si, por ejemplo, queremos una red de menos de 256 equipos, podemos aumentar el número de bits de la máscara a $1$, para conseguier más bits dedicados a identificar la red y menos para identicar equipos. Cada vez que añadimos un bit a la máscara, estamos dividiendo una red en dos mitades. 
    \begin{ejemplo}
        Supongamos que queremos identificar 100 equipos dentro de una misma red. Contando además con la dirección de red y la de difusión, necesitamos 102 direcciones. Como $2^6<102<2^7$, necesitamos 7 bits para identificar a los equipos. Por tanto, la máscara a usar será \verb|/25|.
    \end{ejemplo}
        \item \textbf{Superredes}\

            Si hacemos el procedimiento inverso, quitarle un bit a la máscara, duplicamos la cantidad de equipos que podemos direccionar. Por ejemplo, en \verb|/23| estamos juntando dos redes de clase C. 
    \begin{ejemplo}
        Supongamos que queremos una red de 1000 equipos. Contando con la dirección de red y la de difusión, necesitamos 1002 direcciones. Como $2^9<1002<2^{10}$, necesitamos 10 bits para identificar a los equipos. Por tanto, la máscara a usar será \verb|/22|.
    \end{ejemplo}
\end{itemize}


Como vemos el funcionamiento es igual que en el direccionamiento con clase, pero reduce significativamente (aunque no elimina) el desperdicio de direcciones. A nivel práctico red, subred y superred no se diferencian, y nos referimos a todas ellas como redes.


%Vamos a ver un par de ejemplos de asignaciones de direcciones en subredes y superredes. 
% // TODO: hacer el dibujo del circulo (/27) pag 11 de los apuntes
% // TODO: hacer el ejemplo del /22 (700 equipos)


\subsubsection{Direcciones privadas}

Como hemos venido mencionando en distintas ocasiones, la escasez de direcciones es un gran problema presente en \acrshort{IPv4}, ya que tan solo hay $2^{32}$ direcciones posibles, las cuales ya se agotaron en Noviembre de 2019. Aunque se vayan recopilando direcciones de sitios obsoletos, empresas desaparecidas, etc. el problema sigue existiendo.\\

Hay varias soluciones posibles para solventarlo.
\begin{itemize}
    \item Direccionamiento sin clase: es una solucion que reduce el desperdicio de direcciones, peero aun así tiene la limitación de $2^{32}$ direcciones.
    \item \acrshort{IPv6}, el cual usa 128 bits para las direcciones. La notación utilizada es\

        \verb|FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF|, en el que cada dígito es un número hexadecimal.

    En total hay $2^{128}$ direcciones posibles (más de $10^{37}$), lo que en la práctica las hace ilimitadas. Aunque sea compatible con \acrshort{IPv4}, la transición está siendo lenta.
    \item Direcciones privadas: esta es la principal solución que se usa en la actualidad, ya que hace el número de direcciones prácticamente ilimitado. Desarrollaremos este concepto a continuación.
\end{itemize}

\begin{description}
    \item [Direcciones públicas:] Cada dirección se asigna a un único dispositivo en todo Internet. Se asignan centralizadamente\footnote{Inicialmente por \acrshort{IANA}, actualmente por \acrshort{ICANN}.}, y como son limitadas, hay que pagar por cada una.
    \item [Direcciones privadas:] Solo se pueden usar en redes privadas o \textit{intranets}, sin acceso directo al resto de Internet. Por tanto, al no ser accesibles desde fuera, se pueden repetir en distintas redes privadas, lo que aumenta el número de direcciones disponibles.
    
    Para poder comunicarse con el resto de Internet (ya que si no tendrían poca utilidad), será necesario una dirección pública por la cual se haga la comunicación. Para esto se usa el \acrshort{NAT}, que veremos más adelante.
\end{description}

Respecto al direccionamiento jerárquico con clases, dentro de cada clase se definen algunos rangos de direcciones a usar como IP privadas. Estos rangos son:
\begin{itemize}
    \item Clase A $\rightarrow$ \verb|10.x.y.z/8|
    \item Clase B $\rightarrow$ \verb|172.16-32.y.z/16|
    \item Clase C $\rightarrow$ \verb|192.168.y.z/24|
\end{itemize}



\subsection{\acrfull{NAT}}

Como hemos mencionado anteriormente, para que una red privada pueda comunicarse con el resto de Internet, es necesario que haya una dirección pública que haga de intermediario. Para esto se usa la técnica de \acrshort{NAT}, que posibilita la traducción de direcciones.
Al encontramos en la capa de red, el \acrshort{PDU} contiene la cabecera IP que contiene, entre otros datos:
\begin{itemize}
    \item Dirección IP origen ({IPsc}) junto con el puerto origen ({sport}).
    \item Dirección IP destino ({IPdest}) junto con el puerto destino ({dport}).
\end{itemize}

El concepto de puerto lo veremos más adelante y desarrollaremos a fondo en la Capa de Transporte. Por el momento, tan solo es necesario saber que es un número que se asigna a cada proceso que se comunica en la red, y que se usa para saber a qué proceso enviar la respuesta.\\

Para posibilitar la traducción, se usa una tabla de direcciones a modo de ``diccionario'', tal y como introducimos a continuación.
\begin{definicion}[Tabla de traducciones]
    La Tabla de Traducciones es una tabla que se guarda en la memoria de todo router que haga \acrshort{NAT}.
    Por cada traducción que deba hacerse, se guarda una entrada en la tabla que relaciona la dirección IP y puerto originales con la dirección IP y puerto traducidos.

    La tabla se va actualizando con cada nueva traducción, y cuenta con un temporizador (normalmente de 5 minutos) que borra las entradas que lleven un tiempo sin usarse. De esta forma, se evita que la tabla se sature y se libera memoria.

    En el caso de que llegue una petición que ya esté en la tabla, se reutiliza la información de la tabla, sin crearse una nueva entrada.
\end{definicion}

\begin{definicion}[\textit{Masquerading}]
    Proceso de enmascaramiento que hace el router al traducir la dirección privada del equipo en su dirección pública.

    Se ``enmascara'' la dirección privada, de forma que el servidor no sabe a qué equipo de la red privada está respondiendo.
\end{definicion}

\begin{observacion}
    El uso de \acrshort{NAT} plantea un problema de seguridad. Un atacante, conociendo la IP pública del router, puede hacer un barrido de puertos y puede conseguir que algún paquete entre. En tal caso, el router le responderá, y el atacante sabrá que hay un equipo detrás de esa IP pública y puerto, por lo que podrá intentar atacar a ese equipo.
    
    Para evitar esto, para cada traducción puede guardarse tanto las IP y puerto de origen y destino sin traducir, como las traducidas. De esta forma, si llega una petición que coincide con la IP y puerto origen, pero no con la IP y puerto destino, se descarta directamente. Esta técnica se denomina \textit{NAT estricto}.
\end{observacion}


Hay dos tipos de \acrshort{NAT}, en función de dónde y cuándo se haga la traducción.
\begin{description}
    \item [\acrfull{SNAT}:] el origen de los datos está en una red privada. Por tanto, al enviarse se cambia la dirección IP de origen, y la traducción a la correcta (en la respuesta) se hará tras el encaminamiento (\textit{postrouting}).
    \item [\acrfull{DNAT}:] el origen de los datos está en la red pública. Por tanto, al recibir los datos se cambia la dirección IP de destino, y la traducción a la correcta (en la respuesta) se hará antes del encaminamiento (\textit{prerouting}).
    
    En este caso la tabla de traducciones del router que realiza \acrshort{DNAT} ha de ser estática (la inserción debe ser a mano), ya que en otro caso el router no sabrá a donde redirigir las peticiones entrantes. Este proceso se denomina \textit{port forwarding}.
\end{description}


Planteemos un primer ejemplo de \acrshort{SNAT}, que nos ayudará a comprender cómo funciona esta técnica.
\begin{ejemplo}
    Supongamos la situación de la Figura~\ref{fig:ejemplo_nat}, en la que un portátil dentro de una red privada quiere acceder a un servidor HTTP en Internet.
    \begin{figure}
        \centering
        \begin{tikzpicture}[node distance=6cm]

            \node[laptop] (laptop) {};
            \node[below= 0 of laptop] {192.168.1.2/24};
            
            \node[router, right of=laptop] (router) {};
            %\node[below=0cm of router] {222.222.222.222/24};

            \node[cloud, right of=router, xshift=-3cm] (internet) {Internet};
    
            \node[server, right of=internet, xshift=-2cm] (server) {};
            \node[below=0cm of server] {66.66.66.66/24};
    
            \draw (laptop) -- (router) -- (internet) -- (server);
    
            % Conexiones del router
            \draw[fill] (router.west) circle [radius=0.1cm];
            \draw (router.west) -- ++(0,-1) node[below] {192.168.1.1/24};
            \draw[fill] (router.east) circle [radius=0.1cm];
            \draw (router.east) -- ++(0,1) node[above] {33.33.33.33/24};

            % 1: Petición del portátil al router
            \draw[-Stealth, dashed] ($(laptop.east) + (0.5,0.5)$) -- ($(router.west) + (-0.5,0.5)$) node[midway, above] {1};

            % 2: Petición del router a Internet
            \draw[-Stealth, dashed] ($(router.east) + (0.1,0.5)$) -- ($(internet.west) + (-0.1,0.5)$) node[midway, above] {};
            \draw[-Stealth, dashed] ($(internet.east) + (0.2,0.5)$) -- ($(server.west) + (-0.2,0.5)$) node[midway, above] {2};

            % 3: Respuesta del servidor al router
            \draw[-Stealth, dashed] ($(server.west) + (-0.2,-0.5)$) -- ($(internet.east) + (0.2,-0.5)$) node[midway, below] {3};
            \draw[-Stealth, dashed] ($(internet.west) + (-0.1,-0.5)$) -- ($(router.east) + (0.1,-0.5)$) node[midway, below] {};

            % 4: Respuesta del router al portátil
            \draw[-Stealth, dashed] ($(router.west) + (-0.5,-0.5)$) -- ($(laptop.east) + (0.5,-0.5)$) node[midway, below] {4};
        
        \end{tikzpicture}
        \caption{Ejemplo de red con \acrshort{SNAT}.}
        \label{fig:ejemplo_nat}
    \end{figure}

    El equipo envía una petición al router (1), que este reenvía al servidor (2). El servidor responde al router (3), que a su vez reenvía la respuesta al equipo (4). Se trata de \acrshort{SNAT}, ya que la petición parte de una red privada. Veamos qué ocurre en cada uno de los pasos:
    \begin{enumerate}[label=(\arabic*)]
        \item El ordenador envía una petición \acrshort{HTTP} al router.
        
        El puerto de origen, el cual asignará alteatoriamente el SO (ya se verá), pongamos que es el 1075. El puerto de destino, en el caso de \acrshort{HTTP}, es el 80. Por tanto, la cabecera IP del paquete que envía el portátil al router contendrá:
        \begin{itemize}
            \item {IPsc}:{sport}: \verb|192.168.1.2:1075|.
            \item {IPdest}:{dport}: \verb|66.66.66.66:80|.
        \end{itemize}
            
        \item El router ha de realizar la traducción de direcciones, ya que la IP del portátil es privada y no puede ser usada en Internet. Para esto, modifica la cabecera IP poniendo como IP origen su propia IP pública, y como puerto origen un puerto que aún no haya sido usado (por ejemplo, 12345). La cabecera IP así:
        \begin{itemize}
            \item {IPsc}:{sport}: \verb|33.33.33.33:12345|.
            \item {IPdest}:{dport}: \verb|66.66.66.66:80|.
        \end{itemize}

        La tabla de traducciones del router quedaria (donde notamos con ``$'$'' la traducida):
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c||c|c|}
                \hline
                IPsc & sport & IPsc$'$ & sport$'$ \\
                \hline
                \verb|192.168.1.2| & \verb|1075| & \verb|33.33.33.33| & \verb|12345|\\
                \hline
            \end{tabular}
            \caption{Tabla de traducciones del router con SNAT.}
            \label{tab:tabla_traducciones}            
        \end{table}

        Tras esta traducción, el router envía el paquete al servidor.
        
        \item Tras el procesamiento del paquete en el servidor, este envía la respuesta al router. La cabecera IP del paquete de respuesta contendrá:
            \begin{itemize}
                \item {IPsc}:{sport}: \verb|66.66.66.66:80|.
                \item {IPdest}:{dport}: \verb|33.33.33.33:12345|.
            \end{itemize}
        
        \item El paquete llega sin problema al router, ya que la IP de destino es pública. El router debe realizar de nuevo la traducción para saber a qué equipo de la red privada debe enviar la respuesta. Para ello, consulta la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones}) y, tras modificar de nuevo la cabecera IP (\textit{postrouting}), esta queda:
            \begin{itemize}
                \item {IPsc}:{sport}: \verb|66.66.66.66:80|.
                \item {IPdest}:{dport}: \verb|192.168.1.2:1075|.
            \end{itemize}
    \end{enumerate}
\end{ejemplo}


Planteamos ahora el siguiente ejemplo de \acrshort{DNAT}, que nos ayudará ahora a comprender cómo funciona esta técnica.
\begin{ejemplo}
    Supongamos la situación de la Figura~\ref{fig:ejemplo_dnat}, en la que un portátil dentro de una red privada quiere acceder a un servidor HTTP en Internet.
    \begin{figure}
        \centering
        \begin{tikzpicture}[node distance=6cm]

            \node[server] (server) {};
            \node[below= 0 of server] {192.168.1.2/24};
            
            \node[router, right of=server] (router) {};
            %\node[below=0cm of router] {222.222.222.222/24};

            \node[cloud, right of=router, xshift=-3cm] (internet) {Internet};
    
            \node[laptop, right of=internet, xshift=-2cm] (laptop) {};
            \node[below=0cm of laptop] {66.66.66.66/24};
    
            \draw (server) -- (router) -- (internet) -- (laptop);
    
            % Conexiones del router
            \draw[fill] (router.west) circle [radius=0.1cm];
            \draw (router.west) -- ++(0,-1) node[below] {192.168.1.1/24};
            \draw[fill] (router.east) circle [radius=0.1cm];
            \draw (router.east) -- ++(0,1) node[above] {33.33.33.33/24};

            % 1: Petición del laptop al router
            \draw[-Stealth, dashed] ($(laptop.west) + (-0.2,0.5)$) -- ($(internet.east) + (0.2,0.5)$) node[midway, above] {1};
            \draw[-Stealth, dashed] ($(internet.west) + (-0.1,0.5)$) -- ($(router.east) + (0.1,0.5)$) node[midway, above] {};

            % 2: Petición del router a Internet
            \draw[-Stealth, dashed] ($(router.west) + (-0.5,0.5)$) -- ($(server.east) + (0.5,0.5)$) node[midway, above] {2};

            % 3: Respuesta del sever al router
            \draw[-Stealth, dashed] ($(server.east) + (0.5,-0.5)$) -- ($(router.west) + (-0.5,-0.5)$) node[midway, below] {3};

            % 4: Respuesta del router al laptop
            \draw[-Stealth, dashed] ($(router.east) + (0.1,-0.5)$) -- ($(internet.west) + (-0.1,-0.5)$) node[midway, below] {};
            \draw[-Stealth, dashed] ($(internet.east) + (0.2,-0.5)$) -- ($(laptop.west) + (-0.2,-0.5)$) node[midway, below] {4};        
        \end{tikzpicture}
        \caption{Ejemplo de red con \acrshort{DNAT}.}
        \label{fig:ejemplo_dnat}
    \end{figure}

    El equipo envía una petición al router (1), que este reenvía al servidor (2). El servidor responde al router (3), que a su vez reenvía la respuesta al equipo (4). Se trata de \acrshort{DNAT}, ya que la petición parte de la red pública. Veamos qué ocurre en cada uno de los pasos:
    \begin{enumerate}[label=(\arabic*)]
        \item El ordenador envía una petición \acrshort{HTTP} al router.
        
        El puerto de origen pongamos que es el 1050. El puerto de destino, tras la traducción efectivamente ha de ser el 80 (ya que es un servidor \acrshort{HTTP}). No obstante, antes de la traducción este puerto ha de ser el correspondiente al puerto que hayamos asignado al servidor \acrshort{HTTP} al que queremos acceder. Por ejemplo, sea la tabla de traducciones del router la de la Tabla~\ref{tab:tabla_traducciones_DNAT} (que hemos de haber configurado previamente en el \textit{port forwarding}).
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c||c|c|}
                \hline
                IPdest & dport & IPdest$'$ & dport$'$ \\
                \hline
                \verb|33.33.33.33| & \verb|23456| & \verb|192.168.1.2| & \verb|80|\\
                \hline
            \end{tabular}
            \caption{Tabla de traducciones del router con \acrshort{DNAT}.}
            \label{tab:tabla_traducciones_DNAT}
        \end{table}

        En tal caso, el puerto de destino será el 23456. Por tanto, la cabecera IP del paquete que envía el portátil al router contendrá:
            \begin{itemize}
                \item {IPsc}:{sport}: \verb|66.66.66.66:1050|.
                \item {IPdest}:{dport}: \verb|33.33.33.33:23456|.
            \end{itemize}
        Notemos que la IP de destino no es el servidor como tal, sino el router (ya que es es al que tiene acceso el portátil), y el puerto de destino es el que hemos asignado en la tabla de traducciones para el servidor \acrshort{HTTP} al que queremos acceder.
            
        \item Tras llegar al router, este ha de realizar la traducción de direcciones (\textit{prerouting}), ya que la IP de destino era el router mismo. Consultando la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones_DNAT}), la cabecera IP del paquete que envía el router al servidor quedará:
            \begin{itemize}
                \item {IPsc}:{sport}: \verb|66.66.66.66:1050|.
                \item {IPdest}:{dport}: \verb|192.168.1.2:80|.
            \end{itemize}

        Tras esta traducción, el router envía el paquete al servidor (ya en la red privada).
        
        \item Tras el procesamiento del paquete en el servidor, este envía la respuesta al router. La cabecera IP del paquete de respuesta contendrá:
            \begin{itemize}
                \item {IPsc}:{sport}: \verb|192.168.1.2:80|.
                \item {IPdest}:{dport}: \verb|66.66.66.66:1050|.
            \end{itemize}
        
        \item El paquete llega sin problema al router, ya que la IP de destino es pública. El router debe realizar de nuevo la traducción para saber ahora de qué equipo de la red privada proviene la petición. Para ello, consulta de nuevo la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones}) y, tras modificar de nuevo la cabecera IP, esta queda:
            \begin{itemize}
                \item {IPdest}:{dport}: \verb|33.33.33.33:23456|.
                \item {IPdest}:{dport}: \verb|66.66.66.66:1050|.
            \end{itemize}
    \end{enumerate}

    Notemos que, en el \acrshort{SNAT}, la tabla de traducciones se va actualizando con cada nueva traducción, mientras que en el \acrshort{DNAT} la tabla de traducciones ha de ser estática, ya que en otro caso el router no sabrá a donde redirigir las peticiones entrantes.
\end{ejemplo}

\subsection{Encaminamiento}
Se dice del proceso de encontrar el mejor camino para llevar la información (paquetes) de un origen a un destino dado. Como se vió en la Sección~\ref{sec:conmutacion_de_datagramas}, este se realiza salto a salto y paquete a paquete en función de la dirección IP destino del paquete y de las tablas de encaminamiento que hay en cada uno de los routers.

\subsubsection{Tablas de encaminamiento}

Las tablas de encaminamiento son tablas que se guardan en la memoria de todo equipo conectado a la red (tanto hosts como routers), que informan sobre las redes a las que se puede llegar y la mejor forma de llegar a ellas.\\

Veamos los campos que tienen estas tablas, donde notaremos entre paréntesis aquellos que tienen menor relevancia y que incluso no son siempre necesarios.
\begin{itemize}
    \item Red destino: Red a la que pertenecerá la dirección IP de destino, y a la cual queremos llegar.
    \item Máscara de red: Máscara de red correspondiente a dicha red de destino.
    \item Siguiente salto: Nodo al que debemos reenviar el paquete para que llegue a la red de destino.
    \item (Interfaz de salida del equipo), dato que puede ser redundante. 
    \item (Protocolo).
    \item (Flags).
    \item (Coste): Coste esperado para llegar a dicha dirección IP de destino. Este se puede medir, por ejemplo, mediante el número de saltos que se han de realizar.
\end{itemize}

Hay distntos tipos de rutas que se pueden almacenar en una tabla de encaminamiento:
\begin{description}
    \item [Rutas directas:] (marcadas con $\ast$ en el campo de ``Siguiente salto''). Estas son las redes a las que tenemos conexión directa, sin realizar ningún salto. Podemos enviar directamente el paquete al destinatario sin necesidad de pasar por nodos intermedios.
    
    Un router tiene acceso directo a las redes que interconecta (por lo que tendrá una entrada de este tipo por cada red), mientras que un host suele estar en una única red (por lo que tan solo tendrá una entrada de este tipo).

    En la mayoría de los casos, cuando se asigna una dirección IP a determinada tarjeta de red de un equipo, se almacena la entrada de esta ruta directa de forma automática.
    \item [Rutas indirectas:] Estas son las redes a las que no tenemos conexión directa, pero sí a través de un intermediario. Por tanto, es necesario dar mínimo un salto para llegar al destino.
     
    \item [Entrada por defecto:] (notado por \verb|0.0.0.0| o \verb|default| en red destino y \verb|/0| en máscara). Hace referencia a cualquier red que no haya sido aceptada por el resto de entradas. El equipo que se encuentra en el campo de ``Siguiente salto'' será el que nos conexta con el exterior, y lo denominaremos \emph{pasarela} o \textit{gateway}.
    
    Esta entrada no siempre es necesaria, aunque permite que no se produzcan errores (puesto que siempre habrá, al menos, una entrada válida para cada dirección IP, como más adelante veremos).
    
    \begin{comment}
    Además, poner simplemente un \verb|\0| en máscara es equivalente a una entrada por defecto (algo que veremos cuando entendamos el uso de estas tablas).
    \end{comment}

    \item [Entrada de \texttt{localhost}:] En el caso de que queramos usar esta técnica, también debe haber una entrada en la tabla de encaminamiento con este fin. Su red de destino será \verb|localhost|, y su interfaz, como mencionamos anteriormente, será \verb|lo|.
\end{description}

\noindent
Tenemos dos tipos de encaminamientos:
\begin{description}
    \item [Estático:] La tabla de encaminamiento se rellena a mano.
    \item [Dinámico:] La tabla de encaminamiento se rellena de forma automática, ya que hay un protocolo (\acrshort{RIP}, \acrshort{OSPF}\ldots) que se encarga de actualizarla. Tiene como ventaja que es dinámica (puede cambiar), ya que si se cae cierto router se puede buscar otro camino para llegar al destino.
\end{description}

\begin{observacion}
    En casos muy específicos (menos del $0.1\%$), se puede encaminar en función de la dirección IP origen, pero este caso no se desarrollará en la asignatura.
\end{observacion}

\subsubsection{Uso de la tabla de encaminamiento}

En esta sección entenderemos cómo funcionan estas tablas. Dada una dirección IP de destino, buscamos saber cuál es la dirección IP del nodo al que debemos enviarle el paquete para que este, finalmente, llegue al destino.\\

Para esto, buscamos las redes de destino de la tabla de encaminamiento que admitan a la dirección IP de destino. Para ello, se hace la operación lógica \verb|AND| entre la dirección IP de destino y la máscara de cada entrada, y si el resultado coincide con la red de destino entonces dicha entrada es válida para dicha IP\@.
\begin{itemize}
    \item Si no hay ninguna entrada válida, se envía un mensaje de error \acrshort{ICMP}, pero no se intenta solventar dicho error.
    \item Si hay más de una entrada válida, se escogerá aquella con la máscara de red más restrictiva, ya que la red de destino será más pequeña, teniendo así (a priori) una conexión más directa. Esto lo veremos en detalle en el próximo ejemplo.
\end{itemize}

Por tanto, una vez que tenemos la entrada asignada a la dirección IP de destino, se envía el paquete a la dirección IP del siguiente salto, continuando así el encaminamiento hasta llegar al destino.

\begin{ejemplo}\label{ejemplo:tabla_encaminamiento}
    Veamos un ejemplo de encaminamiento. Supongamos que estamos en la situación de la Figura~\ref{fig:ejemplo_tabla_encaminamiento}, y que la tabla de encaminamiento de R6 es la que se muestra en la Tabla~\ref{tab:encaminamientoR6} (donde hemos notado por \verb|IP_Exterior| a la IP del siguiente router que nos conecta con Internet).
    \begin{figure}
        \centering
        \resizebox{1\textwidth}{!}{
        \begin{tikzpicture}[node distance=3cm]

            \node[laptop] (l1) {};
            \node[laptop, right of=l1] (l2) {};
            \node[laptop, right of=l2] (l3) {};
            \node[laptop, right of=l3] (l4) {};
            \node[laptop, right of=l4] (l5) {};
            \node[laptop, right of=l5] (l6) {};
            \node[router, below of=l1, xshift=1.5cm] (r1) {};
            \node[router, below of=l3, xshift=1.5cm] (r2) {};
            \node[router, below of=l5, xshift=1.5cm] (r3) {};
            \node[router, below of=r1, xshift=3cm, yshift=1cm] (r4) {};
            \node[router, below of=r3, xshift=-3cm, yshift=1cm] (r5) {};
            \node[router, below of=r4, xshift=3cm, yshift=1cm] (r6) {};

            % Bucle for para marcar los routers
            \foreach \i in {1,...,6} {
                \node[yshift=-0.8em] at (r\i) {\color{white} \textbf{R\i}};
            }
            % Bucle for para marcar los laptops
            \foreach \i in {1,...,6} {
                \node[xshift=0.7em, yshift=0.7em] at (l\i) {\color{white} \textbf{L\i}};
            }

            \node[cloud, right of=r6] (cloud) {Internet};


            % Conexiones
            \draw[red] (l1.south) |- ($(r1.north) + (0,0.5)$) -| (l2.south);
            \draw[red] ($(r1.north) + (0,0.5)$) -- (r1.north);
            \draw (l3.south) |- ($(r2.north) + (0,0.5)$) -| (l4.south);
            \draw ($(r2.north) + (0,0.5)$) -- (r2.north);
            \draw (l5.south) |- ($(r3.north) + (0,0.5)$) -| (l6.south);
            \draw ($(r3.north) + (0,0.5)$) -- (r3.north);

            \draw[olive] (r1.east) -- (r2.west);
            \draw[olive] ($(r4.north) + (0,1.1)$) -- (r4.north);
            \draw (r2.east) -- (r3.west);
            \draw ($(r5.north) + (0,1.1)$) -- (r5.north);
            \draw[blue] (r4.east) -- (r5.west);
            \draw[blue] ($(r6.north) + (0,1.1)$) -- (r6.north);

            \draw (r6.east) -- (cloud.west);

            % Conexiones adicionales
            \draw[red] ($(l1.south) - (0,0.65)$) |- ($(r6.south) - (0,0.5)$) -- (r6.south);
            \draw[olive] ($(r1.east) + (0.5,0)$) |- (r6.west);

            % Conexiones del router r1
            %\draw[fill, red] (r1.north) circle [radius=0.1cm];
            %\draw[red] (r1.north) -- ++(0.5,0) node[right] {192.168.0.1/27};
            %\draw[fill, olive] (r1.east) circle [radius=0.1cm];
            %\draw[olive] (r1.east) |- ($(r1.south) +(0,0)$) -- ($(r1.south) +(0,-0.2)$) node[below] {192.168.0.1/24};

            % Conexiones del router r4
            %\draw[fill, olive] (r4.north) circle [radius=0.1cm];
            %\draw[olive] (r4.north) -- ++(0.5,0) node[right] {192.168.0.2/24};
            %\draw[fill, blue] (r4.east) circle [radius=0.1cm];
            %\draw[blue] (r4.east) |- ($(r4.east) +(0,0.4)$) -- ($(r4.east) +(0.2,0.4)$) node[right] {192.168.0.1/16};

            % Conexiones del router r6
            %\draw[fill, blue] (r6.north) circle [radius=0.1cm];
            %\draw[blue] (r6.north) -- ++(0.5,0) node[right] {192.168.0.2/16};
            %\draw[fill, olive] (r6.west) circle [radius=0.1cm];
            %\draw[olive] (r6.west) |- ($(r6.west) +(0,-0.2)$) -- ($(r6.west) +(-0.2,-0.2)$) node[left] {192.168.0.3/24};
            %\draw[fill, red] (r6.south) circle [radius=0.1cm];
            %\draw[red] (r6.south) -- ($(r6.south) +(0.5,0)$) node[right] {192.168.0.3/27};

            % Conexiones del L1
            \draw[red] (l1.north) node[above] {192.168.0.2/27};

            % Redes
            \node[red, above] at ($(r1.north) + (0,0.5)$) {192.168.0.0/27};
            \node[olive, above] at ($(r4.north) + (0,1.1)$) {192.168.0.0/24};
            \node[blue, above] at ($(r6.north) + (0,1.1)$) {192.168.0.0/16};
        \end{tikzpicture}}
        \caption{Situación para el ejemplo de la página~\pageref{ejemplo:tabla_encaminamiento}.}
        \label{fig:ejemplo_tabla_encaminamiento}
    \end{figure}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            {Red de Destino} & {Máscara} & {Siguiente Salto} & {Interfaz}\\ \hline
            192.168.0.0 & {\color{red}/27} & $*$ & {\color{red}-}\\
            192.168.0.0 & {\color{olive}/24} & $*$ & {\color{olive}-}\\
            192.168.0.0 & {\color{blue}/16} & $*$ & {\color{blue}-}\\
            \verb|default| & {/0} & \verb|IP_Exterior| & -\\
            \hline
        \end{tabular}
        \caption{Tabla de encaminamiento de R6 para la Figura~\ref{fig:ejemplo_tabla_encaminamiento}.}
        \label{tab:encaminamientoR6}
    \end{table}

    Supongamos que a R6 le llega un paquete con destino L1 (dirección IP de destino \verb|192.168.0.1|). Tras hacer el \verb|AND| con cada una de las máscaras, vemos que las 4 entradas son válidas para dicha dirección IP\@. No obstante, la máscara más restrictiva es \verb|/27|, por lo que se elegirá dicha entrada y, por tanto, reenviará el paquete por la interfaz de red de R6 que pertenece a dicha red de destino. Esto permite que el camino se haga directo, con menos saltos.
\end{ejemplo}


% // TODO: Por aquí, agrupamiento

A veces es útil minimizar las tablas de encaminamiento, agrupando las redes con las que se trabaja. A menudo tenemos que compartir las tablas de encaminamiento (como veremos en algunos de los siguientes protocolos) y para ello lo mejor es que sean lo más compactas posible. Lo ideal es tener una entrada por cada interfaz del dispositivo. 

\subsubsection{Protocolos de intercambio de información de encaminamiento}

Para facilitar la administración y aumentar la escalabilidad, Internet se jerarquiza en \acrfull{AS}, redes muy grandes gestionadas por una autoridad. Los \acrshort{AS} suelen ser del orden de un país. Se definen dos niveles de encaminamiento (intercambio de tablas):
\begin{itemize}
    \item Algoritmos \acrfull{IGP}: \acrshort{RIP}, \acrshort{OSPF}\ldots Es dentro de cada \acrshort{AS}.
    \item Algoritmos \acrfull{EGP}: \acrshort{BGP}. Es entre distintos \acrshort{AS}.
\end{itemize}

\subsection{\acrfull{RIP}}

Aunque es una funcionalidad de la capa de red, se implementa sobre la capa de aplicación, opera sobre \acrshort{UDP} en el puerto 520 (son cosas independientes la funcionalidad y la implementación). \\

Es un protocolo que adopta un algoritmo vector-distancia, es decir, se basa exclusivamente en el número de saltos, ignorando la velocidad. Una vez que aprende un camino, no aprende otro a no ser que mejore el anterior.\\

Cuando un router RIP se enciende y es configurado, recibe de todos sus vecinos (dirección multicast 224.0.0.9) por defecto cada 30 segundos, los vectores-distancia para todos los posibles destinos, es decir, información sobre las rutas a las que saben llegar. De entre ellos, para un destino dado, se elige el camino de menor coste y se guarda la información sumando 1 al coste anunciado por dicho vecino. \\

La dirección multicast que mencionábamos antes la escuchan todos los routers que soportan \acrshort{RIP}.\\ 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{./images/cuenta-infinito-rip.png}
    \label{fig:rip}
\end{figure}

Un problema que puede ocurrir es que algún camino se rompa y, dado la naturaleza del protocolo, esto tarda en notificarse. En el ejemplo que vemos arriba, R1 es notificado de que ya no es posible llegar a la red 1 por el camino que tenía aprendido. Pero R2, que aún no ha sido notificado, le comunica que él sabe llegar, por tanto R1 lo aprende. Cuando R2 se entera pasa un poco lo mismo, que aprende el camino por R1. Así pasa hasta el infinito (que en el caso de \acrshort{RIP} es equivalente a coste 16). Por esto a esto se le llama problema de la ``cuenta al infinito''. Veamos algunas posibles soluciones:
\begin{description}
    \item [Split horizon:] Se basa en que a un router se le prohíbe compartir una ruta por la misma interfaz por la que la aprendió en primer lugar.
    \item [Hold down:] Retrasa los mensajes que nos llegan de una dirección que ya conocemos 180 segundos, esperando a que nos respondan los anteriores, si siguen activos. 
    \item [Poison reverse:] Si no sabemos llegar a un destino, decimos que el coste es infinito (coste = 16).
\end{description}

\subsection{\acrfull{OSPF}}

Este protocolo permite definir el coste. Tiene un criterio por defecto, en el que el coste de un enlace es el inverso del ancho de banda (la velocidad) de dicho enlace. Busca el camino global que minimiza la suma de todos los costes usando Dijkstra. \\

Permite definir áreas, de forma que la difusión se hace en unas áreas concretas. Esto hace que sea mucho más escalable, al contrario que \acrshort{RIP}.\\

\noindent
Los mensajes que tenemos son:

\begin{itemize}
    \item Hello: para saludar a mis vecinos.
    \item Database description: para mandar la topología que conocemos. 
    \item Link status request/update/ack: para consultar o enviar cambios.
\end{itemize}


\subsection{Cabecera IP}
La cabecera IP tiene 20 Bytes. Veamos los campos, en orden, que la componen:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{./images/cabecera-ip.png}
\end{figure}

\begin{itemize}
    \item Versión (4 bits): La versión utilizada de \acrshort{IP}, 0100 si \acrshort{IPv4} y 0110 si \acrshort{IPv6}. 
    \item Tamaño de cabecera (4 bits): longitud de la cabecera IP en palabras de 32 bits. Como mínimo 5 palabras y como máximo 15 palabras.
    \item Tipo de Servicio (8 bits): hace referencia a la calidad de servicio deseada durante el tránsito del paquete por una red. Hay redes que ofrecer prioridades de servicios, considerando determinados tipos de paquetes más prioritarios que otros.
    \item Longitud total (16 bits): es el tamaño total, en octetos, del datagrama, incluyendo el tamaño de la cabecera y el de los datos.
    \item Identificador (16 bits): identificador único del datagrama. Se utiliza en caso de que el datagrama deba ser fragmentado, para poder distinguir los fragmentos de un datagrama de los de otro.
    \item Flags (3 bits): En la actualidad se utiliza para especificar valores relativos a la fragmentación.
        \begin{itemize}
            \item bit 0: Reservado, debe ser 0.
            \item bit 1 (DF): 0 = divisible; 1 = no divisible.
            \item bit 2 (MF): 0 = último fragmento; 1 = fragmento intermedio, le siguen más fragmentos. 
        \end{itemize}
    \item Desplazamiento (13 bits): en paquetes fragmentados indica la posición, en unidades de 64 bits, que ocupa dentro del datagrama original. 
    \item Tiempo de vida, \acrshort{TTL} (8 bits): indica el número de saltos máximo de un paquete en una red para evitar paquetes navegando en la red indefinidamente. En cada salto, el campo se reduce en una unidad, si llega a 0 se descarta.
    \item Protocolo (8 bits): tiene un identificador del protocolo de las capas superiores al que debe entregarse el paquete.
    \item Suma de Control de Cabecera (16 bits): es una comprobación de la corrección del datagrama. Se recalcula cada vez que algún nodo cambia alguno de sus campos. El método de cálculo consiste en suma en complemento a 1 cada palabra de 16 bits de la cabecera (poniendo 0 en este campo) y hacer el complemento a 1 del valor resultante. Así cuando llega al destino se hace esta misma operación y se comprueba si es correcta la cabecera.
    \item Dirección IP de origen (32 bits).
    \item Dirección IP de destino (32 bits).
    \item Opciones (opcional).
    \item Relleno: este campo tiene tantos como sea necesario para que la cabecera tenga un número de bits múltiplo de 32. 
\end{itemize}

\subsection{Fragmentación}
Las redes no permiten paquetes de cualquier tamaño. El tamaño máximo es $2^{16}$ Bytes, aunque ninguna red suele aceptar dicho tamaño. \\

Las redes cuentan con un \acrfull{MTU}: esta nos dice cuál es el tamaño máximo de lo que podemos transportar en la capa de datos a nivel de enlace, es decir, datos y cabecera de IP normalmente. \\ 

El \acrshort{MTU} depende del estándar de una tarjeta:
\begin{itemize}
    \item Ethernet: 1500 Bytes.
    \item Wifi: permite más pero normalmente el punto de acceso lo restringe a 1500 Bytes.
\end{itemize}

\noindent
Tenemos los siguientes campos en la cabecera de fragmentación:
\begin{itemize}
    \item Identificación: identifica al datagrama completo, no al paquete. Por esto, si un datagrama es fragmentado todos los fragmentos tendrán el mismo identificador.
    \item Campo de indicadores, como el \textit{more fragments}: si hay más fragmentos será un 1, y si es el último será un 0; o el \textit{don't fragment} que indica si un paquete puede ser fragmentado (si no puede y es necesario el paquete se descartará).
    \item Campo de desplazamiento (offset): sirve para ensamblar los paquetes en el destino. 
\end{itemize}

Algunas observaciones importantes:
\begin{itemize}
    \item Si hay algún error y no llegan todos los fragmentos de un datagrama se descarta todo y debe ser una capa superior la que se encargue de arreglar el problema.
    \item Solo fragmentamos cuando pasamos a un \acrshort{MTU} menor y solo se ensamblan en el destino, puesto que distintos fragmentos pueden seguir caminos distintos, dependiendo del encaminamiento.
\end{itemize}


\section{Asociación con la capa de enlace: el protocolo \acrshort{ARP}}
Cuando queremos enviar un paquete a un destino, mirando la tabla de encaminamiento sabemos la dirección IP del siguiente salto, pero para poder mandarle el paquete en el nivel de enlace necesitamos saber la dirección \acrshort{MAC}. \\

A diferencia de las direcciones IP origen y destino, que no cambian en ningún salto (salvo que se use \acrshort{NAT}); las direcciones MAC origen y destino cambian en cada reenvío del paquete, pues el nivel de enlace solo se encarga de encaminar punto a punto.\\

Entonces para mandar los paquetes necesitamos saber las direcciones MAC de los dispositivos. Esto se soluciona con el protocolo \acrfull{ARP}. 

\subsubsection{Funcionamiento}
Supongamos que A quiere mandar un paquete a B y tiene como intermediario a R1. A sabe la IP de R1 (por las tablas de encaminamiento) pero necesita saber la dirección MAC. 
\begin{itemize}
    \item A manda un ARP Request a nivel de enlace por la dirección FF:\ldots:FF (la dirección de difusión a nivel de enlace), preguntando por la MAC de la IP que conoce. 
    \item R1 contesta con un mensaje ARP Reply con su dirección MAC en unicast (es decir, respuesta única, no difusión) pues se conoce la MAC del que pregunta.
\end{itemize}

Este proceso no se hace siempre, sino se introduciría mucho tráfico. Las direcciones MAC que recibimos se van guardando en una caché y cuando pasa mucho tiempo expiran.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{./images/cabecera-arp.png}
\end{figure}


\noindent Campos de la cabecera: (H es referido a hardware, para nivel 2 para abajo; P es referido a protocolo, para nivel 3 para arriba):
\begin{itemize}
    \item Htipo: protocolo que se usa en el nivel de enlace.
    \item Ptipo: protocolo que se usa en el nivel de red.
    \item Hlen: longitud de la dirección hardware.
    \item Plen: longitud de la dirección del protocolo de red.
    \item Operación: Request o Reply.
    \item Hemisor: dirección hardware del emisor (MAC).
    \item Pemisor: dirección de red del emisor (IP).
    \item Hsol: dirección MAC del receptor.
    \item Psol: dirección IP del receptor.
\end{itemize}

Dependiendo de la operación que sea se rellenarán unos campos u otros.

\section{El protocolo \acrshort{ICMP}}
Es un protocolo que no es imprescindible pero ayuda. Sirve en general para informar al origen de que ha habido un error. Este protocolo es útil pues \acrshort{IP} no arregla ningún tipo de problema, pero al menos por este medio informa para que las capas superiores decidan si tomar acción.\\

Cuando ocurre un error, el equipo manda un paquete ICMP al origen. Es un nivel de red que se encapsula dentro de \acrshort{IP}. 

\subsubsection{Paquete \acrshort{ICMP}}
La cabecera es una palabra de 32 bits:
\begin{itemize}
    \item Tipo de mensaje, que indica el tipo de error que ocurrió.
    \item Código (subtipo de mensaje), para especificar más el error.
    \item Comprobación.
\end{itemize}

La parte de datos contiene los primeros 64 bytes del paquete que provocó el error, los 20 de la cabecera y 44 de datos del paquete IP. Esto es para ubicar el paquete que provocó el error.\\

De esta forma lo que tenemos es una cabecera IP y en la parte de datos un paquete ICMP, que a su vez se compone por una cabecera y en los datos tenemos una cabecera IP y algunos datos del paquete problemático.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{./images/codigos-icmp.png}
    \label{fig:icmp}
\end{figure}

\section{Autoconfiguración de la capa de red (\acrfull{DHCP})}

Es un protocolo automático para asignar direcciones IP, máscaras, pasarelas por defecto e IP del servidor \acrshort{DNS}. Funciona a nivel de red pero se implementa en capa de aplicación, se encapsula en \acrshort{UDP}. \\

Al principio cuando no tenemos IP, la IP es 0.0.0.0. Para conseguir una IP se intercambian los siguientes mensajes entre el cliente y el servidor DHCP:
\begin{itemize}
    \item DHCP Discover: lo primero que hace es preguntar si hay alguien. 
    \item DHCP Offer: se presenta el servido y le ofrece una IP a usar. Esto es solo una oferta, no una imperativa.
    \item DHCP Request: el equipo comprueba si ya ha tenido una IP en la red y solicita tener esa IP en caso de que sí. 
    \item DHCP ACK: el servidor responde con la IP definitiva, y esta sí es imperativa. 
\end{itemize}

La IP destino usada en toda la transacción es la de difusión 255.255.255.255, y la de origen es la 0.0.0.0 en caso de ser el cliente o la del servidor DHCP en caso de ser el mismo. Los puertos usados son el 67 para el servidor y el 68 para el cliente.\\

Los pares pregunt-respuesta se etiquetan con un identificador de transacción para que el cliente sepa que el mensaje va para él.\\

\acrshort{DHCP} es un protocolo de \textit{leasing} o alquiler, la IP (y el resto de cosas) se asignan de forma temporal. Cuando tiempo va a expirar es necesario que el equipo mande una solicitud para que el servidor refresque el alquiler. El \textbf{DHCP release} se manda cuando queremos liberar la IP que se nos ha asignado, por ejemplo antes de que el dispositivo se apague. Sin embargo, si el servidor no recibe una petición del equipo antes de que se expire su alquiler libera la IP igualmente, dado que es posible que el equipo ya no la esté usando y sea necesario liberarla para no quedarnos sin IPs disponibles. 

\begin{observacion}
    Es posible configurar un servidor para que algunas IPs fijas se asignen a ciertos dispositivos.
\end{observacion}


