\chapter{Seguridad en redes}

En el presente tema, dejaremos por un momento de lado la capa de transporte para centrarnos en la seguridad en las comunicaciones, concepto esencial que iremos detallando a lo largo de las siguientes páginas.

\subsubsection{Objetivos}
\begin{itemize}
    \item Comprender la importancia de la seguridad en las comunicaciones y aprender cómo desplegar mecanismos básicos de seguridad en redes de computadores e Internet.
    \item Conocer los aspectos de seguridad en redes: confidencialidad, autentificación, no repudio, integridad y disponibilidad. 
    \item Entender los conceptos básicos de la seguridad en redes, como el uso de algoritmos de clave secreta, de clave pública, intercambio de claves\ldots
    \item Comprender qué son los certificados digitales y las autoridades de certificación, y los diferentes mecanismos que se pueden implementar con certificados. 
    \item Conocer algunos de los principales protocolos de comunicación seguros, como \acrshort{TLS} e \acrshort{IPSec}, y los mecanismos que lo utilizan. 
\end{itemize}


\section{Introducción}
Una red de comunicaciones es \textbf{segura} cuando se garantizan todos los aspectos de seguridad, por lo que no hay protocolos ni redes 100\% seguras. No obstante, el objetivo de una red debe ser cubrir todos los aspectos de seguridad posibles.
Definamos brevemente los aspectos de seguridad que vamos a estudiar, junto con los métodos que se utilizan para garantizarlos.
\begin{itemize}
    \item \textbf{Confidencialidad / privacidad:} se garantiza que, cuando transmitimos algo a un receptor determinado, tan solo dicho receptor sea capaz de ver el mensaje.\\
    Se consigue con el cifrado. 
    \item \textbf{Autenticación:} las entidades son quien dicen ser.\\
    Se consigue con algoritmos de Reto-Respuesta o doble cifrado. 
    \item \textbf{No repudio o irrenunciabilidad:} 
    no se permite la renuncia de la autoría de determinada acción, por lo que se convierte en una prueba legal en ante un juez en el caso de ser necesario. Por ejemplo, no podemos renunciar haber participado en una transacción.\\
    Se consigue con la firma digital o con el doble cifrado con certificado, pero ha de haber una entidad fiable. 
    \item \textbf{Integridad:} se garantiza que los datos no sean manipulados por el camino (intencionadamente o no).\\
    Se consigue con funciones hash o compendios (resúmenes).
    \item \textbf{Disponibilidad:} el sistema mantiene las prestaciones de los servicios independientemente de la demanda\footnote{Este aspecto no se tratará en la asignatura.}.
\end{itemize}

Como hemos mencionado antes, una red es \textbf{segura} cuando se garantizan todos los aspectos de seguridad, y esta debe estar presente en todos los niveles de la red. El grado de seguridad lo \emph{fija el punto más débil}, ya que este es el punto más vulnerable y por el que se podría producir un ataque de seguridad. Por tanto, es importante que haya seguridad en todos los niveles de la red.

\begin{definicion}[Ataque de seguridad]
    Cualquier acción intencionada o no que menoscaba cualquiera de los aspectos de seguridad. 
\end{definicion}

Veamos algunos ejemplos de ataque de seguridad:
\begin{itemize}
    \item \textbf{Sniffing:} escuchar comunicaciones, por ejemplo mediante Wireshark. Se produce una vulneración de la confidencialidad.
    \item \textbf{Snooping (phishing):} suplantación de la identidad de alguna entidad. Se vulnera la autentificación.
    \item \textbf{Man in the Middle:} un atacante se situa en medio de dos equipos que se comunican e intercepta todos los mensajes que se transmiten.
    \item \textbf{\acrfull{DDoS}:} ataque consistente en enviar muchas peticiones a un servidor para que este no pueda atender a todas, consiguiendo que el servicio deje de funcionar. Se denomina \emph{distributed} si las peticiones provienen de distintos equipos, que suele ser lo más común. 
    \item \textbf{Malware:} software malicioso, como troyanos, gusanos, \textit{spyware}, \textit{backdoors}, \textit{rootkits}, \textit{keyloggers}, etc. Un ejemplo es \textit{ransomware}, en el que se encriptan todos o parte de los datos y se pide un recate a cambio de estos.
\end{itemize}


Los mecanismos de seguridad que vamos a estudiar, como hemos mencionado antes, son:
\begin{itemize}
    \item Para garantizar la confidencialidad:
    \begin{itemize}
        \item Cifrado (simétrico y asimétrico).
    \end{itemize}
    \item Para garantizar la autentificación:
    \begin{itemize}
        \item Autentificación con clave secreta (reto-respuesta).
        \item Intercambio de Diffie-Hellman (establecimiento de clave secreta).
    \end{itemize}

    \item Para garantizar la integridad:
    \begin{itemize}
        \item Funciones Hash (\acrfull{HMAC}).
    \end{itemize}

    \item Para garantizar el no repudio:
    \begin{itemize}
        \item Firma digital y Certificados digitales.
    \end{itemize}
\end{itemize}

\section{Cifrado}
Se trata de un procedimiento para garantizar la confidencialidad.\\


El proceso se ilustra en la Figura~\ref{fig:cifrado/descifrado}. Inicialmente, se dispone de un texto plano a transmitir (P), que buscamos que tan solo pueda ser leído por el receptor. Para ello, se emplea una función de cifrado $E_k$ que dará lugar a un texto cifrado (C), el cual se mandará a través del canal de comunicaciones (no supone un problema, ya que este texto cifrado no será entendible). Llegará al otro extremo y será descifrado con una función $D_{k'}$, obteniendo así de nuevo el texto plano (P).

Los algoritmos de cifrado y descifrado ($E_k$ y $D_{k'}$) normalmente son conocidos, pero estos dependen de claves $k$ y $k'$ que son secretas. La dificultad reside en hallar estas claves.
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{./images/cifrado.png}
    \caption{Proceso de cifrado y descifrado.}
    \label{fig:cifrado/descifrado}
\end{figure}

Veremos dos tipos de algoritmos de cifrado:
\begin{itemize}
    \item Cifrado simétrico. La clave es secreta y única ($k=k'$), y se usan distintas funciones para cifrar y descifrar.
    \item Cifrado asimétrico. Hay dos claves (pública y privada), y se usa la misma función para cifrar y descifrar.
\end{itemize}

\subsection{Cifrado simétrico}

Este tipo de algoritmos de cifrado se denomina simétrico porque se usa la misma clave para cifrar y descifrar los datos. Por tanto, la clave es secreta y tan solo es conocida por el emisor de los datos y el receptor.

\subsubsection{\acrfull{DES}}
Se trata de algoritmo de cifrado simétrico que se basa en realizar permutaciones y funciones \verb|XOR| encadenadas. Se cifran palabras de 64 bits usando una clave de 56 bits.\\

Como principal ventaja, como estas operaciones se pueden implementar de forma sencilla en hardware, es un algoritmo muy rápido, por lo que se puede usar en tiempo real (por ejemplo para codificar voz). No obstante, presenta una serie de problemas:
\begin{itemize}
    \item La longitud de la clave es corta ($2^{56}$ posibles claves), por lo que es vulnerable a ataques de fuerza bruta.
    \item Lo que se termina obteniendo es una sustitución, por lo que con la misma entrada el resultado siempre será el mismo. Usando estudios estadísticos dependiendo del idioma, se puede llegar a descifrar el mensaje.
\end{itemize}

Para mitigar este segundo aspecto, se utiliza un esquema de cifrado reentrante, donde la salida de aplicar una transformación se usa para el cifrado de la siguiente palabra a cifrar. De esta forma, quien recibe el mensaje codificado necesita conocer la última entrada usada para codificar y podrá así aplicar el proceso inverso.

\subsubsection{\acrshort{DES} doble y 3\acrshort{DES}}

Estas son distintas mejoras del algoritmo \acrshort{DES} para aumentar su seguridad y robustez. Se toman dos claves $k_1$ y $k_2$ (en el caso de 3\acrshort{DES}, podrían ser 3 distintas) y para cifrar se toma una función $E$ y su inversa $D$ y se concatenan $E_{k_1}$, $D_{k_2}$, $E_{k_1}$ y para descifrar se concatenan $D_{k_1}$, $E_{k_2}$, $D_{k_1}$.

De esta forma, podemos simular una clave de 112 bits (en el caso de 2\acrshort{DES}) o de 168 bits (en el caso de 3\acrshort{DES}); aunque se reduce la velocidad de cifrado.
\subsubsection{\acrfull{IDEA}}

Emplea la misma idea que \acrshort{DES} (cifrado empleando permutaciones y funciones \verb|XOR|), pero con claves de 128 bits en vez de 56. De esta forma, hay $2^{128}$ posibles claves, lo que reduce las posibilidades de un ataque por fuerza bruta. Los bloques que se encriptan siguen siendo de 64 bits.

\subsection{Cifrado asimétrico}
Cada usuario $A$ tiene una clave pública $K_{\text{pub}_A}$ y una clave privada $K_{\text{pri}_A}$ distintas. Conociendo la pública no es posible conocer la privada, por lo que la pública la conocen todos pero la privada solo la conoce su propietario, $A$.  Además, hay una correspondencia biunívoca entre las claves públicas y privadas.\\

Veamos ahora la forma de funcionar de estos algoritmos. Supongamos que $A$ quiere enviar un mensaje a $B$, por lo que cifraremos con la clave pública de $B$, de forma que sólo $B$ podrá descifrarlo con su clave privada. De esta forma, se garantiza la confidencialidad del mensaje. Si $P$ es el mensaje a enviar y $C$ el mensaje cifrado, se tiene que:
\begin{equation*}
    C = K_{\text{pub}_B}(P) \longrightarrow P = K_{\text{pri}_B}(C)
\end{equation*}

De cara a la autentificación, si se cifra un documento con la clave privada de $A$, se garantiza que solo $A$ ha podido cifrarlo, por lo que se garantiza la autentificación de $A$.
\begin{equation*}
    C = K_{\text{pri}_A}(P) \longrightarrow P = K_{\text{pub}_A}(C)
\end{equation*}
Este último aspecto tiene algunos inconvenientes que veremos más adelante.

\subsubsection{\acrshort{RSA}}
Este algoritmo, cuyo nombre se debe a sus creadores, es ampliamente utilizado en la actualidad. Es un algoritmo de cifrado asimétrico que se basa en la factorización de números enteros.
Aunque no entraremos en el detalle de por qué es así el algoritmo\footnote{Se basa en factorización de números enteros, y se emplea para ello conocimientos mátemáticos, algunos vistos en la asignatura de Álgebra I, como la función de Euler.}, explicaremos tanto la generación de claves como el cifrado y descifrado de mensajes. Respecto a la generación de claves, se sigue el siguiente procedimiento:
\begin{enumerate}
    \item Elegimos $p,q$ primos grandes ($p,q>10^{100}$).
    \item $n = p\cdot q\qquad z = (p-1)\cdot(q-1)$.
    \item Elegimos $d$ primo relativo de $z$ ($\mcd(d,z)=1$).
    \item Calculamos $e$ tal que $e\cdot d \mod z = 1$.
\end{enumerate}
Las claves serán los siguientes pares:
\begin{equation*}
    K_{\text{pub}} = (e,n)\qquad K_{\text{pri}} = (d,n)
\end{equation*}

Para cifrar un número entero $P$ en $C$, y descifrarlo de nuevo en $P$, se usan las siguientes funciones:
\begin{align*}
    \text{Cifrado:} &\quad C = P^e \mod n\qquad \text{con } K_{\text{pub}} = (e,n)\\
    \text{Descifrado:} &\quad P = C^d \mod n \qquad \text{con } K_{\text{pri}} = (d,n)
\end{align*}

\begin{ejemplo}
    Veamos el siguiente ejemplo de aplicación del algoritmo.
    \begin{enumerate}
        \item Elegimos $p=3$ y $q=11$.
        \item $n = 3\cdot 11 = 33\qquad z = (3-1)\cdot(11-1) = 20$.
        \item Elegimos $d=7$, ya que $\mcd(7,20)=1$.
        \item Tomamos $e=3$, ya que $3\cdot 7 \mod 20 = 1$.
        \item Tenemos $K_{\text{pub}} = (3,33)$ y $K_{\text{pri}} = (7,33)$.
    \end{enumerate}

    Suponemos que queremos codificar la palabra ``SUZANNE''. Para ello, asignamos un número a cada letra (el orden en el alfabeto sin la ñ), y el proceso se ilustra en la Tabla~\ref{tab:rsa}. Notemos que, por la red, tan solo se envía el número cifrado, $C$, y no se podría descifrar sin conocer la clave privada.
    \begin{table}[H]
        \centering
        \begin{tabular}{cc||c||c||c}
            Simbólico & Numérico ($P$) & $C=P^3\mod 33$ & $P=C^7\mod 33$ & Simbólico\\
            \hline
            S & 19 & 28 & 19 & S\\
            U & 21 & 21 & 21 & U\\
            Z & 26 & 10 & 26 & Z\\
            A & 1 & 1 & 1 & A\\
            N & 14 & 5 & 14 & N\\
            N & 14 & 5 & 14 & N\\
            E & 5 & 26 & 5 & E
        \end{tabular}
        \caption{Cifrado y descifrado de la palabra ``SUZANNE''.}
        \label{tab:rsa}
    \end{table}
\end{ejemplo}

\section{Autenticación}
Pongámonos en el supuesto de que dos equipos, $A$ y $B$, quieren autenticarse. Lo más sencillo es que cada uno tenga una base de datos con el usuario y la clave que comparten con el otro. Para autenticarse $A$, este le manda a $B$ su usuario y su clave compartida, y $B$ comprueba si son correctos. De forma análoga, $B$ se autentica con $A$. Al estar enviándose la clave, este método es vulnerable, pero se usa en muchos servicios, como en el protocolo \acrshort{PAP}. Se pueden hacer algunas mejoras, como enviar la información a través de túneles cifrados, pero la vulnerabilidad sigue presente.\\

Para evitar este problema, se pueden usar algoritmos de reto-respuesta.
\subsection{Reto-respuesta}
Este algoritmo se ilustra en la Figura~\ref{fig:reto-respuesta}.
Al igual que antes, supongamos que dos equipos $A$ y $B$ quieren autenticarse. Ambos tienen una base de datos que contiene, para cada usuario, la clave que comparten. Para autenticarse $A$ con $B$, este envía su identidad (usuario) $A$ (que no es un dato sensible), y $B$ le contesta con un número aleatorio $(R_B)$ denominado reto. Usando la clave compartida $K_{AB}$, $A$ cifra el reto ($K_{AB}(R_B)$) y se lo envía a $B$. El quipo $B$ también cifra el reto con la clave compartida que posee en su base de datos, y si coincide con el que ha recibido, $A$ queda autenticado. Además, $A$ habrá enviado ya un reto $R_A$ a $B$ para que este se autentique de la misma forma. De esta forma, se garantiza la autenticación de ambos equipos.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{./images/reto-respuesta.png}
    \caption{Algoritmo de reto-respuesta.}
    \label{fig:reto-respuesta}
\end{figure}

Notemos que por la red no se envía ningún dado sensible, sino que solo se envían números aleatorios cifrados. Aunque parece seguro, este algoritmo tiene algunas vulnerabilidades:
\begin{itemize}
    \item \textbf{Ataque por repetición:} el atacante escucha por mucho tiempo y va guardando las respuestas correctas para cada resto. De esta forma, cuando se repita un reto, ya sabe qué respuesta ha de enviar para identificarse él, suplantando así la identidad. \textbf{Solución:} que el reto no se pueda repetir (denominado \emph{nonce}), como puede ser el instante de tiempo junto a un número aleatorio (por ejemplo).
    \item \textbf{Ataque por reflexión:} el atacante, tras escuchar el reto de $B$, le envía a $B$ su mismo reto, como si este fuese el reto de $A$. Cuando $B$ le responda, le reenvía dicha respuesta a $B$ como si hubiese sido él quien la ha cifrado. \textbf{Solución:} usar dominios de retos disjuntas, para que así no se pueda reenviar el reto de $B$ a $B$.
\end{itemize}

\subsection{Intercambio de Diffie-Hellman}

Aunque en el algoritmo de reto-respuesta no se envían claves, estas se han tenido que establecer en algún momento.
Además, también es posible que no sea posible almacenar las claves en las bases de datos mencionadas, y que tengamos que calcular una clave secreta y compartida en cada autenticación. Estos dos problemas se resuelven con el intercambio de Diffie-Hellman, ya que este algoritmo permite establecer una clave secreta entre dos entidades a través de un canal no seguro.

El algoritmo se muestra en la Figura~\ref{fig:diffie-hellman}. Aunque tampoco entraremos en detalle en las matemáticas que hay detrás, el algoritmo para crear una clave secreta compartida entre $A$ y $B$ es el siguiente:
\begin{enumerate}
    \item $A$ elige enteros $x,n$ y $g$, y $B$ elige el entero $y$.
    \item $A$ envía a $B$ los valores $g$, $n$ y $g^x \mod n$.
    \item $B$ envía a $A$ el valor $g^y \mod n$, que calcula a partir de los valores recibidos.
    \item La clave secreta que comparten $A$ y $B$, que nunca se ha transmitido por la red y, como no se ha transmitido ni $x$ ni $y$, tampoco la podrá calcular un atacante, es:
    \begin{align*}
        K_{AB}  &= (g^y \mod n)^x \mod n = g^{xy} \mod n\\
        K_{BA}  &= (g^x \mod n)^y \mod n = g^{xy} \mod n
    \end{align*}
\end{enumerate}
\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{./images/diffie-hellman.png}
    \caption{Algoritmo de intercambio de Diffie-Hellman.}
    \label{fig:diffie-hellman}
\end{figure}

No obstante, este algoritmo también tiene sus vulnerabilidades. Por ejemplo, puede sufrir un ataque del tipo \textit{man-in-the-middle}, en el que un atacante se sitúa entre $A$ y $B$ y se hace pasar por $A$ ante $B$ y por $B$ ante $A$. De esta forma, hace de mensajero invisible, y las claves compartidas en realidad serán con el atacante.

\section{Funciones Hash}

Son funciones de forma que dada una palabra P, nos da una palabra a modo de resumen o compendio de los datos, R. P puede ser de cualquier longitud, R, sin embargo, suele ser de longitud fija y ademas la función es unidireccional, irreversible, es decir, no se puede obtener P a partir de R. Dado un mensaje P, se envía P junto con su hash. \\

Para que no se pueda modificar el mensaje a P' e incluir su resumen se tienen varias alternativas: 
\begin{itemize}
    \item En el resumen podemos meter la clave que se comparte. A este hash (P + $K_{AB}$) se le suele llamar MAC (Message Authentification Code).
    \item Cifrar el hash con la clave compartida.
\end{itemize}

Así conseguimos integridad del mensaje y por otra parte autenticación con los MAC\@.

\subsubsection{MD5 (Message Digest)}

Dada una palabra nos da un resumen de 128 bits. El algoritmo trabaja sobre bloques de 512 bits, por lo que si la palabra no tiene un número de bits múltiplo de 512 rellenamos con 100\ldots0 hasta que sea congruente con 448módulo 512, y se le añade un campo de longitud de 64 bits. A continuación se divide el mensaje en bloques de 512 bits y hacemos un procesamiento secuencial por bloques, es decir, que cada salida sirve como entrada para la siguiente caja MD5\@.


\subsubsection{SHA (Secure Hash Algorithm)}

Funciona igual que MD5 pero los resúmenes son de 160 bits. 


\section{Firma digital y certificados digitales}

Una \textbf{firma digital} intenta ser un sustituto de una firma escrita para poder garantizar el \textbf{no repudio} en nuestras acciones en Internet. Con ellas conseguimos:
\begin{itemize}
    \item Autenticación por parte del receptor de la identidad del emisor.
    \item No repudio por parte del firmante.
    \item El emisor obtiene garantía de no falsificación. (Integridad).
\end{itemize}

\subsection{Firma con clave secreta o Big Brother (BB)}

El protocolo consiste en usar una entidad en la que todos los usuarios confían y que vigilará las transacciones de todos los usuarios. Es una especie de man-in-the-middle. Si A quiere enviar un mensaje a B, el BB formará parte de la comunicación haciendo de puente que guardará cada una de las transacciones realizadas. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{./images/big-brother.png}
    \label{fig:big-brother}
\end{figure}

El BB tiene una clave compartida con todos. A le manda a BB:
\begin{description}
    \item [A:]Identificador.
    \item [B:] El destinatario.
    \item [$R_A$:] Un resumen para dar integridad.
    \item [t:] el instante de tiempo.
    \item [P:] texto plano, el mensaje a enviar. 
\end{description}
Todo menos el identificador va cifrado con la clave que comparte A con BB. El mensaje es recibido y reenviado por BB añadiéndole algunos detalles.
\begin{description}
    \item [$K_{BB}(A,t,P)$:] Esta clave solo la tiene el BB lo que prueba ante un juez quién ha hecho dicha transacción, en qué momento y el contenido de la transacción.  
    \item [$K_B(\ldots)$:] Además todo va cifrado con la clave de B para confidencialidad. 
\end{description}


\subsection{Firma digital con clave asimétrica o Doble cifrado}

Supongamos que A le quiere mandar un mensaje a B. La idea se basa en lo siguiente:
\begin{itemize}
    \item $k_{\text{pri}_A}\equiv$ autenticación, solo A ha podido cifrarlo.
    \item $k_{pub_B}\equiv$ confidencialidad, solo B podrá descifrarlo.
\end{itemize}
De esta manera, juntando las dos obtenemos autenticación + confidencialidad: $k_{pub_B}(K_{\text{pri}_A} (P))$ (puede cifrarse al revés, no es relevante).\\

Sin embargo todo esto no garantiza el \textbf{no repudio}, puesto que nada nos garantiza que A sea el dueño de la clave. Para garantizarlo necesitamos los certificados digitales que deben ser emitidos por autoridades de certificación, que son entidades fiables. 

\begin{definicion}[Autoridades de certificación (AC\@)]
    Entidad que garantiza la asociación entre identidad y claves.
\end{definicion}

\subsubsection{Certificado digital}
El usuario obtiene sus claves pública y privada, envía una solicitud, firmada digitalmente, a la AC indicando su identidad y clave pública. La AC comprueba la firma y emite el certificado: este tiene los datos que a continuación detallaremos y va firmado digitalmente por la clave firmada de la AC con objeto de que el certificado no pueda falseficarse. Campos de un certificado X\@.509:
\begin{itemize}
    \item Identidad del usuario.
    \item Su clave pública.
    \item La AC que lo ha emitido.
    \item Periodo de validez.
    \item Algunos datos más como la versión del certificado, el número de serie\ldots
\end{itemize}

\section{Protocolos seguros}
La seguridad se divide en dos tipos:
\begin{itemize}
    \item \textbf{Perimetral:} uso de \textit{firewalls}, \textit{sistemas de detección de intrusiones} o \textit{sistemas de respuesta}.
    \item \textbf{Seguridad en protocolos:} consiste en usar protocolos para garantizar seguridad.
        \begin{itemize}
            \item Capa de aplicación: PGP o SSH\@.
            \item Capa de sesión (entre aplicación y transporte): TLS\@, SSL\@.
            \item Capa de red: IPSec\@.
        \end{itemize}
\end{itemize}

\subsection{PGP (Pretty Good Privacy)}

Es un protocolo de correo electrónico seguro. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\linewidth}
        \centering
        \includegraphics[width=0.6\linewidth]{./images/pgp-emisor.png}
        \label{fig:pgp-emisor}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \centering
        \includegraphics[width=0.6\linewidth]{./images/pgp-receptor.png}
        \label{fig:pgp-receptor}
    \end{subfigure}
\end{figure}

El emisor hace un resumen del mensaje, lo firma; esto lo comprime junto con el mensaje, cifra esa compresión con IDEA y una clave de sesión K (generada solo para esa sesión), que manda cifrada con la clave pública del receptor y esto lo codifica con base 64 (esto no tiene nada que ver con seguridad). El resultado de esto último es lo que le manda al destinatario. El receptor simplemente tiene que hacer el proceso inverso para sacar el mensaje y con el resumen comprobar que no se ha modificado.\\

Con este proceso conseguimos:
\begin{itemize}
    \item Confidencialidad: el mensaje va cifrado.
    \item Integridad: gracias al resumen.
    \item Autenticación: gracias al cifrado con la clave privada.
    \item No repudio: solo si hay un certificado digital.
\end{itemize}


\subsection{TLS\@, SSL}
Se usan para muchos protocolos (HHTPS\@, IMAPS\@, SSL\@-POP\@). TLS fue el original y SSL se acabó popularizando más. Hacen más o menos lo mismo, pero no son compatibles. Lo que hacen en esencia es crear túneles cifrados. 

\subsubsection{SSL}
No es un protocolo sino una familia de ellos.
\begin{itemize}
    \item SSL Record Protocol: encapsula los protocolos y ofrece un canal seguro con privacidad, autenticación e integridad. Lo que se hace es que cuando voy a mandar datos, los parto en fragmentos, cada fragmento lo comprimos, hago un resumen y cifro datos + resumen. Y esto último es lo que se transmite, encapsulado en un paquete TCP\@.
    \item SSL Handshake Protocol: se negocia el algoritmo de cifrado, la función hash, autentica al servidor, el cliente genera claves de sesión (temporales) con el algoritmo de Diffie-Hellman o aleatorias y que irán cifradas con la clave pública del servidor. \\
        El problema del hombre en medio se resuelve autenticando al servidor. Así, si el mensaje que me llega con $g^ymodn$ no viene del servidor no lo tomo. 
    \item SSL Assert Protocol: informa sobre errores en la sesión.
    \item Change Cipher Spec Protocol: para notificar cambios en el cifrado.
\end{itemize}

\subsection{IPSec}
Su objetivo es garantizar autenticación, integridad y opcionalmente privacidad a nivel IP\@. Crea túneles unidireccionales. 

\begin{definicion}[Túnel]
    Es un sitio donde entra un paquete y a la salida tendremos exactamente el mismo paquete. Para ello encapsulamos el paquete dentro de otro paquete. Si el túnel va cifrado (la parte de los datos va cifrada) entonces el túnel es seguro.
\end{definicion}

Son tres procedimientos:
\begin{enumerate}
    \item Establecimiento de una ``Asociación de seguridad'': con el objetivo de establecer una clave secreta (Diffie-Hellman), con la previa autenticación. Es simplex. Vulnera el carácter NO orientado a conexión. 
    \item Garantizar la autenticación e integridad de los datos mediante las ``Cabeceras de autenticación''.
    \item (Opcional) Garantizar la privacidad de los datos mediante el protocolo de ``Encapsulado de seguridad de la carga''.
\end{enumerate}

Dos tipos de túneles:
\begin{itemize}
    \item Modo transporte: la asociación se hace extremo a extremo entre el host origen y destino.
    \item Modo túnel: la asociación se hace entre dos routers intermediarios. Útil por ejemplo si una empresa quiere comunicar dos sucursales, en vez de comunicar cada dos trabajadores, se comunican mediante esos routers intermediarios y solo hacen falta dos túneles (para ambas direcciones).
\end{itemize}


