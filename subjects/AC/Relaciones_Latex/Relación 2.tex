\section{Programación paralela}

\begin{ejercicio}
    Un programa tarda $40$ s en ejecutarse en un multiprocesador. Durante un 20\% de ese tiempo se
    ha ejecutado en cuatro procesadores; durante un 60\%, en tres; y durante el 20\% restante, en un procesador
    (consideramos que se ha distribuido la carga de trabajo por igual entre los procesadores que colaboran en la
    ejecución en cada momento, despreciamos sobrecarga).
    \begin{enumerate}
        \item ¿Cuánto tiempo tardaría en ejecutarse el programa
        en un único procesador?
        \item ¿Cuál es la ganancia en velocidad obtenida con respecto al tiempo de ejecución
        secuencial?
        \item ¿Cuál es la ganancia en eficiencia obtenida con respecto al tiempo de ejecución
        secuencial?
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Un programa tarda $20$ s en ejecutarse en un procesador $P_1$, y requiere $30$ s en otro procesador
    $P_2$. Si se dispone de los dos procesadores para la ejecución del programa (despreciamos sobrecarga):
    \begin{enumerate}
        \item ¿Qué tiempo tarda en ejecutarse el programa si la carga de trabajo se distribuye por igual entre los
        procesadores $P_1$ y $P_2$?
        \item ¿Qué distribución de carga entre los dos procesadores $P_1$ y $P_2$ permite el menor tiempo de
        ejecución utilizando los dos procesadores en paralelo ? ¿Cuál es este tiempo?
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    ¿Cuál es fracción de código paralelo de un programa secuencial que, ejecutado en paralelo en 8
    procesadores, tarda un tiempo de 100 ns, durante 50ns utiliza un único procesador y durante otros 50 ns
    utiliza 8 procesadores (distribuyendo la carga de trabajo por igual entre los procesadores)?
\end{ejercicio}

\begin{ejercicio}
    Un 25\% de un programa no se puede paralelizar, el resto se puede distribuir por igual entre
    cualquier número de procesadores. ¿Cuál es el máximo valor de ganancia de velocidad que se podría
    conseguir al paralelizarlo en $p$ procesadores, y con infinitos? ¿A partir de cuál número de procesadores se
    podrían conseguir ganancias mayores o iguales que 2?
\end{ejercicio}

\begin{ejercicio}\label{ej:2.5}
    
    En la Figura \ref{fig:Grafo_2.5}, se presenta el grafo de dependencia entre tareas para una aplicación.
    La figura muestra la fracción del tiempo de ejecución secuencial que la aplicación tarda en ejecutar grupos de tareas del grafo.
    Suponiendo un tiempo de ejecución secuencial de 60 s, que las tareas no se pueden dividir en tareas de menor granularidad y
    que el tiempo de comunicación es desprecible, obtener el tiempo de ejecución en paralelo y la ganancia en velocidad en un computador con:
    \begin{enumerate}
        \item 4 procesadores.
        \item 2 procesadores.
    \end{enumerate}
    \begin{figure}
        \centering
        \begin{tikzpicture}[
            every node/.style={circle, draw, fill=blue!10},
            level 1/.style={sibling distance=1.5cm},
            level 2/.style={sibling distance=1cm},
            level 3/.style={sibling distance=1cm},
            level 4/.style={sibling distance=1cm},
            level distance=1.5cm,
            sibling distance=2.5cm,
            edge from parent/.style={draw,-stealth}
            ]
            \node (topnode) at (0,5) {15\%} 
            child { node {15\%}}
            child { node {15\%}}
            child { node {15\%}}
            ;
    
            \node (middlenode) at (0,2) {15\%}
            child { node {5\%} }
            child { node {5\%} }
            child { node {5\%} }
            child { node {5\%} }
            ;
    
            \node(bottomnode) at (0,-1) {15\%};
    
            \foreach \x in {1,2,3,4}{
                \draw[-stealth] (middlenode-\x) -- (bottomnode);
            }
    
            \foreach \x in {1,2,3}{
                \draw[-stealth] (topnode-\x) -- (middlenode);
            }
        \end{tikzpicture}
        \caption{Grafo de tareas del Ejercicio \ref{ej:2.5}}
        \label{fig:Grafo_2.5}
    \end{figure}
\end{ejercicio}


\begin{ejercicio} \label{ej:2.6}
    Un programa se ha conseguido dividir en 10 tareas. El orden de precedencia entre las tareas se
    muestra con el grafo dirigido de la Figura \ref{fig:Grafo_2.6}. La ejecución de estas tareas en un procesador supone un tiempo de 2 sg.
    El 10\% de ese tiempo es debido a la ejecución de la tarea 1; el 15\% a la ejecución de la tarea 2; otro 15\% a la ejecución de 3;
    cada tarea 4, 5, 6 o 7 supone el 9\%; un 8\% supone la tarea 8; la tarea 9 un 10\%; por último, la tarea 10 supone un 6\%.
    Se dispone de una arquitectura con 8 procesadores para ejecutar la aplicación. Consideramos que el tiempo de comunicación se puede despreciar.
    \begin{enumerate}
        \item ¿Qué tiempo tarda en ejecutarse el programa en paralelo?
        \item ¿Qué ganancia en velocidad se obtiene con respecto a su ejecución secuencial?
    \end{enumerate}
    \begin{figure}
        \centering
        \begin{tikzpicture}[
            every node/.style={circle, draw, fill=red!10},
            level 1/.style={sibling distance=3cm},
            level 2/.style={sibling distance=2cm},
            level 3/.style={sibling distance=2.5cm},
            level 4/.style={sibling distance=1cm},
            level distance=1cm,
            sibling distance=3cm,
            edge from parent/.style={draw,-stealth}]

            \node (topnode) at (0,4) {1} 
                child { node {2}
                    child { node {4}}
                    child { node {5}}
                }
                child { node {3}
                    child { node {6}}
                    child { node {7}}
                }
            ;

            \node(bottomnode) at (0,0) {10} [grow=up]
                child[edge from parent/.style={draw,stealth-}] { node {9}}
                child[edge from parent/.style={draw,stealth-}] { node {8}}
            ;

            \foreach \i in {1,2}{
                \draw[-stealth] (topnode-1-\i) -- (bottomnode-2);
            }

            \foreach \i in {1,2}{
                \draw[-stealth] (topnode-2-\i) -- (bottomnode-1);
            }
        \end{tikzpicture}
        \caption{Grafo de tareas del Ejercicio \ref{ej:2.6}}
        \label{fig:Grafo_2.6}
    \end{figure}
\end{ejercicio}

\begin{ejercicio}
    Se quiere paralelizar el siguiente trozo de código:
    \begin{minted}[xleftmargin=3cm]{c++}
//  {Cálculos antes del bucle}
for( i=0; i<w; i++) {
    // Código para i
}
// {cálculos después del bucle}
    \end{minted}
    Los cálculos antes y después del bucle suponen un tiempo de $t_1$ y $t_2$, respectivamente.
    Una iteración del ciclo supone un tiempo $t_i$. En la ejecución paralela, la inicialización de $p$ procesos supone un tiempo
    $k_1p$ ($k_1$ constante), los procesos se comunican y se sincronizan, lo que supone un tiempo $k_2p$ ($k_2$ constante); $k_1p+k_2p$
    constituyen la sobrecarga.
    \begin{enumerate}
        \item Obtener una expresión para el tiempo de ejecución paralela del trozo de código en $p$ procesadores ($T_p$).
        \item Obtener una expresión para la ganancia en velocidad de la ejecución paralela con respecto a una ejecución secuencial ($S_p$).
        \item ¿Tiene el tiempo $T_p$ con respecto a $p$ una característica lineal o puede presentar algún mínimo? ¿Por qué? En caso de presentar un mínimo, ¿para qué número de procesadores $p$ se alcanza?
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Supongamos que se va a ejecutar en paralelo la suma de $n$ números en una arquitectura con $p$
    procesadores o cores ($p$ y $n$ potencias de dos) utilizando un grafo de dependencias en forma de árbol (divide
    y vencerás) para las tareas.
    \begin{enumerate}
        \item\label{ej:2.8a} Dibujar el grafo de dependencias entre tareas para $n=16$ y $p=8$. Hacer una asignación de tareas
        a procesos.
        \item Obtener el tiempo de cálculo paralelo para cualquier $n$ y $p$ con $n>p$ suponiendo que se tarda una
        unidad de tiempo en realizar una suma.
        \item\label{ej:2.8c} Obtener el tiempo comunicación del algoritmo suponiendo:
        \begin{enumerate}
            \item Que las comunicaciones en un nivel del árbol se pueden realizar en paralelo en un número de unidades de tiempo igual al número de
            datos que recibe o envía un proceso en cada nivel del grafo de tareas (tenga en cuenta la asignación
            de tareas a procesos que ha considerado en el apartado \ref{ej:2.8a})
            \item Que los procesadores que realizan las tareas de las hojas del árbol tienen acceso sin coste de comunicación a los datos que utilizan
            dichas tareas.
        \end{enumerate}

        \item Suponiendo que el tiempo de sobrecarga coincide con el tiempo de comunicación calculado en el apartado \ref{ej:2.8c}, obtener la ganancia en prestaciones.
        \item Obtener el número de procesadores para el que se obtiene la máxima ganancia con $n$ números.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:2.9}
    Se va a paralelizar un decodificador JPEG en un multiprocesador. Se ha extraído para la aplicación
    el siguiente grafo de tareas que presenta una estructura segmentada (o de flujo de datos):
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[every node/.style={draw, fill=gray!10}, node distance=2cm]
            \node (entrada) [draw] {\textbf{Entrada}};
            \node (T1) [draw, right of=entrada] {T1};
            \node (T2) [draw, right of=T1] {T2};
            \node (T3) [draw, right of=T2, yshift=-1cm] {T3};
            \node (T4) [draw, right of=T2, yshift=1cm] {T4};
            \node (T5) [draw, right of=T4, yshift=-1cm] {Paso 4};
            \node (salida) [draw, right of=T5] {\textbf{Salida}};
            
            \draw[-stealth] (entrada) -- (T1);
            \draw[-stealth] (T1) -- (T2);
            \draw[-stealth] (T2) -- (T3);
            \draw[-stealth] (T2) -- (T4);
            \draw[-stealth] (T3) -- (T5);
            \draw[-stealth] (T4) -- (T5);
            \draw[-stealth] (T5) -- (salida);
        \end{tikzpicture}
        \caption{Segmentación del Ejercicio \ref{ej:2.9}}
    \end{figure}
    La entrada tenemos que es el bloque de la imagen a decodificar (supone 8x8 pixels de la imagen).
    La salida será el bloque decodificado de 8x8 pixel. Las tareas 1, 2 y 5 se ejecutan en un tiempo igual a $t$,
    mientras que las tareas 3 y 4 suponen $1.5t$. El decodificador JPEG aplica el grafo de tareas de la figura a bloques de la imagen, cada uno de 8x8 píxeles. Si
    se procesa una imagen que se puede dividir en $n$ bloques de 8x8 píxeles, a cada uno de esos $n$ bloques se
    aplica el grafo de tareas de la figura. Obtenga la mayor ganancia en prestaciones que se puede conseguir
    paralelizando el decodificador JPEG en (suponga despreciable el tiempo de comunicación/sincronización):
    \begin{enumerate}
        \item 5 procesadores.
        \item 4 procesadores.
    \end{enumerate}

    En cualquier de los dos casos, la ganancia se tiene que calcular suponiendo que se procesa una imagen con un total de $n$ bloques de 8x8 píxeles.
\end{ejercicio}


\begin{ejercicio}
    Se quiere implementar un programa paralelo para un multicomputador que calcule la siguiente
    expresión para cualquier $x$ (es el polinomio de interpolación de Lagrange):
    $P(x) = \sum\limits_{i=0}^{n} \left(b_i\cdot L_i(x)\right)$, donde:
    \begin{align*}
        L_i(x) &= \frac{(x-a_0) \ldots  (x-{a_{i-1}})(x-{a_{i+1}}) \ldots  (x-a_n)}{k_i}
        = \frac{\prod\limits_{\substack{j=0\\ j\neq i}}^{n} (x-a_j)}{k_i} \qquad i=0,1,\dots,n\\
        k_i &= (a_i-a_0) \ldots  (a_i-a_{i-1})(a_i-a_{i+1}) \ldots  (a_i-a_n)= \prod\limits_{\substack{j=0\\ j\neq i}}^{n} (a_i-a_j) \qquad i=0,1,\dots,n
    \end{align*}

    Inicialmente $k_i$, $a_i$ y $b_i$ se encuentran en el nodo $i$ y $x$ en todos los nodos. Sólo se van a usar funciones de
    comunicación colectivas. Indique cuál es el número mínimo de funciones colectivas que se pueden usar,
    cuáles serían, en qué orden se utilizarían y para qué se usan en cada caso.
\end{ejercicio}

\begin{ejercicio}\label{ej:2.11}~
    \begin{enumerate}
        \item Escriba un programa secuencial con notación algorítmica (podría escribirlo en C) que
        determine si un número de entrada, $x$, es primo o no. El programa imprimirá si es o no primo. Tendrá
        almacenados en un vector, \verb|NP|, los $M$ números primos entre 1 y el máximo valor que puede tener un número
        de entrada al programa.

        \item Escriba una versión paralela del programa anterior para un multicomputador usando un estilo de
        programación paralela de paso de mensajes. El proceso 0 tiene inicialmente el número $x$ y el vector \verb|NP| en su
        memoria e imprimirá en pantalla el resultado. Considere que la herramienta de programanción ofrece
        funciones \verb|send()/receive()| para implementar una comunicación uno-a-uno asíncrona, es decir, con función
        \verb|send(buffer,count,datatype,idproc,group)| no bloqueante y
        \verb|receive(buffer,count,datatype,idproc,group)| bloqueante. En las funciones \verb|send()/receive()| se
        especifica:
        \begin{itemize}
            \item \verb|group|: identificador del grupo de procesos que intervienen en la comunicación.
            \item \verb|idproc|: identificador del proceso al que se envía o del que se recibe.
            \item \verb|buffer|: dirección a partir de la cual se almacenan los datos que se envían o los datos que se
            reciben.
            \item \verb|datatype|: tipo de los datos a enviar o recibir (entero de 32 bits, entero de 64 bits, flotante de 32
            bits, flotante de 64 bits, \dots).
            \item \verb|count|: número de datos a transferir de tipo \verb|datatype|.
        \end{itemize}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:2.12}
    Escribir una versión paralela del programa secuencial del ejercicio \ref{ej:2.11} para un multicomputador
    usando un estilo de programación paralela de paso de mensajes y suponiendo que la herramienta de
    programación ofrece las funciones colectivas de difusión y reducción (escribir primero la versión secuencial). 
    Sólo el proceso 0 imprimirá en pantalla. En la función de difusión,
    \verb|broadcast(buffer,count,datatype,idproc,group)|, se especifica:
    \begin{itemize}
        \item \verb|group|: identificador del grupo de procesos que intervienen en la comunicación, todos los procesos
        del grupo reciben.
        \item \verb|idproc|: identificador del proceso que envía.
        \item \verb|buffer|: dirección de comienzo en memoria de los datos que difunde \verb|idproc| y que almacenará,
        en todos los procesos del grupo, los datos difundidos.
        \item \verb|datatype|: tipo de los datos a enviar/recibir (entero de 32 bits, entero de 64 bits, flotante de 32
        bits, flotante de 64 bits, \dots).
        \item \verb|count|: número de datos a transferir de tipo \verb|datatype|.
    \end{itemize}
    En la función de reducción, \verb|reduction(sendbuf,recvbuf,count,datatype,oper,idproc,group)|,
    se especifica:
    \begin{itemize}
        \item \verb|group|: identificador del grupo de procesos que intervienen en la comunicación, todos los procesos
        del grupo envían.
        \item \verb|idproc|: identificador del proceso que recibe.
        \item \verb|recvbuf|: dirección en memoria a partir de la cual se almacena el escalar resultado de la reducción
        de todos los componentes de todos los vectores \verb|sendbuf|.
        \item \verb|sendbuf|: dirección en memoria a partir de la cual almacenan todos los procesos del grupo los
        datos de tipo \verb|datatype| a reducir (uno o varios).
        \item \verb|datatype|: tipo de los datos a enviar y recibir (entero de 32 bits, entero de 64 bits, flotante de 32
        bits, flotante de 64 bits, \dots).
        \item \verb|oper|: tipo de operación de reducción. Puede tomar los valores \verb|OR|, \verb|AND|, \verb|ADD|, \verb|MUL|,\verb|MIN|,\verb|MAX|
        \item \verb|count|: número de datos de tipo \verb|datatype|, del buffer \verb|sendbuffer| de cada proceso, que se van a reducir.
    \end{itemize}
\end{ejercicio}

\begin{ejercicio}~
    \begin{enumerate}
        \item\label{ej:2.13a} Escribir una versión paralela del programa paralelo del ejercicio \ref{ej:2.12} suponiendo que, además de las
        dos funciones colectivas anteriores, se dispone de dispersión y que $M$ es divisible entre el número de
        procesos (escribir primero la versión secuencial). Sólo el proceso 0 imprimirá en pantalla. La función
        \verb|scatter(sendbuf,sendcnt,recvbuf,recvcnt,datatype,idproc,group)| especifica:
        \begin{itemize}
            \item \verb|group|: identificador del grupo de procesos que intervienen en la comunicación, todos los procesos
            del grupo envían.
            \item \verb|idproc|: identificador del proceso que envía.
            \item \verb|recvbuf|: dirección en memoria a partir de la cual se almacenan los datos recibidos.
            \item \verb|sendbuf|: dirección en memoria a partir de la cual almacena el proceso \verb|idproc| los datos a enviar.
            \item \verb|sendtype|: tipo de los datos a enviar y recibir.
            \item \verb|recvcnt|: número de datos de tipo \verb|datatype| a recibir en \verb|recvbuf|.
            \item \verb|sendcnt|: número de datos de tipo \verb|datatype| a enviar.
        \end{itemize}

        \item ¿Qué estructura de procesos/tareas implementa el código paralelo del apartado \ref{ej:2.13a}? Justifique su respuesta.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Escribir una versión paralela del programa secuencial del ejercicio \ref{ej:2.11} para un multiprocesador
    usando el estilo de programación paralela de variables compartidas; en particular, use OpenMP (escribir
    primero la versión secuencial).
\end{ejercicio}

\begin{cuestion}
    Indique las diferencias entre OpenMP y MPI.
\end{cuestion}

\begin{cuestion}
    Ventajas e inconvenientes de una asignación estática de tareas a procesos/threads frente a una
    asignación dinámica.
\end{cuestion}

\begin{cuestion}
    ¿Qué se entiende por escalabilidad lineal y por escalabilidad superlineal? Indique las causas por
    las que se puede obtener una escalabilidad superlineal.
\end{cuestion}

\begin{cuestion}
    Enuncie la ley de Amdahl en el contexto de procesamiento paralelo.
\end{cuestion}

\begin{cuestion}
    Deduzca la expresión matemática que se suele utilizar para caracterizar la ley de Gustafson.
    Defina claramente y sin ambigüedad el punto de partida que va a utilizar para deducir esta expresión y cada
    una de las etiquetas que utilice. ¿Qué nos quiere decir Gustafson con esta ley?
\end{cuestion}

\begin{cuestion}
    Deduzca la expresión que caracteriza a la ley de Amdahl. Defina claramente el punto de partida y
    todas las etiquetas que utilice.
\end{cuestion}