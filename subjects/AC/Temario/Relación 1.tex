\section{Arquitecturas Paralelas}

\begin{ejercicio}
    En el código de prueba (benchmark) que ejecuta un procesador no segmentado que funciona a
    $300$ MHz, hay un 20\% de instrucciones \verb|LOAD| que necesitan 4 ciclos, un 10\% de
    instrucciones \verb|STORE| que necesitan 3 ciclos, un 25\% de instrucciones con operaciones de
    enteros que necesitan 6 ciclos, un 15\% de instrucciones con operandos en coma flotante que
    necesitan 8 ciclos por instrucción, y un 30\% de instrucciones de salto que necesitan 3 ciclos.
    \begin{enumerate}
        \item ¿Cuál es la ganancia que se puede obtener por reducción a 3 ciclos de las instrucciones
        con enteros?

        Resumimos los datos del enunciado en la siguiente tabla:
        \begin{table}[H]
            \centering
            \begin{tabular}{c|c|c}
                $I_i$ & $CPI_i^b$ & $NI_i$ \\
                \hline
                \verb|LOAD| & 4 ciclos & $0.2$ NI \\ 
                \verb|STORE| & 3 ciclos & $0.1$ NI \\
                \verb|FX. POINT| & 6 ciclos & $0.25$ NI \\
                \verb|FLT. POINT| & 8 ciclos & $0.15$ NI \\
                \verb|BRANCH| & 3 ciclos & $0.3$ NI
            \end{tabular}
        \end{table}
        donde $I_i$ es el tipo de instrucción,
        $CPI_i^b$ es el número de ciclos por instrucción y
        $NI_i$ es el número de instrucciones de ese tipo.

        El tiempo base $T_b$ que tardaría en ejecutarse el programa sin mejoras sería:
        \begin{align*}
            T_b &= NI \cdot CPI \cdot T_c = T_c \cdot \sum_{i} NI_i \cdot CPI_i
            =\\&= T_c \cdot NI \cdot \left(\underbrace{0.2 \cdot 4}_{LD} + \underbrace{0.1 \cdot 3}_{ST} + \underbrace{0.25 \cdot 6}_{FP} + \underbrace{0.15 \cdot 8}_{FLT~POINT} + \underbrace{ 0.3 \cdot 3}_{BRANCH}\right) =\\&= T_c \cdot NI \cdot 4.7
        \end{align*}
        donde $T_c$ representa el tiempo de ciclo. Respecto al tiempo mejorado $T_p$, sabiendo ahora
        que en caso de los números enteros el número de ciclos se reduce a 3, tendríamos:
        \begin{align*}
            T_p &= NI \cdot CPI \cdot T_c = T_c \cdot \sum_{i} NI_i \cdot CPI_i
            =\\&= T_c \cdot NI \cdot \left(\underbrace{0.2 \cdot 4}_{LD} + \underbrace{0.1 \cdot 3}_{ST} + \underbrace{0.25 \cdot \red{3}}_{FP} + \underbrace{0.15 \cdot 8}_{FLT~POINT} + \underbrace{ 0.3 \cdot 3}_{BRANCH}\right) =\\& = T_c \cdot NI \cdot 3.95
        \end{align*}

        La expresión de la ganancia, por tanto, es:
        \begin{equation*}
            S = \dfrac{T_b}{T_p} = \dfrac{\cancel{T_c} \cdot \bcancel{NI} \cdot 4.7}{\cancel{T_c} \cdot \bcancel{NI} \cdot 3.95} = \frac{4.7}{3.95} \approx 1.1898
        \end{equation*}

        \item ¿Cuál es la ganancia que se puede obtener por reducción a 3 ciclos de las instrucciones en coma flotante?
        
        Tenemos que:
        \begin{align*}
            T_p &= NI \cdot CPI \cdot T_c = T_c \cdot \sum_{i} NI_i \cdot CPI_i
            =\\&= T_c \cdot NI \cdot \left(\underbrace{0.2 \cdot 4}_{LD} + \underbrace{0.1 \cdot 3}_{ST} + \underbrace{0.25 \cdot 6}_{FP} + \underbrace{0.15 \cdot \red{3}}_{FLT~POINT} + \underbrace{ 0.3 \cdot 3}_{BRANCH}\right) =\\&= T_c \cdot NI \cdot 3.95
        \end{align*}

        La expresión de la ganancia, por tanto, es:
        \begin{equation*}
            S = \dfrac{T_b}{T_p} = \dfrac{\cancel{T_c} \cdot \bcancel{NI} \cdot 4.7}{\cancel{T_c} \cdot \bcancel{NI} \cdot 4.25} = \frac{4.7}{3.95} \approx 1.1898
        \end{equation*}

        Como podemos ver, la ganancia es la misma que en el caso anterior. Esto se debe a que, aun recudiendo más ciclos de reloj ($5$ en este caso, frente a $3$ en el anterior),
        el número de instrucciones de coma flotante es menor que el número de instrucciones de enteros, por lo que la ganancia se compensa.
        Se tiene que $0.25 \cdot 3 = 0.15 \cdot 5$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Un circuito que implementaba una operación en un tiempo de $T_{op}=450$ ns se ha segmentado
    mediante un cauce lineal con cuatro etapas de duración $T_1=100$ ns, $T_2=125$ ns, $T_3=125$ ns y
    $T_4=100$ ns respectivamente, separadas por un registro de acoplo que introduce un retardo de
    $25$ ns.
    \begin{enumerate}
        \item ¿Cuál es la máxima ganancia de velocidad posible? ¿Cuál es la productividad máxima
        del cauce?

        Tenemos que el ciclo de reloj es de $T_c = 125ns + 25ns = 150ns$, ya que depende de la etepa de ejecución más lenta.
        La ganancia de velocidad, siendo $N$ el número de operaciones, es:
        \begin{equation*}
            S(N) = \frac{T^b(N)}{T^s(N)} 
        \end{equation*}
        donde $T^b(N)$ es el tiempo base y $T^s(N)$ es el tiempo usando segmentación.
        El tiempo base es directo ver que es $T^b(N) = N\cdot T_{op}$, mientras que el tiempo segmentado es algo más complejo,
        ya que hay que tener en cuenta el tiempo que tarda el cauce en llenarse.
        Una vez está lleno, ejecuta una operación cada ciclo de reloj, pero la primera operación
        tarda $N_{\text{etapas}} \cdot T_c$. Por tanto, el tiempo segmentado es:
        \begin{align*}
            T^s(N) &= \left[1\cdot N_{\text{etapas}} \cdot T_c\right] + \left[(N-1)\cdot T_c\right]
            = N_{\text{etapas}} \cdot T_c + (N-1)T_c
            =\\&= 4 \cdot T_c + (N-1)T_c
        \end{align*}
        donde el 4 se debe a que es el número de etapas del cauce. Por tanto, la ganancia de velocidad es:
        \begin{equation*}
            S(N) = \frac{T^b(N)}{T^s(N)}
            = \frac{N\cdot T_{op}}{4\cdot T_c + (N-1)T_c}
            = \frac{N\cdot T_{op}}{T_c\cdot (4 + N-1)}
            = \frac{N\cdot 450}{150 \cdot (3+N)}
            = \frac{3N}{3+N}
        \end{equation*}
        
        La ganancia máxima se presupone que se alcanza cuando $N\to\infty$, por lo que:
        \begin{equation*}
            S_{\max} = S(N\ggg) = \lim_{N\to\infty} S(N) = \lim_{N\to\infty} \frac{N\cdot T_{op}}{T_c\cdot (3+N)} = \frac{T_{op}}{T_c} = \frac{450}{150} = 3
        \end{equation*}

        Respecto a la productividad del cauce, se tiene que:
        \begin{equation*}
            P(N) = \frac{N}{T^s(N)} = \frac{N}{4\cdot T_c + (N-1)T_c}
            = \frac{N}{150\cdot (3+N)}~\unitfrac{op}{ns}
            = \frac{N}{150\cdot (3+N)}\cdot 10^3~\unitfrac{Mop}{s}
        \end{equation*}

        La productividad máxima del cauce es:
        \begin{equation*}
            P_{\max} = \lim_{N\to\infty} P(N) = \lim_{N\to\infty} \frac{N}{150\cdot (3+N)}\cdot 10^3 = \frac{10^3}{150} \approx 6.667~\unitfrac{Mop}{s}
        \end{equation*}
        

        \item ¿A partir de qué número de operaciones ejecutadas se consigue una productividad igual
        al 90\% de la productividad máxima?\\

        Tenemos que:
        \begin{align*}
            \frac{N}{150\cdot (3+N)}\cdot 10^3 &= 0.9 \cdot P_{\max} = 0.9 \cdot \frac{10^3}{150}
            \Longrightarrow \frac{N}{3+N} = 0.9 \Longrightarrow\\&\Longrightarrow N = 2.7 + 0.9N \Longrightarrow 0.1N = 2.7 \Longrightarrow N = 27
        \end{align*}

        Por tanto, a partir de 27 operaciones ejecutadas se consigue una productividad igual al 90\% de la productividad máxima.
    \end{enumerate}
\end{ejercicio}


\begin{ejercicio} \label{ej:1.3}
    En un procesador sin segmentación de cauce, determine cuál de estas dos alternativas para
    realizar un salto condicional es mejor:
    \begin{itemize}
        \item \ul{ALT1}: Una instrucción \verb|COMPARE| actualiza un código de condición y es seguida por una instrucción \verb|BRANCH| que comprueba esa condición. Se usan dos intrucciones.
        \item \ul{ALT2}: Una sola instrucción incluye la funcionalidad de las instrucciones \verb|COMPARE| y \verb|BRANCH|. Se usa una única instrucción.
    \end{itemize}

    Hay que tener en cuenta que hay un 20\% de instrucciones \verb|BRANCH| para \ul{ALT1}
    en el conjunto de programas de prueba; que las instrucciones \verb|BRANCH| en \ul{ALT1} y
    \verb|COMPARE+BRANCH| en \ul{ALT2} necesitan 4 ciclos mientras que todas las demás necesitan sólo 3;
    y que el ciclo de reloj de la \ul{ALT1} es un 25\% menor que el de la \ul{ALT2}, dado que en este caso
    la mayor funcionalidad de la instrucción \verb|COMPARE+BRANCH| ocasiona una mayor complejidad en el procesador.\\

    En todo el ejercicio, el superíndice $1$ denotará la \ul{ALT1}, mientras que
    el superíndice $2$ denotará la \ul{ALT2}.
    Como el tiempo de ciclo de reloj depende de la ejecución más lenta, es normal que este cambie (como se especifica en el enunciado).
    La relación entre los tiempos de ciclo, dada por el enunciado, es la siguiente:
    \begin{equation*}
        T_c^1 = T_c^2 - 0.25 T_c^2 = 0.75 T_c^2
    \end{equation*}

    Resumimos los datos del enunciado en la siguiente tabla:
    \begin{table}[H]
        \centering
        \begin{tabular}{c|c|c||c|c|c}
            $I_i^1$ & $CPI_i^1$ & $NI_i^1$ & $I_i^2$ & $CPI_i^2$ & $NI_i^2$ \\
            \hline
            \verb|BRANCH| & 4 ciclos & $0.2 \cdot NI^1$ & \verb|COMPARE+BRANCH| & 4 ciclos & $0.2 \cdot NI^1$ \\
            \verb|COMPARE| & 3 ciclos & $0.2 \cdot NI^1$ &  &  &  \\
            Demás & 3 ciclos & $0.6 \cdot NI^1$ & Demás & 3 ciclos & $0.6 \cdot NI^1$ \\
            \hline
            & & $NI^1$ &  &  & $0.8 \cdot NI^1$ = $NI^2$ \\
        \end{tabular}
    \end{table}

    Hay que tener en cuenta que sabemos que cada salto conlleva un \verb|BRANCH| y un \verb|COMPARE| en la primera alternativa,
    por lo que hay el mismo número de instrucciones de dichos tipos. Además, como el programa es el mismo,
    tenemos que hay el mismo número de instrucciones de salto en ambos, por eso deducimos el número de instrucciones de salto en la segunda alternativa.
    Tiene sentido que $NI^2 < NI^1$, ya que cada instucción de salto conlleva 2 órdenes en la primera alternativa, mientras que en la segunda conlleva una sola.

    Tenemos que ver qué alternativa nos da un tiempo de ejecución menor
    (tengamos en cuenta que el tiempo de ciclo de cada uno no es el mismo, por lo que tenemos que pasarlo todo al mismo tiempo de ciclo):
    \begin{align*}
        T_{CPU}^1 &= NI^1 \cdot (\underbrace{0.2 \cdot 4}_{BR} + \underbrace{0.8 \cdot 3}_{CMP+\text{Resto}}) \cdot T_c^1 = NI^1 \cdot 3.2 \cdot 0.75 \cdot T_c^2 = NI^1 \cdot 2.4 \cdot T_c^2\\
        T_{CPU}^2 &= NI^1 \cdot (\underbrace{0.2 \cdot 4}_{CMPBR} + \underbrace{0.6\cdot 3}_{\text{Resto}}) \cdot T_c^2 = NI^1 \cdot 2.6 \cdot T_c^2
    \end{align*}

    Por tanto,
    \begin{equation*}
        \frac{T_{CPU}^1}{T_{CPU}^2} = \frac{2.4}{2.6} = \frac{12}{13} \approx 0.923 \Longrightarrow T_{CPU}^1 < T_{CPU}^2
    \end{equation*}

    Por ser $T_{CPU}^1 < T_{CPU}^2$, concluimos que la opción \ul{ALT1} es la mejor, en cuanto a tiempos de ejecución.
\end{ejercicio}

\begin{ejercicio}
    ¿Qué ocurriría en el problema del ejercicio anterior (Ejercicio \ref{ej:1.3}) si el ciclo de reloj fuese únicamente un 10\% mayor para
    la \ul{ALT2}?\\

    En este caso, el tiempo de ciclo de la \ul{ALT1} sería:
    \begin{equation*}
        T_c^1 = T_c^2 - 0.1 T_c^2 = 0.9 T_c^2
    \end{equation*}

    Por tanto, los tiempos de ejecución serían:
    \begin{align*}
        T_{CPU}^1 &= NI^1 \cdot (\underbrace{0.2 \cdot 4}_{BR} + \underbrace{0.8 \cdot 3}_{CMP+\text{Resto}}) \cdot T_c^1 = NI^1 \cdot 3.2 \cdot 0.9 \cdot T_c^2 = NI^1 \cdot 2.88 \cdot T_c^2\\
        T_{CPU}^2 &= NI^1 \cdot (\underbrace{0.2 \cdot 4}_{CMPBR} + \underbrace{0.6\cdot 3}_{\text{Resto}}) \cdot T_c^2 = NI^1 \cdot 2.6 \cdot T_c^2
    \end{align*}

    Por tanto,
    \begin{equation*}
        \frac{T_{CPU}^1}{T_{CPU}^2} = \frac{2.88}{2.6} = \frac{72}{65} \approx 1.1077 \Longrightarrow T_{CPU}^1 > T_{CPU}^2
    \end{equation*}

    Por ser $T_{CPU}^1 > T_{CPU}^2$, concluimos que la opción \ul{ALT2} es la mejor, en cuanto a tiempos de ejecución.    
\end{ejercicio}

\begin{ejercicio} \label{ej:1.5}
    Considere un procesador no segmentado con una arquitectura de tipo \verb|LOAD/STORE| en la que las
    operaciones sólo utilizan como operandos registros de la CPU. Para un conjunto de programas
    representativos de su actividad se tiene que el 43\% de las instrucciones son operaciones con la ALU (3 CPI),
    el 21\% \verb|LOAD|s (4 CPI), el 12\% \verb|STORE|s (4 CPI) y el 24\% \verb|BRANCH|s (4 CPI).
    Se ha podido comprobar que un 25\% de las operaciones con la ALU utilizan operandos en registros que no se
    vuelven a utilizar. Compruebe si mejorarían las prestaciones si, para sustituir ese 25\% de operaciones, se
    añaden instrucciones con un dato en un registro y otro en memoria. Tengan en cuenta en la comprobación que para estas nuevas instrucciones el valor de CPI es 4 y que añadirlas ocasiona un incremento de un ciclo
    en el CPI de los \verb|BRANCH|, pero no afectan al ciclo de reloj.\\

    Resumimos los datos del enunciado en la siguiente tabla, donde el superíndice $1$ denotará la primera alternativa y el superíndice $2$ denotará la segunda:
    \begin{table}[H]
        \centering
        \begin{tabular}{c|c|c||c|c|c}
            $I_i^1$ & $CPI_i^1$ & $NI_i^1$ & $I_i^2$ & $CPI_i^2$ & $NI_i^2$ \\
            \hline
            Instrucción ALU & 3 ciclos & $0.43 \cdot NI^1$ & \verb|ALU r,r| & 3 ciclos & $0.3225 \cdot NI^1$ \\
                            & & & \verb|ALU r,m| & 4 ciclos &  $ 0.1075 \cdot NI^1$ \\
            \verb|LOAD|s & 4 ciclos & $0.21 \cdot NI^1$ & \verb|LOAD|s & 4 ciclos & $0.1025 \cdot NI^1$ \\
            \verb|STORE|s & 4 ciclos & $0.12 \cdot NI^1$ & \verb|STORE|s & 4 ciclos & $0.12 \cdot NI^1$ \\
            \verb|BRANCH|s & 4 ciclos & $0.24 \cdot NI^1$ & \verb|BRANCH|s & 5 ciclos & $0.24 \cdot NI^1$  \\
            \hline
                           & & & & & $0.8925\cdot NI^1 = NI^2$ \\
        \end{tabular}
    \end{table}
    donde, cada $NI_i^2$ se ha calculado de la siguiente forma:
    \begin{itemize}
        \item Para \verb|ALU r,r|, se ha usado que son el $75\%$ de las operaciones con la ALU, es decir, $NI^2{\sb\texttt{ALU r,r}}=0.75 \cdot 0.43 \cdot NI^1 = 0.3225 \cdot NI^1$.
        \item Para \verb|ALU r,m|, se ha usado que son el $25\%$ de las operaciones con la ALU, es decir, $NI^2{\sb\texttt{ALU r,m}} = 0.25 \cdot 0.43 \cdot NI^1 = 0.1075 \cdot NI^1$.
        \item Para \verb|LOAD|s, se ha usado que en la alternativa 2 se hacen $0.1075 \cdot NI^1$ \verb|LOAD|s menos que en la alternativa 1, ya que las instrucciones que usan un operando de memoria no es necesario que se traigan de memoria.
        Por tanto, tenemos que son $NI^2{\sb\texttt{LOADs}} = 0.21 \cdot NI^1 - 0.1075 \cdot NI^1 = 0.1025 \cdot NI^1$.
    \end{itemize}

    Calculamos los tiempos en CPU de ambas alternativas:
    \begin{align*}
        T_{CPU}^1 &= NI^1 [0.43\cdot 3 +(0.21+0.12+0.24)\cdot 4] \cdot T_c\\
                  &= NI^1 \cdot 3.57 \cdot T_c\\
                  & \\
        T_{CPU}^2 &= NI^1 [0.3225\cdot 3 + (0.1075+0.1025+0.12)\cdot 4 + 0.24 \cdot 5] \cdot T_c\\
        &= NI^1 \cdot 3.4875 \cdot T_c
    \end{align*}

    Y tenemos que $T_{CPU}^2 < T_{CPU}^1$, luego sí que mejorarían las prestaciones.

\end{ejercicio}

\begin{ejercicio}
    Se ha diseñado un compilador para la máquina \verb|LOAD/STORE| del problema anterior (Ejercicio \ref{ej:1.5}). Ese
    compilador puede reducir en un 50\% el número de operaciones con la ALU, pero no reduce el número de
    \verb|LOAD|s, \verb|STORE|s, y \verb|BRANCH|s. Suponiendo que la frecuencia de reloj es de $50$ Mhz,
    ¿Cuál es el número de
    MIPS y el tiempo de ejecución que se consigue con el código optimizado? Compárelos con los
    correspondientes del código no optimizado.\\

    El código no optimizado se representa con el superíndice $1$, mientras que el código optimizado se representa con el superíndice $2$.
    \begin{table}[H]
        \centering
        \begin{tabular}{c|c|c||c|c|c}
            $I_i^1$ & $CPI_i^1$ & $NI_i^1$ & $I_i^2$ & $CPI_i^2$ & $NI_i^2$ \\
            \hline
            Instrucción ALU & 3 ciclos & $0.43 \cdot NI^1$ & Instrucción ALU & 3 ciclos & $0.215 \cdot NI^1$ \\
            \verb|LOAD|s & 4 ciclos & $0.21 \cdot NI^1$ & \verb|LOAD|s & 4 ciclos & $0.21 \cdot NI^1$ \\
            \verb|STORE|s & 4 ciclos & $0.12 \cdot NI^1$ & \verb|STORE|s & 4 ciclos & $0.12 \cdot NI^1$ \\
            \verb|BRANCH|s & 4 ciclos & $0.24 \cdot NI^1$ & \verb|BRANCH|s & 4 ciclos & $0.24 \cdot NI^1$  \\
            \hline
                           & & & & & $0.785\cdot NI^1 = NI^2$ \\
        \end{tabular}
    \end{table}

    Calculamos los tiempos en CPU de ambas alternativas:
    \begin{align*}
        T_{CPU}^1 &= NI^1 [0.43\cdot 3 +(0.21+0.12+0.24)\cdot 4] \cdot T_c\\
                  &= NI^1 \cdot 3.57 \cdot T_c
                  = NI^1 \cdot 3.57 \cdot \frac{1}{50\cdot 10^6} \text{ seg}
                  = NI^1 \cdot 7.14 \cdot 10^{-8} \text{ seg}
                  & \\
        T_{CPU}^2 &= NI^1 [0.215\cdot 3 + (0.21+0.12+0.24)\cdot 4] \cdot T_c\\
        &= NI^1 \cdot 2.925 \cdot T_c
        = NI^1 \cdot 2.925 \cdot \frac{1}{50\cdot 10^6} \text{ seg}
        = NI^1 \cdot 5.85 \cdot 10^{-8} \text{ seg}
    \end{align*}

    Calculamos ahora el número de MIPS de ambas alternativas:
    \begin{align*}
        MIPS^1 &= \frac{NI^1}{T_{CPU}^1\cdot 10^{6}} = \frac{NI^1}{NI^1 \cdot 7.14 \cdot 10^{-8}\cdot 10^{6}} = \frac{1}{7.14 \cdot 10^{-2}} = 14 \text{ MIPS} \\
        MIPS^2 &= \frac{NI^2}{T_{CPU}^2\cdot 10^{6}} = \frac{0.785\cdot NI^1}{NI^1 \cdot 5.85 \cdot 10^{-8}\cdot 10^{6}} = \frac{1}{7.4522 \cdot 10^{-2}} = 13.4188 \text{ MIPS}
    \end{align*}

    Como podemos ver, de forma objetiva el código optimizado es mejor que el no optimizado, ya que $T_{CPU}^2 < T_{CPU}^1$.
    No obstante, si solo nos fijásemos en el número de MIPS, podríamos pensar que el código no optimizado es mejor que el optimizado, ya que $MIPS^1 > MIPS^2$; pero
    sabemos que esta medida no es una medida objetiva, ya que tan solo depende de la frecuencia y de los ciclos por instrucción, y no tiene en cuenta el número de instrucciones.
\end{ejercicio}

\begin{ejercicio}
    En un programa que se ejecutan en un procesador no segmentado que funciona a 100 MHz, hay
    un 20\% de instrucciones \verb|LOAD| que necesitan 4 ciclos, un 15\% de instrucciones \verb|STORE| que necesitan 3 ciclos,
    un 40\% de instrucciones con operaciones en la ALU que necesitan 6 ciclos, y un 25\% de instrucciones de
    salto que necesitan 3 ciclos.
    \begin{enumerate}
        \item\label{ej:1.7a}
        Si en las instrucciones que usan la ALU el tiempo en la ALU supone 4 ciclos, determine cuál es la máxima ganancia que se puede obtener si se mejora el diseño de la ALU de forma que
        se reduce su tiempo de ejecución a la mitad de ciclos.\\

        Resumimos los datos del enunciado en la siguiente tabla:
        \begin{table}[H]
            \centering
            \begin{tabular}{c|c|c||c}
                $I_i$ & $CPI_i^b$ & $NI_i$ & $CPI_i^p$ \\
                \hline
                \verb|LOAD| & 4 ciclos & $0.2$ NI & 4 ciclos \\ 
                \verb|STORE| & 3 ciclos & $0.15$ NI & 3 ciclos \\
                Instrucción ALU & 6 ciclos & $0.4$ NI & 4 ciclos \\
                \verb|BRANCH| & 3 ciclos & $0.25$ NI & 3 ciclos
            \end{tabular}
        \end{table}
        Hemos de notar que el número de instrucciones de la ALU no cambia, ya que no se ha especificado que se reduzca el número de instrucciones de la ALU.
        Además, no se reduce de 6 a 3, ya que tan solo se reducen a la mitad los 4 ciclos que tarda en ejecutarse la instrucción de la ALU.
        Por tanto, se tiene que $CPI_{\text{ALU}}^2 = 2+4\cdot \nicefrac{1}{2} = 4$.
        Por tanto, la ganancia para un número de instrucciones $NI$ es:
        \begin{equation*}
            S (NI) = \frac{T^b(NI)}{T^p(NI)} = \frac{NI \cdot (0.2\cdot 4 + 0.15\cdot 3 + 0.4\cdot 6 + 0.25\cdot 3) \cdot T_c}{NI \cdot (0.2\cdot 4 + 0.15\cdot 3 + 0.4\cdot 4 + 0.25\cdot 3) \cdot T_c} = \frac{4.4}{3.6} = \frac{11}{9} \approx 1.222
        \end{equation*}
        
        \item ¿Con qué porcentaje de instrucciones con operaciones en la ALU se podría haber obtenido en los cálculos del apartado \ref{ej:1.7a} una ganancia mayor que 2?
        Razone su respuesta.\\

        Para ver que no es posible, usaremos la Ley de Amdahl. Supongamos que el porcentaje de instrucciones con operaciones que no son de la ALU es $f$.
        El factor de mejora de la ALU es $p=\frac{6}{4}=1.5$. Por tanto, por la Ley de Amdahl, tenemos que:
        \begin{equation*}
            S \leq \frac{p}{1+f(p-1)} = \frac{1.5}{1+f\cdot 0.5} \leq 1.5 \qquad \forall f\in [0,1]
        \end{equation*}
        Por tanto, tenemos que la ganancia está acotada por $1.5$, por lo que no es posible obtener una ganancia mayor que 2.
    \end{enumerate}
\end{ejercicio}


\begin{ejercicio}
    Suponga que en los programas que constituyen la carga de trabajo habitual de un procesador las
    instrucciones de coma flotante consumen un promedio del 13\% del tiempo del procesador.
    \begin{enumerate}
        \item Ha aparecido en el mercado una nueva versión del procesador en la que la única mejora con respecto a la
        versión anterior es una nueva unidad de coma flotante que permite reducir el tiempo de las instrucciones de
        coma flotante a tres cuartas partes del tiempo que consumían antes. ¿Cuál es la máxima ganancia de
        velocidad que puede esperarse en los programas que constituyen la carga de trabajo si se utiliza la nueva
        versión del procesador?\\

        El porcentaje de ejecución de las instrucciones que no son de coma flotante es $f=1-0.13=0.87$; mientras
        que el factor de mejora es $p=\nicefrac{4}{3}$. Por tanto, la ganancia máxima es:        
        \begin{equation*}
            S = \dfrac{T_b}{T_p} \leq \frac{p}{1+f(p-1)} = \frac{\nicefrac{4}{3}}{1+0.87\cdot \nicefrac{1}{3}} \approx 1.0336
        \end{equation*}

        \item\label{ej:1.8b} ¿Cuál es la máxima ganancia de velocidad con respecto a la versión inicial del procesador que, en
        promedio, puede esperarse en los programas debido a mejoras en la velocidad de las operaciones en coma
        flotante?\\

        Sea $p$ el factor de mejora de la unidad de coma flotante. Tenemos que:
        \begin{equation*}
            S \leq \frac{p}{1+f(p-1)} = \frac{p}{1+0.87(p-1)}
        \end{equation*}

        Suponiendo que el factor de mejora es muy grande, es decir, $p\to\infty$, tenemos que:
        \begin{equation*}
            S_{\max} = \lim_{p\to\infty} \frac{p}{1+0.87(p-1)} = \frac{1}{0.87} \approx 1.149
        \end{equation*}

        \item\label{ej:1.8c} ¿Cuál debería ser el porcentaje de tiempo de cálculo con datos en coma flotante en los programas para
        esperar una ganancia máxima de 4 en lugar de la obtenida en el apartado \ref{ej:1.8b}?\\

        Calcularemos en primer lugar $f$, que representa el porcentaje de tiempo de cálculo con datos que no son en coma flotante:
        \begin{equation*}
            4 = S_{\max} = \lim_{p\to\infty} \frac{p}{1+f(p-1)} = \frac{1}{f} \Longrightarrow f = \frac{1}{4} = 0.25
        \end{equation*}
        
        Por tanto, el porcentaje de tiempo de cálculo con datos en coma flotante es $1-f=0.75$; es decir, el $75\%$.

        \item ¿Cuánto debería reducirse el tiempo de las operaciones en coma flotante con respecto a la situación
        inicial para que la ganancia máxima sea 2 suponiendo que en la versión inicial el porcentaje de tiempo de
        cálculo con como flotante es el obtenido en el apartado \ref{ej:1.8c}?\\

        Se trata de buscar $p$, suponiendo que tenemos un 75\% de operaciones de coma flotante; es decir, $f=0.25$. Tenemos que:
        \begin{align*}
            2 = S_{\max} &= \frac{p}{1+f(p-1)} = \frac{p}{1+0.25(p-1)} = \frac{p}{0.75+0.25p} \Longrightarrow \\
            &\Longrightarrow 2(0.75+0.25p) = p \Longrightarrow 1.5+0.5p = p \Longrightarrow 1.5 = 0.5p \Longrightarrow p = 3
        \end{align*}

        Por tanto, el tiempo de las operaciones en coma flotante debería reducirse a un tercio del tiempo que consumían antes.

    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Suponga que, en el código siguiente, \verb|a[]| es un array de números de 32 bits en coma flotante y b
    un número de 32 bits en coma flotante y que debería ejecutarse en menos de $0.5$ segundos para $\verb|N|=10^9$:
    \begin{minted}[xleftmargin=3cm]{c++}
for (i=0; i<N; i++)
    a[i+2]=(a[i+2]+a[i+1]+a[i])*b;
    \end{minted}

    \begin{enumerate}
        \item ¿Cuántos GFLOPS se necesitan para poder ejecutar el código en menos de $0.5$ segundos?\\
        
        En este caso, necesitamos $T_{CPU} \leq 0.5$ segundos. Sabemos que el número de operaciones en coma flotante es $3\cdot N$ (dos sumas y una multiplicación por cada iteración del bucle). Por tanto, necesitamos:
        \begin{equation*}
            GFLOPS = \dfrac{\text{nº FP}}{T_{CPU}\cdot 10^9} = \dfrac{3\cdot N}{T_{CPU}\cdot 10^9} \geq \dfrac{3\cdot 10^9}{0.5\cdot 10^9} = 6
        \end{equation*}

        Por tanto, necesitamos al menos 6 GFLOPS para poder ejecutar el código en menos de $0.5$ segundos.

        \item Suponiendo que este código en ensamblador tiene 7N instrucciones y que se ha ejecutado en un
        procesador de 32 bits a 2 GHz. ¿Cual es el número medio de instrucciones que el procesador tiene que poder
        completar por ciclo para poder ejecutar el código en menos de $0.5$ segundos?\\

        Tenemos que:
        \begin{equation*}
            T_{CPU} = NI \cdot CPI \cdot T_c = \dfrac{NI}{IPC \cdot F}
            \Longrightarrow IPC = \dfrac{NI}{T_{CPU}\cdot F}
        \end{equation*}

        Como buscamos que $T_{CPU} \leq 0.5$ segundos, tenemos que:
        \begin{equation*}
            IPC \geq \dfrac{7\cdot 10^9}{0.5\cdot 2\cdot 10^9} = 7
        \end{equation*}

        Por tanto, el número medio de instrucciones que el procesador tiene que poder completar por ciclo para poder ejecutar el código en menos de $0.5$ segundos es al menos 7.
        
        \item Estimando que el programa pasa el 75\% de su tiempo de ejecución realizando operaciones en coma
        flotante, ¿cuánto disminuiría como mucho el tiempo de ejecución si se redujesen un 75\% los tiempos de las
        unidades de coma flotante?\\

        En este caso, sea $f$ el porcentaje de tiempo de cálculo con datos que no son en coma flotante, $f=0.25$;
        y sea $p$ el factor de mejora de la unidad de coma flotante, $p=4$, ya que el tiempo se reduce a una cuarta parte. Tenemos que la mejora máxima sería:
        \begin{equation*}
            S_{\max} = \frac{T_{CPU}^b}{T_{CPU}^p} \leq \frac{p}{1+f(p-1)} = \frac{4}{1+0.25\cdot 3} = \frac{4}{1.75} = \frac{16}{7} \approx 2.2857
        \end{equation*}

        Por tanto, tenemos que $T_{CPU}^b \leq 2.2857 \cdot T_{CPU}^p$; o equivalentemente tenemos $T_{CPU}^p \geq 0.4375 \cdot T_{CPU}^b$;
        es decir, el tiempo de ejecución disminuiría como mucho un $(100-43.75)\% = 56.25\%$.
    \end{enumerate}
\end{ejercicio}


\begin{ejercicio}
    Un compilador ha generado un código máquina optimizado para el siguiente programa
    \begin{minted}[xleftmargin=3cm]{c++}
par=0; impar=0;
for (i=0;i<N;i++)
    if ((i%2) == 0)
        par=par+c*x[i];
    else
        impar=impar-c*x[i];
    \end{minted}
    sin utilizar instrucciones de salto dentro de las iteraciones del bucle (porque se ha usado la técnica de
    desenrollado del bucle que veremos en el Seminario 4): el código tiene un número de iteraciones de $\nicefrac{N}{2}$, 7
    instrucciones fuera del bucle (2 de almacenamiento en memoria, 5 instrucciones para inicializar registros), 9
    instrucciones dentro del bucle (4 instrucciones para implementar el bucle \verb|for|: incremento de la variable de
    control \verb|i|, comparación, salto condicional y un salto incondicional; 4 instrucciones coma flotante y 2
    instrucciones de carga desde memoria a registro (se leen dos componentes de \verb|x|). El computador donde se
    ejecuta dispone de:
    \begin{itemize}
        \item Un procesador superescalar de 32 bits a 2 GHz capaz de terminar dos instrucciones de coma
        flotante por ciclo y dos instrucciones de cualquier otro tipo por ciclo, excepto instrucciones de carga,
        cuyo tiempo depende de si hay o no fallo de cache (si no hay fallo de cache suponen 1 ciclo), y las
        instrucciones de almacenamiento que suponen 1 ciclo.
        \item Dos caches integradas en el chip de procesamiento (una para datos y otra para instrucciones) de
        512 KBytes cada una, mapeo directo, política de actualización de postescritura, líneas de 32 bytes, y
        latencia de un ciclo de reloj.
        \item Una memoria principal con latencia de 30 ns. y ciclos burst 6-1-1-1 a través de un bus de memoria de
        200 MHz con 64 bits.
    \end{itemize}
    Conteste a las siguientes cuestiones:
    \begin{enumerate}
        \item ¿Cuál es la velocidad pico del procesador (en GFLOPS)?
        \item ¿Cuál es el tiempo mínimo que tarda en ejecutarse el programa para $\verb|N|=211$?
        \item ¿Cuántos MFLOPS alcanza el programa?
    \end{enumerate}

    \begin{observacion}
        Considere que el vector \verb|x| se almacena en memoria en una dirección múltiplo del tamaño de una
        línea de cache y que ningún componente está en cache cuando se referencia; \verb|N|, \verb|i| estarán en
        registros de enteros, \verb|par|, \verb|impar|, \verb|c|, y \verb|x[]| son números de 32 bits en coma
        flotante; dentro del bucle \verb|c|, \verb|par| e \verb|impar| estarán en registros.
    \end{observacion}
\end{ejercicio}


\subsection{Cuestiones}
\begin{cuestion}
    Indique cuál es la diferencia fundamental entre una arquitectura CC-NUMA y una arquitectura
    SMP.
\end{cuestion}

\begin{cuestion}
    ¿Cuándo diría que un computador es un multiprocesador y cuándo que es un multicomputador?
\end{cuestion}

\begin{cuestion}
    ¿Un CC-NUMA escala más que un SMP? ¿Por qué?
\end{cuestion}

\begin{cuestion}
    Indique qué niveles de paralelismo implícito en una aplicación puede aprovechar un PC con un
    procesador de 4 cores, teniendo en cuenta que cada core tiene unidades funcionales SIMD (también
    llamadas unidades multimedia) y una microarquitectura segmentada y superscalar. Razone su respuesta.
\end{cuestion}

\begin{cuestion}
    Si le dicen que un ordenador es de 20 GIPS ¿puede estar seguro que ejecutará cualquier
    programa de $20000$ instrucciones en un microsegundo?\\

    No: si un programa que ejecuta 20000 instrucciones tarda 1 microsegundo, tendríamos efectivamente que el programa se ha ejecutado a una velocidad de 20 GIPS. Sin embargo, \ul{no} podemos estar seguros de que cualquier programa de 20000 instrucciones tarde en ejecutarse un microsegundo, ya que depende de las características de las instrucciones que componen al programa:
    \begin{itemize}
        \item El número de instrucciones que constituyen un programa puede ser dinstinto del número de instrucciones que finalmente ejecuta el procesador (se trata por tanto de un número dinámico de instrucciones), ya que puede haber instruccioens de salto, bucles, $\ldots$ que hacen que ciertas instrucciones del código se ejecuten más de una vez; y puede haber otras aque no se ejecuten nunca.
        \item Por otro lado, el tipo de instruccione sque constituyen el programa y las dependencias entre ellas pueden variar los tiempos de ejecución que tardan en ejecutarse las instrucciones.
    \end{itemize}
\end{cuestion}

\begin{cuestion}
    ¿Aceptaría financiar/embarcarse en un proyecto en el que se plantease el diseño e implementación de un
    computador de propósito general con arquitectura MISD? (Justifique su respuesta).
\end{cuestion}

\begin{cuestion}
    Deduzca la expresión que se usa para representar la ley de Amdahl suponiendo que se mejora un
    recurso del procesador, que hay una probabilidad $f$ de no utilizar dicho recurso y que la mejora supone
    un incremento en un factor de $p$ dela velocidad de procesamiento del recurso.
\end{cuestion}

\begin{cuestion}
    ¿Es cierto que si se mejora una parte de un sistema (por ejemplo, un recurso de un procesador) se
    observa experimentalmente que, al aumentar el factor de mejora, llega un momento en que se satura el
    incremento de velocidad que se consigue? (Justifique la respuesta)
\end{cuestion}

\begin{cuestion}
    ¿Es cierto que la cota para el incremento de velocidad que establece la ley de Amdahl crece a medida
    que aumenta el valor del factor de mejora aplicado al recurso o parte del sistema que se mejora?
    (Justifique la respuesta).
\end{cuestion}

\begin{cuestion}
    ¿Qué podría ser mejor suponiendo velocidades pico, un procesador superescalar capaz de emitir
    cuatro instrucciones por ciclo, o un procesador vectorial cuyo repertorio permite codificar 8 operaciones
    por instrucción y emite una instrucción por ciclo? (Justifique su respuesta).
\end{cuestion}

\begin{cuestion}
    En la Lección 2 de AC se han presentado diferentes criterios de clasificación de computadores y en
    el Seminario 0 de prácticas se ha presentado atcgrid. Clasifique atcgrid, sus nodos, sus encapsulados y
    sus núcleos dentro de la clasificación de Flynn y dentro de la clasificación que usa como criterio el
    sistema de memoria. Razone su respuesta.
\end{cuestion}

\begin{cuestion}
    En la Lección 1 de AC se han presentado diferentes criterios de clasificación del paralelismo implícito
    en una aplicación y en el Seminario 0 de prácticas se ha presentado atcgrid. ¿Qué tipos de paralelismo
    aprovecha atcgrid? Razone su respuesta.
\end{cuestion}

\subsection{Ejercicios adicionales}
\begin{ejercicio}
    En el bucle siguiente, los arrays \verb|a[]|, \verb|b[]|, \verb|c[]| y \verb|d[]|, son números en coma flotante de 64 bits y $n = 2\cdot 10^{10}$:
    \begin{minted}[xleftmargin=3cm]{c++}
for (i = 0; i < n; i++)
    d[i] = a[i] + b[i] + c[i];
    \end{minted}

    Si el programa se ejecuta en un procesador a 2 GHz que puede terminar dos operaciones en coma flotante por ciclo, ¿cuál es el tiempo mínimo que tardaría en ejecutarse? ¿Cuántos GFLOPS de velocidad pico tiene el procesador?\\

    Para calcular el tiempo mínimo que tardaría en ejecutarse, calculamos de forma teórica el tiempo que se necesita para ejecutar las instrucciones descritas en el código. Este es el tiempo mínimo ya que estamos despreciando muchos factores por simplificar el estudio que hacen que el tiempo de ejecución aumente. Hacemos uso de la fórmula del tiempo de CPU:
    \begin{equation*}
        T_{CPU} = NI_{float} \cdot CPI_{float} \cdot T_{ciclo} = \dfrac{NI_{float}}{IPC_{float} \cdot F} = \dfrac{\bcancel{2}\cdot 10^{\cancel{10}}}{\bcancel{2} \cdot (2\cdot \cancel{10^9})} = 5 \text{\ segundos}
    \end{equation*}

    A continuación, calculamos el número de GFLOPS pico del procesador, haciendo uso de la fórmula:
    \begin{equation*}
    GFLOPS = \dfrac{1}{CPI \cdot T_{ciclo} \cdot 10^9} = \dfrac{IPC \cdot F}{10^9} = \dfrac{2 \cdot (2 \cdot \cancel{10^9})}{\cancel{10^9}} = 4
    \end{equation*}
    Por lo que el procesador tiene 4 GFLOPS de velocidad pico.
\end{ejercicio}

\begin{ejercicio}
    La empresa DataNimbus estima que debe adquirir un nuevo computador con una velocidad pico de 100 TFLOPS para alcanzar los niveles de tiempos de respuesta requeridos en su nueva generación de algoritmos para aplicaciones Big Data. Se ha decidido configurar la máquina a base de nodos HP ProLiant SL230s Gen8. Concretamente, cada uno de estos servidores tiene dos procesadores Sandy Bridge Intel$^\copyright$ Xeon$^\copyright$ E5-2670 a $2.60$ GHz con 8 núcleos/procesador: 
    \begin{enumerate}
        \item ¿Cuántos nodos (servidores HP ProLiant SL230s) se necesitan para configurar la máquina de 100 TFLOPS?
        \item Clasifique el nuevo servidor que se pretende adquirir, sus nodos, sus encapsulados y sus núcleos dentro de la clasificación de Flynn y dentro de la clasificación que usa como criterio el sistema de memoria.
        \item ¿Cuál es el número máximo de operaciones de coma flotante por ciclo de cada core del Intel Xeon E5-2670?
    \end{enumerate}
    Nota: El Yellowstone National enter for Atmospheric Research, que utiliza el mismo procesador que quermos montar, tiene una velocidad pico de 1503590 GFLOPS y contiene 72288 núcleos.

    \begin{enumerate}
        \item Como sabemos, por la información que nos proporcina la nota, la velocidad pico de un núcleo para operaciones en coma flotante es:
            \begin{equation*}
                \dfrac{1503590}{72288} = 20.8 \text{\ GFLOPS/núcleo}
            \end{equation*}
            Dado que hay que alcanzar 100 TFLOPS $= 100\cdot 10^3$ GFLOPS, el número de núcleos que necesitamos es:
            \begin{equation*}
                \dfrac{100\cdot 10^3}{20.8} = 4807.7 \text{\ núcleos}
            \end{equation*}
            Es decir, 4808 núcleos.

            Como el servidor HP ProLiant SL230s que se utiliza en cada nodo tiene 16 núcleos (2 microprocesadores con 8 núcleos cada uno), el número de nodos necesarios sería:
            \begin{equation*}
                \dfrac{4808}{16} = 300.5 \longrightarrow 301 \text{\ nodos}
            \end{equation*}

        \item Desde el punto de vista de la taxonomía Flynn, es un computador MIMD. Cada uno de los microprocesadores que hay en el nodo tiene 8 núcleos que comparten la memoria local del microprocesdor y por tanto son multiprocesadores UMA. Estos dos microprocesadores se interconectan en el nodo constituyendo un procesador NUMA dado que cada uno de ellos tiene su memoria principal local. Los nodos están interconectados a través de una red y configuran un computador NORMA o cluster.

        \item Para este último punto, simplemente tenemos que observar la fórmula de los GFLOPS:
            \begin{equation*}
                GFLOPS = \dfrac{\text{Operaciones coma flotante}}{T_{CPU}\cdot 10^9} = \dfrac{\text{Operaciones coma flotante}}{\text{Ciclos de programa} \cdot T_{ciclo}\cdot 10^9} 
            \end{equation*}
            De donde despejamos las operaciones de coma flotante ($Ops$) entre los ciclos de programa ($cdp$):
            \begin{equation*}
                \dfrac{Ops}{cdp} = GFLOPS \cdot 10^9\cdot T_{ciclo} = \dfrac{GFLOPS \cdot 10^9}{F} = \dfrac{20.8\cdot \cancel{10^9}}{2.6\cdot \cancel{10^9}} = 8
            \end{equation*}
            
            Por tanto, el número máximo de operaciones en coma flotante que puede terminar el núcleo por ciclo es 8.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Un procesador superescalar de 64 bits a 1 GHz capaz de finalizar tres instrucciones por ciclo ejecuta el programa que se indica a continuación:
    \begin{minted}[linenos,xleftmargin=3cm]{asm}
start:  ld      f0, a           // f0 = a
        add     r8, r0, r2      // r8 = r2 (r0 = 0)
        addi    r6, r8, #2048   // r6 = r8 + 2048
        add     r12, r0, r4     // r12 = r4 (r0 = 0)
loop:   ld      f2, 0(r8)       // f2 = m(r8)
        multd   f2, f0, f2      // f2 = f0 * f2
        ld      f4, 0(r12)      // f4 = m(r12)
        addd    f4, f2, f4      // f4 = f2 + f4
        sd      0(r12), f4      // m(r12) = f4
        addi    r8, r8, #8      // r8 = r8 + 8
        addi    r12, r12, #8    // r12 = r12 + 8
        sub     r16, r6, r8     // r16 = r6 - r8
        bnez    r16, loop       // Si r16 != 0, salta
    \end{minted}

    En el programa, \verb|a| es un número real, \verb|r0| es un registro que siempre está a cero, \verb|r2| contiene la dirección a partir de la cual empieza un array, \verb|X|, de números reales de 64 bits, y \verb|r4| contiene la dirección a partir de la que empieza otro array también de números reales de 64 bits. ¿Qué hace el programa? ¿Cuál es el tiempo mínimo que tardaría en ejecutarse?

    % // TODO: hacer
\end{ejercicio}



\newpage
