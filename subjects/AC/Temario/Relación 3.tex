\section{Arquitecturas TLP}

\begin{ejercicio}
    En un multiprocesador SMP con 4 procesadores o nodos (N0-N3) basado en un bus, que implementa el protocolo MESI para mantener la coherencia, supongamos una dirección de memoria incluida en un bloque que no se encuentra en ninguna caché. Indique los estados de este bloque en las cachés y las acciones que se producen en el sistema ante la siguiente secuencia de eventos para dicha dirección:
    \begin{enumerate}
        \item Lectura generada por el procesador 1.
        \item Lectura generada por el procesador 2.
        \item Escritura generada por el procesador 1.
        \item Escritura generada por el procesador 2.
        \item Escritura generada por el procesador 3.
    \end{enumerate}

    Al hablar el enunciado de un protocolo MESI en un SMP con un bus, entendemos que se refiere al protocolo MESI de espionaje. Durante el ejercicio, supongamos que el bloque en el que se encuentra la dirección de memoria mencionada es el bloque \verb|B|. A continuación, mostramos la Tabla~\ref{tab:ej_rel3_1}, que contiene cómo van cambiando los estados del bloque \verb|B| en cada caché en relación al tiempo (que medimos de forma relativa a los estados). Consideramos que el estado 0 es el inicial (cuando el bloque no se encuentra en ninguna caché). A continuación, desarrollamos en detalle los eventos que se producen y las acciones de los controladores, junto con los eventos que generan:\\

\begin{table}
\centering
\begin{tabular}{c|c|c|c|c}
    Evento & Caché 0 & Caché 1 & Caché 2 & Caché 3 \\
    \hline
    0 & I & I & I & I \\
    \hline
    1 & I & E & I & I \\
    \hline
    2 & I & C & C & I \\
    \hline
    3 & I & M & I & I \\
    \hline
    4 & I & I & M & I \\
    \hline
    5 & I & I & I & M \\
\end{tabular}
\caption{Estados del bloque B tras cada evento.}
\label{tab:ej_rel3_1}
\end{table}
Inicialmente, como ningún nodo contiene al bloque \verb|B|, este está en estado Inválido en todas las cachés. Explicamos ahora las acciones derivadas de cada evento:
\begin{enumerate}
    \item Tenemos el evento \verb|PrLec(B)| por parte del procesador 1, que provoca un fallo de caché al estar el bloque \verb|B| en estado Inválido en su caché. Como consecuencia, genera el paquete \verb|PtLec(B)|, que es enviado a través del bus.

        El resto de los controladores ignoran el paquete, al tener el bloque \verb|B| en estado Inválido en sus cachés. Es pues el controlador de la memoria principal quien contesta al paquete, a través de un paquete \verb|RpBloque(B)|.

        El controlador de caché del procesador 1 recibe el paquete, escribiéndo su contenido en la línea de caché correspondiente y cambiando el estado del bloque \verb|B| de Inválido a Exclusivo, ya que el controlador de caché sabe que dicho paquete no está en estado válido en ninguna otra caché.

    \item El procesador 2 genera el evento \verb|PrLec(B)|, que provoca un fallo en su caché, al estar el bloque \verb|B| en estado Inválido en su caché. Como consecuencia, genera el paquete \verb|PtLec(B)|, que es enviado a través del bus.

        Los controladores de caché de los procesadores 0 y 3 ignoran dicho paquete, al tener al bloque \verb|B| en estado Inválido. El controlador de caché del procesador 1 ve que el paquete es de lectura del mismo paquete \verb|B| que tiene en estado Exclusivo, luego cambia su estado a Compartido, al saber que otro nodo contendrá otra copia del bloque. Es el contorlador de la memoria principal quien contesta al paquete, a través de un paquete \verb|RpBloque(B)|.

        El controlador de caché del procesador 2 recibe el paquete, escribiéndo su contenido en la línea de caché correspondiente y cambiando el estado del bloque \verb|B| de Inválido a Compartido, ya que el controlador de caché sabe que dicho paquete está en estado válido en otra caché (depende de la implementación, pero puede saberlo por una línea OR que funcione a modo de chivato, relativa a si otras cachés tienen o no a \verb|B|).

    \item El procesador 1 genera el evento \verb|PrEsc(B)|. Al estar \verb|B| en estado Compartido en su caché (es un estado válido), no hay fallo de caché. Su controlador de caché genera el paquete \verb|PtEx(B)|, para solicitar acceso exclusivo al bloque (estamos en un protocolo con escritura con invalidación) para poder escribir en él. Posteriormente, cambia el estado de su bloque a Modificado y procede a escribir en él.

        Los controladores de caché de los procesadores 0 y 3 ignoran dicho paquete, al tener al bloque \verb|B| en estado Inválido. El controlador de caché del procesador 2 observa que tiene al bloque \verb|B| en estado Compartido y procede a invalidar su copia, pasando el bloque \verb|B| a estado Inválido.

    \item El procesador 2 genera el evento \verb|PrEsc(B)|. Al estar \verb|B| en estado Inválido en su caché, se produce un fallo de caché. Su controlador de caché genera el paquete \verb|PtLecEx(B)|, para solicitar la copia actualizada de \verb|B| y escribir en ella.

        Los controladores de caché de los procesadores 0 y 3 ignoran dicho paquete (tienen a \verb|B| en estado inválido). El controlador de caché del procesador 1 observa el paquete y tiene a \verb|B| en estado Modificado, luego contiene a la única copia de \verb|B| en estado válido en todo el sistema de memoria. Por tanto, genera el paquete \verb|RpBloque(B)| con el contenido de \verb|B| e invalida su copia (era un paquete de acceso exclusivo). Además, el controlador del procesador 1 invalida la respuesta de la memoria principal.

        El controlador de caché del procesador 2 recibe el paquete y escribe el contenido del bloque \verb|B| en la línea de caché correspondiente, cambiando su estado a Modificado.
    
    \item Se produce el mismo razonamiento que en el caso anterior, sustituyendo:
        \begin{itemize}
            \item 2 por 3.
            \item 1 por 2.
            \item 3 por 1.
        \end{itemize}
\end{enumerate}

\end{ejercicio}

\begin{ejercicio}
    Para un multiprocesador de memoria distribuida con $8$ nodos se quiere implementar un protocolo para mantenimiento de coherencia basado en directorios. Suponiendo que se necesitan un bit de estado para un bloque en el directorio de memoria principal y que el tamaño de una línea de caché es de 64 bytes, calcular el porcentaje del tamaño de memoria principal que supone el tamaño del directorio de vector de bits completo.\\

Supuesto que la memoria principal tiene $M$ bloques de memoria, el directorio será una tabla de $M$ entradas y 9 columnas, similar a la Tabla~\ref{tab:ej_rel3_2}.
\begin{table}[H]
\centering
\begin{tabular}{r|c|c|c|c|}
    & $C_0$ & $\ldots$ & $C_7$ & MP \\
    \cline{2-5}
    0 & Bit & $\ldots$ & Bit & Bit \\
    \cline{2-5}
    $\vdots$ & $\vdots$ & $\ddots$ & $\vdots$ & $\vdots$ \\
    \cline{2-5}
    $M-1$ & Bit & $\ldots$ & Bit & Bit \\
    \cline{2-5}
\end{tabular}
\caption{Directorio de memoria.}
\label{tab:ej_rel3_2}
\end{table}

Notemos que nos es suficiente con calcular el porcentaje del tamaño de cada bloque que supone almacenar una fila (9 bits) de la tabla. Como las líneas de caché son de 64 bytes $= 68\cdot 8 = 512$ bits, calculamos dicha fracción:
\begin{equation*}
    \dfrac{9}{512} = 0.017578 \approx 1.76\%
\end{equation*}
\begin{itemize}
    \item Si nuestra memoria principal sólo contiene un bloque, sólo tenemos una entrada en la tabla y por tanto sólo se ocupan 9 bits, con lo que ocupa un $1.76\%$ del tamaño total de memoria principal.
    \item Si ahora nuestra memoria principal tiene $M$ bloques, pasamos de gastar 9 bits de la tabla a gastar $9M$ bits. Asímismo, pasamos a tener una memoria de tamaño $512M$ bits, de donde calculamos el porcentaje que supone almacenar el directorio:
        \begin{equation*}
            \dfrac{9\cancel{M}}{512\cancel{M}} = 0.017578 \approx 1.76\%
        \end{equation*}
\end{itemize}

\end{ejercicio}

\begin{ejercicio}
    Suponga que en un CC-NUMA de red estática de 4 nodos (N0-N3) se implementa un protocolo MSI basado en directorios sin difusión con dos estados en el directorio (válido e inválido). Cada nodo tiene 8 GBytes de memoria y una línea de caché supone 64 Bytes. Considere que el directorio utiliza vector de bits completo.
    \begin{enumerate}
        \item Calcule el tamaño del directorio de un nodo en bytes.
        \item Indique cual sería el contenido del directorio, las transiciones de estados (en caché y en el directorio) y la secuencia de paquetes generados por el protocolo de coherencia en los siguientes accesos sobre una dirección D que se encuentra en la memoria del nodo 3 (inicialmente D no está en ninguna caché):
        \begin{enumerate}
            \item Lectura generada por el procesador del nodo 1.
            \item Escritura generada por el procesador del nodo 1.
            \item Lectura generada por el procesador del nodo 2.
            \item Lectura generada por el procesador del nodo 3.
            \item Escritura generada por el procesador del nodo 0.
        \end{enumerate}
    \end{enumerate}

\begin{enumerate}
    \item El tamaño de un bloque de memoria principal coincide con el tamaño de la línea de caché, de $64 = 2^6$ Bytes. Cada nodo tiene 8 GBytes de memoria, luego dispondrá de:
        \begin{equation*}
            \dfrac{8 \text{\ GBytes}}{64 \text{\ Bytes}} = \dfrac{2^3\cdot 2^{30} \text{\ Bytes}}{2^6 \text{\ Bytes}} = 2^{27} \text{\ Bloques}
        \end{equation*}
        Por tanto, el directorio de memoria de cada nodo tendrá $2^{27}$ entradas, cada una con 5 columnas (cada una con un bit). Cada direcorio de memoria ocupará por tanto:
        \begin{equation*}
            2^{27}\cdot 5 \text{\ Bytes} = 5\cdot 2^7\cdot 2^{20} \text{\ Bytes} = 5\cdot 128 \text{\ MBytes} = 640 \text{\ MBytes}
        \end{equation*}
        Que son:
        \begin{equation*}
            2^{27}\cdot 5 \text{\ Bytes} = 671088640 \text{\ Bytes} \approx 6.71\cdot 10^8 \text{\ Bytes}
        \end{equation*}
        En total, los 4 subdirectorios de memoria ocuparán:
        \begin{align*}
            4\cdot 640 \text{\ MBytes} &= 2560 \text{\ MBytes} \\
            4\cdot 6.71\cdot 10^8 &= 2.68\cdot 10^9 \text{\ Bytes}
        \end{align*}

    \item En las Tablas~\ref{tab:ej_rel3_3} y~\ref{tab:ej_rel3_3_2} indicamos la secuencia de estados de la línea del directorio del nodo 3 correspondiente al bloque \verb|B| de la dirección D, así como el estado del bloque \verb|B| en cada una de las cachés.

\begin{table}[H]
\centering
\begin{tabular}{r|c|c|c|c|c|}
    & $C_0$ & $C_1$ & $C_2$ & $C_3$ & MP \\
    \cline{2-6}
    0 & 0 & 0 & 0 & 0 & 1 \\
    \cline{2-6}
    a & 0 & 1 & 0 & 0 & 1 \\
    \cline{2-6}
    b & 0 & 1 & 0 & 0 & 0 \\
    \cline{2-6}
    c & 0 & 1 & 1 & 0 & 1 \\
    \cline{2-6}
    d & 0 & 1 & 1 & 1 & 1 \\
    \cline{2-6}
    e & 1 & 0 & 0 & 0 & 0 \\
    \cline{2-6}
\end{tabular}
\caption{Estado de la línea de B del directorio de memoria del nodo 3.}
\label{tab:ej_rel3_3}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
    Evento & Caché 0 & Caché 1 & Caché 2 & Caché 3 \\
    \hline
    0 & I & I & I & I \\
    \hline
    a & I & C & I & I \\
    \hline
    b & I & M & I & I \\
    \hline
    c & I & C & C & I \\
    \hline
    d & I & C & C & C \\
    \hline
    e & M & I & I & I \\
\end{tabular}
\caption{Estados del bloque B tras cada evento.}
\label{tab:ej_rel3_3_2}
\end{table}
Inicialmente, como D no está en ninguna caché, su bloque \verb|B| tampoco, luego inicializamos todos los estados de \verb|B| en las cachés a Inválido y un 0 en el directorio de memoria, siendo la copia de la memoria principal válida (ya que si no \verb|B| no está en el sistema de memoria).

    \begin{enumerate}
        \item El procesador 1 realiza \verb|PrLec(B)| y al estar \verb|B| en estado Inválido en su caché, su controlador genera el paquete \verb|PtLec(B)|, que envía al nodo 3, al ser el nodo origen de \verb|B|. Su controlador de caché observa que no tiene en su caché a \verb|B| en un estado válido (gracias al directorio), y que se encuentra válido en memoria principal. No realiza ninguna acción, dejando que la memoria (como tiene a \verb|B| en estado válido), responda con el paquete \verb|RpBloque(B)|. 

        El controlador del nodo 3 apunta en el directorio que ahora el nodo 1 tiene una copia válida del bloque \verb|B|.

        El procesador 1 recibe el paquete de respuesta, copiando el bloque \verb|B| en la correspondiente línea de caché y cambiando su estado a Compartido.

        \item El procesador 1 realiza \verb|PrEsc(B)| y al estar \verb|B| en estado Compartido en su caché, su controlador genera el paquete \verb|PtEx(B)|, que envía al nodo 3, al ser el nodo origen de \verb|B|. Su controlador de caché observa que es la única caché con copia de \verb|B|, por lo que sólo invalida la copia de \verb|B| en memoria principal y deuelve al nodo 1 el paquete \verb|RpInv(B)|, para que sepa que todas las copias de \verb|B| fueron invalidadas.

            Una vez recibido el paquete, el controlador de caché del nodo 1 cambia el estado de \verb|B| a Modificado y el procesador es libre de escribir en el bloque.

        \item El procesador 2 realiza \verb|PrLec(B)| y al estar \verb|B| en estado Inválido en su caché, su controlador genera el paquete \verb|PtLec(B)|, que envía al nodo 3, al ser el nodo origen de \verb|B|. Su controlador de caché observa que el nodo 1 es el único que contiene una copia válida de \verb|B| en todo el sistema, por lo que genera el paquete \verb|RvLec(B)|, que envía al nodo 1.

            El controlador de caché del nodo 1 recibe el paquete, con lo que cambia el estado de \verb|B| a Compartido, y genera el paquete de respuesta \verb|RpBloque(B)| al nodo 3.

            El controlador de caché del nodo 3 copia el contenido del paquete en memoria principal, cambiando su bit de validez a 1 y reenviando el paquete de respuesta al nodo solicitante 2.

            El controlador de caché del nodo 2 recibe el paquete, copiando el contenido de \verb|B| en la línea de caché correspondiente y cambiando su estado a Compartido.
        
        \item El procesador del nodo 3 realiza \verb|PrLec(B)| y al estar \verb|B| en estado Inválido, se produce un fallo de caché. Él mismo es el origen del bloque, luego consulta su directorio y observa que tanto los nodos 1 y 2 como la memoria principal lo tienen en estado válido.

            Dependiendo de la implementación:
            \begin{itemize}
                \item O copia a la caché el contenido del bloque desde la memoria.
                \item O genera un paquete \verb|RvLec(B)| al nodo 1 o 2, para que le devuelva el bloque \verb|B| a través de un paquete \verb|RpBloque(B)|.
            \end{itemize}
            EL controlador de caché del nodo 3 apunta en el directorio que ahora dispone de una copia válida de \verb|B|.

            Copia el contenido del bloque \verb|B| en la línea de caché correspondiente, cambiando su estado a Compartido.
        
        \item El procesador del nodo 0 realiza \verb|PrEsc(B)| y al estar \verb|B| en estado Inválido, se produce un fallo de caché. Genera un paquete \verb|PtLecEx(B)|, para obtener \verb|B| con acceso exclusivo, que envía al nodo 3 por ser el origen del bloque. El controlador del nodo 3 recibe el paquete de petición y:
            \begin{itemize}
                \item Primero, envía el paquete \verb|RvInv(B)| a los nodos 1 y 2 para que invaliden sus copias de \verb|B|, mientras que el controlador invalida las copias de memoria principal y de su propia caché.
                \item Por haber estado \verb|B| Compartido en el nodo 3, una vez que se reciban los paquetes \verb|RpInv(B)| desde los nodos 1 y 2, el controlador del nodo 3 generará el paquete \verb|RpBloqueInv(B)|, que enviará al nodo 0.
            \end{itemize}

            El controlador de caché del nodo 0 copiará el contenido de \verb|B| en la línea de caché correspondiente, cambiando su estado a Modificado.
    \end{enumerate}

\end{enumerate}

\end{ejercicio}

\begin{ejercicio}
    Supongamos que se va a ejecutar en paralelo el siguiente código, donde \verb|x| e \verb|y| son variables compartidas (inicialmente \verb|x=y=0|):
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.3\textwidth}
            \begin{minted}[frame=lines,
                framesep=2mm,
                baselinestretch=1.2,
                linenos,
                escapeinside=||]{cpp}
x=1;
x=2;
print y;
            \end{minted}
            \caption{P1.}
        \end{subfigure}\hspace{3cm}
        \begin{subfigure}{0.3\textwidth}
            \begin{minted}[frame=lines,
                framesep=2mm,
                baselinestretch=1.2,
                linenos,
                escapeinside=||]{cpp}
y=1;
y=2;
print x;
            \end{minted}
            \caption{P2.}            
        \end{subfigure}
    \end{figure}

    ¿Qué resultados se pueden imprimir si (considere que el compilador no altera el código):
    \begin{enumerate}
        \item Se ejecutan P1 y P2 en un multiprocesador con consistencia secuencial.
        \item Se ejecutan en un multiprocesador basado en un bus que garantiza todos los órdenes excepto el orden \verb|W|$\to$\verb|R|. Esto es debido a que los procesadores tienen buffer de escritura, permitiendo el procesador que las lecturas en el código que ejecuta adelanten a las escrituras que tiene su buffer.  Obsérvese que hay varios resultados posibles.
    \end{enumerate}

    \begin{enumerate}
        \item Al no haber ningún código de sincronización entre los dos programas, el comportamiento del mismo está indeterminado, por lo que tenemos que distinguir casos. Mostramos todas las trazas de ejecución posibles:
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
x=2;
print y; // Imprime 0
y=1;
y=2;
print x; // Imprime 2
        \end{minted}
        \caption{Opción 1.}
    \end{subfigure}\hspace{3cm}
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
x=2;
y=1;
print y; // Imprime 1
y=2;
print x; // Imprime 2
        \end{minted}
        \caption{Opción 2.}            
    \end{subfigure}
    \\
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
x=2;
y=1;
y=2;
print y; // Imprime 2
print x; // Imprime 2
        \end{minted}
        \caption{Opción 3.}
    \end{subfigure}\hspace{3cm}
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
x=2;
y=1;
y=2;
print x; // Imprime 2
print y; // Imprime 2
        \end{minted}
        \caption{Opción 4.}            
    \end{subfigure}
    \\
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
y=1;
x=2;
y=2;
print x; // Imprime 2
print y; // Imprime 2
        \end{minted}
        \caption{Opción 5.}
    \end{subfigure}\hspace{3cm}
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
y=1;
y=2;
x=2;
print x; // Imprime 2
print y; // Imprime 2
        \end{minted}
        \caption{Opción 6.}            
    \end{subfigure}
    \\
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
x=1;
y=1;
y=2;
print x; // Imprime 1
x=2;
print y; // Imprime 2
        \end{minted}
        \caption{Opción 7.}
    \end{subfigure}\hspace{3cm}
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
y=1;
x=1;
y=2;
print x; // Imprime 1
x=2;
print y; // Imprime 2
        \end{minted}
        \caption{Opción 8.}            
    \end{subfigure}
    \\
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
y=1;
y=2;
x=1;
print x; // Imprime 1
x=2;
print y; // Imprime 2
        \end{minted}
        \caption{Opción 9.}
    \end{subfigure}\hspace{3cm}
    \begin{subfigure}{0.3\textwidth}
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
y=1;
y=2;
print x; // Imprime 0
x=1;
x=2;
print y; // Imprime 2
        \end{minted}
        \caption{Opción 10.}            
    \end{subfigure}
\end{figure}
En resumen, las salidas del programa podrán ser: $\{0 2, 1 2, 2 2\}$.

        \item Si ahora consideramos que las lecturas pueden adelantar a las escrituras, entonces la instrucción \verb|print var| puede adelantar a las escrituras anteriores (ya que consiste en una lectura), por lo que ahora sí que podemos obtener como salida cualquier combinación de 0, 1 y 2:
            \begin{equation*}
                \{0 0, 0 1, 0 2, 1 0, 1 1, 1 2, 2 0, 2 1, 2 2\}
            \end{equation*}
    \end{enumerate}

\end{ejercicio}


\begin{ejercicio}
    Supongamos que se va a ejecutar en paralelo el siguiente código (inicialmente \verb|x=y=0|):
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.3\textwidth}
            \begin{minted}[frame=lines,
                framesep=2mm,
                baselinestretch=1.2,
                linenos,
                escapeinside=||]{cpp}
x=30;
y=40;
flag=1;
            \end{minted}
            \caption{P1.}
        \end{subfigure}\hspace{3cm}
        \begin{subfigure}{0.3\textwidth}
            \begin{minted}[frame=lines,
                framesep=2mm,
                baselinestretch=1.2,
                linenos,
                escapeinside=||]{cpp}
while (flag==0) {};
r1=x;
r2=y;
            \end{minted}
            \caption{P2.}            
        \end{subfigure}
    \end{figure}

    ¿Qué datos puede obtener P2 en los registros \verb|r1| y \verb|r2| si (considere que el compilador no altera el código):
    \begin{enumerate}
        \item Se ejecutan P1 y P2 en un multiprocesador con consistencia secuencial.
        \item Se ejecutan en un multiprocesador con un modelo de consistencia que relaja todos los órdenes en los accesos a memoria. Razone su respuesta.
    \end{enumerate}

Aunque no lo dice el enunciado, suponemos que inicialmente \verb|flag=0|.
\begin{enumerate}
    \item Si se cumple la consistencia secuencial, no se producirán adelantamientos, por lo que lo primero que se ejecutará en el procesador 2 será la línea 1, que entrará en bucle hasta que no se ejecute la línea 3 del procesador 1, liberando al bucle (una vez ya modificadas las variables \verb|x| e \verb|y|) y copiando en los registros su contenido.

        De esta forma, en cualquier ejecución obtendremos \verb|r1=30| y \verb|r2=40|.

    \item En este caso, podemos obtener cualquiera de los siguientes resultados:
        \begin{equation*}
            \verb|r1=0|, \verb|r2=0| \qquad \verb|r1=30|, \verb|r2=0| \qquad \verb|r1=0|, \verb|r2=40| \qquad \verb|r1=30|, \verb|r2=40|
        \end{equation*}
        \begin{enumerate}
            \item La instrucción \verb|flag=1| puede adelantar a \verb|x=30| y \verb|y=40|.
            \item La instrucción \verb|flag=1| puede adelantar a \verb|y=40|.
            \item Tanto \verb|y=40| como \verb|flag=1| adelantan a \verb|x=30|.
            \item Si no se produce ningún adelantamiento (o se produce uno que no altera el resultado, como que \verb|y=40| adelante a \verb|x=30|).
        \end{enumerate}
        Sólo hemos considerado un subconjunto pequeño de posibilidades, pero se pueden dar muchas más (sólo hemos comentado algunos adelantamientos en P1, pero en P2 también pueden producirse de muchas formas). En definitiva, puede suceder cualquier cosa.
\end{enumerate}

\end{ejercicio}

\begin{ejercicio}
    Se quiere implementar un cerrojo simple en un multiprocesador SMP basado en procesadores de
    la línea x86 de Intel, en particular, procesadores Intel Core. 
    \begin{enumerate}
        \item Teniendo en cuenta el modelo de consistencia de memoria que ofrece el hardware de este multiprocesador ¿podríamos implementar la función de liberación del cerrojo simple usando \verb|mov k, 0|, siendo \verb|k| la variable cerrojo? Razone su respuesta.
        \item ¿Cómo se debería implementar la función de liberación de un cerrojo simple si se usan procesadores con la arquitectura ARMv7? Razone su respuesta.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Se ha ejecutado el siguiente código en un multiprocesador con un modelo de consistencia que no garantiza ni \verb|W|$\to$\verb|R| ni \verb|W|$\to$\verb|W| (garantiza el resto de órdenes):
    \begin{figure}[H]
        \centering
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
sump = 0;
for (i=ithread ; i<8 ; i=i+nthread) {
    sump = sump + a[i];
}
while (Fetch_&_Or(k,1)==1) {};
sum = sum + sump;
k=0;
        \end{minted}
    \end{figure}
    Conteste a las siguientes preguntas (considere que el compilador no altera el código):
    \begin{enumerate}
        \item Indique qué se puede obtener en \verb|sum| si se suma la lista \verb|a={1,2,3,4,5,6,7,8}|. \verb|k| y \verb|sum| son variables
        compartidas que están inicialmente a 0 (el resto de variables son privadas), \verb|nthread = 3|, \verb|ithread| es el
        identificador del thread en el grupo (0,1,2). Si hay varios posibles resultados, se tienen que dar todos
        ellos. Justifique su respuesta.
        \item ¿Qué resultados se pueden obtener si lo único que no garantiza el modelo de consistencia es el orden
        \verb|W|$\to$\verb|R|? Justifique su respuesta.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    ¿Qué ocurre si en el segundo código para implementar barreras visto en clase eliminamos la
    variable local, \verb|cont_local|, sustituyéndola en los puntos del código donde aparece por el contador
    compartido asociado a la barrera \verb|bar[id].cont|?
\end{ejercicio}

\begin{ejercicio}
    Suponiendo que la arquitectura dispone de instrucciones \verb|Fetch&Add|, simplifique el segundo
    código para barreras visto en clase.
\end{ejercicio}

\begin{ejercicio}
    Se quiere paralelizar el siguiente ciclo de forma que la asignación de iteraciones a los
    procesadores disponibles se realice en tiempo de ejecución (dinámicamente):
    \begin{figure}[H]
        \centering
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
for (i=0; i<100; i++) {
    // Código que usa i
}
        \end{minted}
    \end{figure}
    \begin{observacion}
        Considerar que las iteraciones del ciclo son independientes, que el único orden no garantizado por el
        sistema de memoria es \verb|W|$\to$\verb|R|, que las primitivas atómicas garantizan que sus accesos a memoria se realizan
        antes que los accesos posteriores y que el compilador no altera el código.
    \end{observacion}
    \begin{enumerate}
        \item Paralelizar el ciclo para su ejecución en un multiprocesador que implementa la primitiva \verb|Fetch&Or|
        para garantizar exclusión mutua.
        \item Paralelizar el anterior ciclo en un multiprocesador que además tiene la primitiva \verb|Fetch&Add|.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Un programador está usando el siguiente código para barreras (\verb|bar| es un vector compartido, \verb|k|
    es una variable compartida, el resto son variables locales, \verb|Fetch_&_Or(k,1)| realiza sus accesos a memoria
    antes de que puedan realizarse los accesos posteriores):
    \begin{figure}[H]
        \centering
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
Barrera(id, num_procesos)
{
    band_local= !(band_local)
    while (Fetch_&_Or(k,1)==1) {};
    cont_local = ++bar[id].cont;
    k=0;
    if (cont_local == num_procesos) {
        bar[id].cont=0;
        bar[id].band=band_local;
    }
    else while (bar[id].band != band_local) {};
}
        \end{minted}
    \end{figure}
    Conteste a las siguientes cuestiones (considere que el compilador no altera el código):
    \begin{enumerate}
        \item ¿Funciona bien este código como barrera en un multiprocesador en el que lo único que no garantiza su
        modelo de consistencia es el orden \verb|W|$\to$\verb|R|? Razone por qué.
        \item Funciona bien este código como barrera en un multiprocesador con modelo de consistencia que no
        garantice ningún orden en los accesos a memoria? Razone por qué.
    \end{enumerate}
\end{ejercicio}


\begin{ejercicio}
    Se quiere implementar un programa que calcule en paralelo la siguiente expresión en un
    multiprocesador en el que sólo se relaja el orden \verb|W|$\to$\verb|R| y en el que sólo se dispone de primitiva de
    sincronización \verb|test_&_set|:
    \[
        d = \frac{1}{N} \sum_{i=1}^{N} x_i^2 - \ol{x}^2, \quad \ol{x} = \frac{1}{N} \sum_{i=1}^{N} x_i
    \]
    Un programador ha implementado el código de abajo. Tenga en cuenta lo siguiente:
    \begin{itemize}
        \item El código lo ejecutan \verb|nthread| threads en paralelo.
        \item \verb|ithread| es una variable local que nota el identificador del thread.
        \item \verb|i|, \verb|medl| y \verb|varil| son variables locales.
        \item \verb|i|, \verb|med|, \verb|vari|, el vector \verb|x| y \verb|N| son variables compartidas.
        \item Inicialmente \verb|med|, \verb|vari|, \verb|medl| y \verb|varil| son 0.
    \end{itemize}
    \begin{figure}[H]
        \centering
        \begin{minted}[frame=lines,
            framesep=2mm,
            baselinestretch=1.2,
            linenos,
            escapeinside=||]{cpp}
for (i=ithread;i<N;i=i+nthread) {
    medl=medl+x[i];
    varil=varil+x[i]*x[i];
}
med = med + medl/N; vari = vari + varil/N;
vari= vari - med*med;
if (ithread==0) printf("varianza = %f", vari); //imprime en pantalla
        \end{minted}
    \end{figure}
    Conteste a las siguientes cuestiones (considere que el compilador no altera el código):
    \begin{enumerate}
        \item Se ha ejecutado este código usando varios threads y se ha visto que, aunque \verb|N| y el vector \verb|x| no
        varían, no siempre se imprime lo mismo. ¿Por qué ocurre esto?
        \item Añada lo mínimo necesario para solucionar el problema teniendo en cuenta que sólo se dispone
        para implementar sincronización de \verb|test_&_set| (tampoco se dispone de primitivas software de
        sincronización). Indique qué variables son ahora compartidas y cuáles locales.
        \item Escriba el programa suponiendo que el multiprocesador además tiene primitivas de sincronización
        \verb|fetch_&_add| (se tendrá en cuenta las prestaciones). Indique qué variables son compartidas y
        cuáles locales.
        \item Escriba el programa ahora suponiendo que el multiprocesador sólo tiene primitivas de
        sincronización \verb|compare_&_swap| (se tendrá en cuenta las prestaciones). Indique qué variables son
        compartidas y cuáles locales.
    \end{enumerate}
    \begin{observacion}
        En todos los apartados puede añadir o quitar variables si lo estima conveniente.
    \end{observacion}
\end{ejercicio}

\begin{ejercicio}
    Se ha extraído la siguiente implementación de cerrojo (\textit{spin-lock}) para x86 del kernel de Linux, el cual se muestra
    en el Código Fuente~\ref{code:spinlock}.
    \lstinputlisting[
        language=C,
        style=vscode_C,
        caption={Código de un cerrojo en el kernel de Linux.},
        label={code:spinlock}
    ]{Relacion3_Ejercicio13.c}

    Conteste a las siguientes preguntas:
    \begin{enumerate}
        \item Utiliza una implementación de cerrojo con etiquetas ¿Cuál es el contador de adquisición y cuál es el
        contador de liberación?
        \item Describa qué hace \verb|xaddw %w0, %1| ¿opera con el contador de adquisición, con el de liberación o con
        los dos? ¿qué operaciones hace con ellos?
        \item Describa qué hace \verb|cmpb %h0, %b0| ¿opera con el contador de adquisición, con el de liberación o con
        los dos? ¿qué operaciones hace con ellos?
        \item ¿Por qué cree que se usa el prefijo \verb|lock| delante de la instrucción \verb|xaddw|? 
    \end{enumerate}

    \begin{observacion} Es recomendable consultar recursos siguientes:
        \begin{itemize}
            \item Puede consultar las instrucciones en el manual de Intel con el repertorio de instrucciones
            (Volumen 2 o volúmenes 2A, 2B y 2C) que puede encontrar \href{http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html}{\color{blue}\ul{aquí}}.
            \item Si no recuerda la interfaz entre C/C++ y ensamblador en \verb|gcc| (se ha presentado en Estructura de
            Computadores), consulte el manual de \verb|gcc| \href{http://gcc.gnu.org/onlinedocs/gcc-4.6.2/gcc/ExtendedAsm.html#Extended-Asm}{\color{blue}\ul{aquí}}.
        \end{itemize}
    \end{observacion}
\end{ejercicio}


\subsection{Cuestiones}

\begin{cuestion}
    Diferencias entre núcleos con multithread temporal y núcleos con multithread simultánea.\\

    La diferencia fundamental es que los hilos que se ejecutan en núcleos con multithread temporal (TMT) no se ejecutan de forma paralela, sino que multiplexan el núcleo, teniendo que disponer de un sistema hardware que realice la conmutación entre ellos. Por otra parte, en los núcleos de multithread simultáneo (SMT), el núcleo no se multiplexa, por lo que no es necesaria realizar la conmutación de hilos. Esto provoca que los TMT sólo sean capaces de emitir resultados de un sólo hilo (o flujo de instrucciones) por iteración, mientras que los SMT son capaces de emitir resultados de distintos hilos por ciclo.
\end{cuestion}

\begin{cuestion}
    Diferencias entre núcleos con multithread temporal de grano fino y núcleos con multithread temporal de grano grueso.\\

    La conmutación de hilos en los núcleos con multithread temporal de grano fino (FGMT) se realiza en cada ciclo, por lo que son cambios de contexto con bajo coste, que no implica pérdidas de ciclos para realizar los cambios de contexto. Por otra parte, la conmutación de hilos en los núcleos con multithread temporal de grano grueso (CGMT) presenta un mayor coste de cambio de contexto, que puede derivar en la pérdida de ciclos para realizar dicho cambio, introduciendo pérdidas verticales.
    
    Además, si el CGMT realiza una conmutación dinámica, se introduce un coste mayor a la hora de realizar los cambios de contexto.
\end{cuestion}

\begin{cuestion}
    Suponga un multiprocesador con protocolo MESI de espionaje. Si un controlador de cache observa en el bus un paquete de petición de lectura exclusiva de un bloque que tiene en estado C, debe (indique cuál sería la respuesta correcta y razone por qué es la respuesta correcta):
    \begin{enumerate}
        \item Generar un paquete de respuesta con el bloque y pasar el bloque a estado I.
        \item Pasar el bloque a estado I.
        \item Generar un paquete de respuesta con el bloque y pasar el bloque a estado E.
        \item No tiene que hacer nada.
    \end{enumerate}

    La respuesta correcta es la opción 2: Si la caché especificada tiene el bloque en estado C (Compartido), entonces se encuentra válido el bloque en memoria principal y en otras cachés (en al menos una más). En este caso, debe ser el controlador de la memoria principal quien genera el paquete con el bloque de respuesta (ya que en otro caso todos los controladores generarían el paquete, saturando la red de comunicación). Por tanto, la única acción que realiza el controlador es invalidar su copia del bloque, ya que se solicitó acceso exclusivo al bloque para su modificaicón.
\end{cuestion}

\begin{cuestion}
    Suponga un multiprocesador con protocolo MESI de espionaje. Si un nodo observa en el bus un paquete de petición de lectura exclusiva de un bloque que tiene en estado M, ¿qué debe hacer? Razone su respuesta.\\

Por tener dicho bloque en estado M (Modificado), entonces dicha caché es la única en todo el sistema de memoria que tiene dicho bloque actualizado. Por solicitar una lectura \textbf{exclusiva}, debe primero invalidar la copia del bloque en su caché. Posteriormente (al ser la única copia válida en el sistema), debe responder con el contenido del bloque, generando un paquete \verb|RpBloque|. Además: si la memoria no tiene constancia de que su contenido del bloque está desactualizado (está en estado inválido), la memoria tratará de responder también a la caché solicitante del bloque. En dicho caso, el controlador de caché deberá a su vez invalidar la respuesta de la memoria.
\end{cuestion}

\begin{cuestion}
    Suponga un multiprocesador con el protocolo MESI de espionaje. Si el procesador de un nodo escribe en un bloque que tiene en su cache en estado I, debe (indique cuál sería la respuesta correcta y razone por qué es la respuesta correcta):
    \begin{enumerate}
        \item Generar paquete de petición de acceso E al bloque y pasar el bloque a M.
        \item Generar paquete de petición de acceso E y pasar el bloque a estado E.
        \item Generar paquete de petición de acceso E con lectura y pasar el bloque a estado E.
        \item Generar paquete de petición de acceso E al bloque con lectura y pasar el bloque a M.
    \end{enumerate}

    La opción correcta es la 4: Debe generar un paquete de petición de acceso exclusivo con lectura ya que tiene el bloque en estado I (Inválido), luego no dispone de una copia actualizada del mismo (por lo que tiene que solicitar la lectura del mismo). El acceso es exclusivo ya que se dispone a escribir en el bloque, luego debe invalidar el resto de copias del bloque en el resto de las cachés (al usar MESI la escritura con invalidación). FInalmente, pasará el bloque a estado Modificado ya que escribirá en él, por lo que será (una vez finalizada la escritura) la única copia del bloque válida en todo el sistema de memoria.
\end{cuestion}

\begin{cuestion}
    ¿Cuál de los siguientes modelos de consistencia permite mejores tiempos de ejecución?
    Justifique su respuesta.
    \begin{enumerate}
        \item Modelo de consistencia que no garantiza los órdenes \verb|W|$\to$\verb|W| y \verb|W|$\to$\verb|R|.
        \item Modelo implementado en los procesadores de la línea x86.
        \item Modelo de consistencia secuencial.
        \item Modelo de consistencia que no garantiza ningún orden.
    \end{enumerate}
\end{cuestion}

\begin{cuestion}
    Indique qué expresión no se corresponde con la serie (justifique su respuesta):
    \begin{enumerate}
        \item \verb|Lock|.
        \item \verb|Fetch_and_Or|.
        \item \verb|Compare_and_Swap|.
        \item \verb|Test_and_Set|.
    \end{enumerate}
    La expresión que no corresponde es \verb|Lock|, por ser el código de adquisición de un cerrojo, mientras que el resto de las expresiones son primitivas de las que dispone el hardware para implementar códigos para sincronización de forma eficiente.
\end{cuestion}
