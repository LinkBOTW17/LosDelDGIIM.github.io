atomic es mas rapido k critical xq critical implementa cerrojos y atomic una instruccion maquina particular, del estilo *lock addl*.

### Tema 4 ###
# La diferencia entre ILP y VLIW 
## Diferencias
% Las dos implementaciones están segmentadas (tienen un cauce).
% - Las instrucciones se captan en el orden del programa --> buffer de instrucciones y se decodifican en orden del programa.
% - UNa vez decodificada se sabe qué se va a usar y en ISS se emite a ejecución.
% 
% ## Comentarios en el flujo de ejecucion de instrucciones
% La emision a ejecucion puede ser en orden del programa o desordenada, con el fin de ahorrar tiempo de ejecución.
% Ya sea ordenada o no, como las unidades pueden suponer distinto tiempo, la finalización de las instrucciones también va a ser desordenada (una puede emitirse antes y terminar después que una que se emite después y termina antes).
% 
% En los superescalares, la última etapa procesa las instrucciones de forma ordenada (en orden del programa), aunque la ejecución sea en forma desordenada.
% Esta última etapa es la que modifica los registros de la arquitectura. Con esto se garantiza la consistencia del procesador, de forma que el resultado coincide con el que se obtendría de forma ordenada. Está claro que la ejecución va a ser de forma desordenada. Sin embargo, obtenemos un resultado como si se obtendria en el orden del programa.

% En la realidad, cada etapa está compuesta por distintas subetapas. Puede llegar a haber 10, 14, \ldots etapas en el cauce.

% ## Modificaciones instroducidas en las arquitecturas para reducir tiempos de ejecución
% - Segmentación (esto es repaso). Mejora el tiempo de CPU porque reduce el tiempo de ciclo, reduciéndolo entre el N de etapas si todas las etapas duran lo mismo.

% Sin embargo, en los códigos hay dependencias (de datos o control) que dan lugar a problemas en un cauce segmentado, que pueden llevar a un resultado incorrecto de la ejecución (distinto al que se obtendría si no estuviera segmentado).

% Problemas (llamados hazards, riesgos): Hay riesgos entre dos instrucciones que tienen dependencias. Además, hay riesgos en saltos (de control), ya que la siguiente instruccion despues de un salto no es la que hay despues en el código. Gran problema con saltos condicionales.

% ### Como prevenir riesgos 
% En VLIW el compilador debe añadir instrucciones de no operacion (nop), para eliminar riesgos; tanto de datos como de control. Peores prestaciones, pasamos de un CPI ideal (1) a uno mayor (como 3 ciclos por instruccion).
% Un superescalar VLIW (uno real): Vamos a trabajar en cada una de las etapas con varias instrucciones a la vez (tantas como replicado). Tenemos un CPI ideal (0.5, dos resultados por ciclo). Al añadir instrucciones nop, hace el CPI muy malo (de 2.75). Sin considerar dependencias estructurales (que puede empeorar las cosas, si dos instrucciones necesitan acceder en el mismo tiempo a la misma unidad que no se encuentra replicada). Peor es el rendiminto.

% Para reducir la penalización el compialdor debe encargarse.

% En ILP el hardware se encarga de eliminar los riesgos y reducir el tiempo de penalización que suponen las dependencias. Puede llegar a el 0.5 ideal que teniamos antes.

% # Cómo se hace
% 1. Ver los diagramas.
% 2. Ver cómo se implementan los bloquecitos (almacenamiento, algoritmos, \ldots) para eliminar riesgos de datos, control y estructurales; reduciendo tiempos.

% Vamos a ver un diseño sencillo.

% ## Vistazo a diagrama de Microarquitectura.
% ### Diagrama de bloques (ejemplo del ARM a76, con ARMv8).
% La emisión forma parte de la codificación. Con la emision se emiten las instrucciones a ejecutar a las unidades funcionales. 
% Hay almacenamientos intermedios (llamados estaciones de reserva), anteriormente se presentaron como buffers intermedios.

% Dudas posibles: IMPORTANTE
% - En los 86 pasa siempre (al ser CISC) y en ARM (es RISC): Puede suceder que uns instrucción esté implementada con varias microinstrucciones (que son las que entiende el núcleo). Por eso hay veces que pasa de 4 flechas a 8.
% - En la emisión hay dos partes: una (Intel llama emisión a (estación de reserva) ventana de instrucciones) y luego usa envio cuando se refiere a paso de instrucciones desde estacion de reserva a unidad. En manuales de ARM y PowerPC se usa al revés (envío a estaciones de reserva y luego emisión a unidad funcional).

% IMPORTANTE 
% IMPORTANTE 
% - Que ver con carga y almacenamiento: Se implementa en la ejecución el adelantamiento (también que una escritura propia sea adelantada en cuanto a orden general) (lo pueden hacer todos los núcleos): LSU, una parte donde pone las cargas y otra con almacenamientos. Lo que va delante AGU (generacion de address) genera las direcciones para acceder a memoria. Puede calcular la direccion en cualqueir AGU, pero si es de carga se va a otra y si es de lectura se va a otra. En estas listas una lectura puede coger el contenido de una escritura, viéndola antes que el resto (ya que todavia no se ha llevado a caché, ningun otro nucleo se entera al realizarse de forma interna).
% 
% Si es la misma direccion: el cerebro de la LSU mira la direccion de las lecturas que entran y comprueba si hay alguna escritura que escribe en la dirección. Cuando se mete un LOAD se coje la direccion (ya calculada en el AGU) y se mira en todas las tablas a ver si hay escrituras en dicha direccion y la última que haya coge su contenido.
% Si se gestiona como una FIFO, se garantizan W->W y R->R (no se realizan dichos adelantamientos). Así es en Intel. En ARM no (implementacion mas compleja).
% - Las dos colas del LSU van a su ritmo (cada una al suyo). 
% 
% ### Esquema de ARM cortex A72
% IMPORTANTE
% IMPORTANTE
% VER DIAPOSITIVA 12, leer qué hace cada etapa.
% En la etapa de captacion está la predicción de saltos y la tabla de saltos (se verá después).
% En emision se usa la (ventana de instrucciones) estaciones de reserva. Buffer de renombrado (eliminar WAW y WAR), buffer de reorden.
% Buffer renombrado y de reorden (ROB) en WB.
% Buffer de reorden: 
% - puede inbluir buffer de renombreado.
% - Permite implementar la eliminacion de riesgos de control de forma sencilla.
% - Tarea fundamental: En la ultima etapa, garantiza que registros se modifican en orden del programa (de ahi viene el orden).
% 
% Eliminar RAW: ventanas de instrucciones 
% Eliminar WAR, WAW: buffer renombre.

% Los de control que se escapan (por prediccion incorrecta) se eliminan en WB.
% Para eliminar control usamos ROB.
% 
% IMPORTANTE
% # Detalles
% 
% IMPORTANTE
% ## Como se implmementa la emision
% Utilizamos los almacenamientos de negrita y se realizan las tareas de negrita (arriba).
% - Eliminan RAW y estructurales con estaciones de reserva o ventanas.
% - WAW y WAR con renombrado.
% - Cómo se capturan los operandos. Buffer con los registros de la arquitectura.
% 
% Si hay un registro no renombrado se capta el operando del buffer de registros.
% Si está renombrado, se capta del buffer de renombrado.
% 
% A Intel le gusta una estacion de reserva compartida.
% 
% Antes de nada:
% ### Buffer de renombrado
% Cuando se emite instruccion se le asigna entrada en estacion de reserva y se renombra el registro en el que se va a escribir asignandole una entrada en el banco de registros de renombrado. (Eso es la tabla Diap 14). Es una tabla con tantas entradas como registros. Campos:
% - U Si estoy usando la entrada.
% - Dest: registro que estoy renombrando. (2 renombra a 5).
% - Valor: Almaceno el valor que se va a guardar en 2
% - Valido: Si el valor está calculado o no (1 si esta calculado) y 0 si la instruccion emitida pero no ha terminado.
% - Ult: Elimina el WAW: si esta activo dice que es el ultimo renombrado de un registro (si el 5 esta renombrado varias veces), el 1 es que sea valido.
% 
% Cuando se emite una instruccion el registro donde se escribe se renombra.
% Si 3 y 5 no estan renombrados, se coge el contenido directamente de 3 y 5. Si estan renombrados, se cogen de la tabla.

% Siempre que se emite instruccion se le asigna entrada en buffer de renombrado (al registro que almacena) (si no, se producen WAR y WAW). Se ELIMINAN las dependencias, no hace falta detectarlas.
% RR: registro en tabla de renombrado.
% 1. Se renombran 3 y 5. Se meten en la tabla.
% 2. Se renombra 4.
% 3. Se espera a 3 en la estacion de reserva.
% 4. Se renombra nuevamente 3 con la entrada 5.
% 5. Se renombra nuevamente 7 con la entrada 6.
% 6. Suponemos division tarda mas que suma. Se completa antes la suma y pasa el campo a valido.
% 7. Se completa la siguiente suma.
% 8. Se completa la division, dato ya disponible.
% 9. Ya lo tiene disponible la estacion de reserva y ya se ejecuta.
% 10. Termina la entrada 6.
% 
% TODO AHORA:
% Añadimos estaciones de reserva. Las unidades de mult y suma-resta tienen su propia estacion de reserva.
% ESTACION DE RESERVA:
% - OC: para instruccion.
% - Rdestino: El registro de renombrado donde guardar el resultado. Cuando se calcula se mete y ya.
% - VS1: Primero operando.
% - VS2: Segundo operando.
% 
% Cuando se emite una instruccion se captan los operandos.
% Si no estan renombrados los operandos, se captan del registro y se mandan a estacion de reserva (no se renombran).
% Si estan renombrados, se coge de la tabla de renombrado en caso de estar calculado.
% Si estan renombrados, si no esta calculado, se almacena en OSi/ISi la entrada de la tabla de renombrado en el que se almacena el operando.
% 
% Al tener los operandos disponibles en el siguiente ciclo se ejecuta.
% Pasa a ejecutar una instruccion de la estacion de reserva cuando ambos operandos estan disponibles (elimina RAW) y la estructura esta disponible (elimina estructural).
% 
% Se pueden enviar instrucciones a la par.
% 
% - OSi/ISi El registro de renombrado donde se alamcena el operando cuando termina de calcularse.

% Añadir que write-back -> registros de la arquitectura.

% Clase 29 - 5
% 
% % Algoritmo de Tomasulo (el de las estaciones de reserva)
% 
% En la etapa de write-back, se pasan los valores de los registros renombrados a los registros reales (si 5 era el ultimo que renombraba a 3), en la etapa de write-back se hará:
% RR3 = RR5
% 
% # Buffer de reorden:
% - Permite que las instrucciones en la etapa de write-back se modifiquen los registros de la arquitectura (el estado del procesador) en el orden del programa, obteniendo resultados como si se ejecutase en orden del programa.
% - Además, sirve para implementar ejecución especulativa (para reducir riesgos de control) de una forma muy sencilla.
% 
% -- -- -- -- -- 
% -- -- -- -- -- 
% Antes: Importancia de reordenar instrucciones para extraer paralelismo y reducir tiempo secuencial.
% Diapositiva 25, código ensamblador de MIPS generador del bucle en c.
% 
% 
% Se carga xi en r1, se multipica por r6 y se guarda en la misma pos de la que se ha leido.
% Se carga yi en r3.
% Las instrucciones addi, subi, bnz son para el bucle
% addi: i++
% subi: n--
% bnz: n == 0 ?
% 
% Tenemos raw entre varias instrucciones (ld - mulf en ambos y mulf - st), y en subi - bnz.
% 
% Vemos que a pesar de tener 4 unidades funcionales para ejecución, no podemos extraer paralelismo. 
% Sin embargo, como en todos se permite W -> R, podemos hacer la flecha de "si W->R relajado", (no se pueden los dos ld en el mismo ciclo porque sólo hay una unidad de Mem) hay que ver si cada instruccion en paralelo puede hacerse en cada unidad funcioanl. Estamos extrayendo paralelismo.
% 
% El renombrado permite que addi adelante hasta mul, ya que elimina el WAR indicado.
% -- -- -- -- -- 
% -- -- -- -- -- 
% # BUFFER DE REORDEN
% Si el segundo ld lo hacemos con r7: el hardware no sabe si se va a leer la misma escritura.
% 
% Tenemos carga especulativa: 
% 
% Si entre ld y st se hacen calculos, dichos calculos estan en el buffer de renombre.
% 
% Cuando se sabe que el st accede a la misma direccion que ld, las instrucciones intermedias se deben marcar en algún almacenamiento para que cuando pasen por la úĺtima etapa no modifiquen los registros de la arquitectura, sino que se descarten. Esto se anota en el buffer de reordenamiento. Normalmente en el ROB se implementa el de renombrado.
% El contador de programa debe volver a ld, para volver a introducir las instrucciones al ROB.
% 
% Las instrucciones cuando se emiten se almacenan en el buffer de reorden en el orden del programa. Campos:
% - Indica la posición de la instrucción en el código (instr(n), instr(n+1)).
% - Indica el estado de la instruccion:
    % - x para ejecutando.
    % - i emitida pero no se ejecuta. En el 
    % - f finalizada.
% - flush: se pone a 1 para todas las instrucciones a continuacion de la instruccion de almacenamiento (se han ejecutado pero no deben modfiicar los registros de la arquitectura).
% Se pone a 1 cuando se han ejecutado instrucciones de forma especulativa y se encuentra que no se deben ejecutar realmente. Se han ejecutado pensando (especulando) que el almacenamiento no coincide con la lectura.
% Cuando el st pasa a finalizado y se ve que el ld es a la misma direccion se pone a 1.
% - Puede usarse de buffer de renombrado a la vez (para no tener renombrado y ROB, sino ROB k tmb hace de renombrado):
% - Registro de destino.
% - codop
% - resultado, ok
% - unidad a la que se va a mandar.
% 
% Cuando va finalizando la ejecucion se van retirando. Funciona a modo de cola.
% 
% Para quitar una instruccion, tiene que estar primero y finalizada. 
% En cada ciclo sacamos el nº maximo de instrucciones finalizadas en la cabeza de la cola que permita la arquitectura (quizas pueda sacar max 4 por ciclo).
% Las finalizadas que tengan antes una no finalizada no pueden retirarse hasta sacar las que le preceden, para garantizar el orden del programa => se garantiza que las instrucciones dan el funcionamiento como si fuera secuencial.
% 
% 
% Diap 28
% Suponemos estaciones de reserva independientes (una para cada unidad). Las Estaciones de resrva se encuentran inmediatamente antes de las unidades funcionales. 
% 

% 
% 
% 
% 
% 
% 
% 
% 
% No hemos hablado de eliminar riesgos de control:
% Los saltos los procesa:
% captación, ejecución, write back (mirar diapositivas):
% 
% para que no supongan penalizaciones las instrucciones de salto, detectarlas lo antes posible (se usa la direccion en la que se encuentra la direccion de salto).
% EN el PC tengo la direccion de la siguiente.
% 
% Debemos almacenar las direcciones que ocupan las instrucciones de salto: en la tabla de saltos.
% 
% - Campos:
% - Dirección de las instrucciones de salto (se identifican con la direccion en el código).
% - Dirección a la que salta si se cumple la condición.
% - Historial (3 bits) ayuda a predecir si saltará o no.
% Si hay más 1 que 0, se salta.
% primero: en la ultima ejecucion se salto.
% segundo: en la penultima no se salto.
% ultimo: en  la antepenultima se salto.
% 
% Diapo 31, en la columna 3 sub se queda en estacion de reserva por riesgo estructural (color rojo sobre blanco). 
% Teniamos dependencias de datos que haran esperar en estaciones de reserva (color amarillo sobre blanco).
% ER = Estacion de Reserva.
% 
% Con la prediccion que introducimos, hacemos que en el ciclo 2 (columna 2) se coja el pc y se consulte en la tabla de saltos (encontramos una direccion de salto => hay una instruccion de salto). 
% Va a consultar donde hay que saltar y la prediccion.
% Si hay que saltar, se carga en el pc la direccion y no hay penalizacion ninguna.
% 
% 
% Habra penalizacion cuando falla la prediccion:
% Al finalizar la etapa de ejcucion se comprobará el valor de r8 y se comprobará que no era válida la predicción. En el ROB se marcan las instrucciones a 1 en el flush.
% 
% Si acertamos: 0.75 cpi ~ 0.5 cpi ideal.
% 
% Si la prediccion falla, la instruccion despues del salto antes de terminar EX espera en ROB antes de quitarse (ya que se retiran en orden del programa). Por tanto, hasta que no se asegure que el salto era correcto no termina la siguiente tras el salto, en caso de predecir que iba a saltar y no salta.
% 
% 
% 
% Cómo se implementa el historial: con registro de desplazamiento, se realiza un shift.
% 
% Con dos estados:
% 3 y 2 salta, 1 y 0 no salta.
% 3 <--> 2 <--> 1 <--> 0
% Si se salta se va a la izquierda y si no se salta se va a la derecha.
% Se implementa a partir de realizacion de circuito a partir de diagrama de estados.
% 
% 
% 
% # Tipos de predicciones:
% pred dinamica: en tiempo de ejecucion.
    % implicita: se almacena la direccion sque se ejecuto la ultima vez que se ejecuto el salto.
    % explicita: se usa un estado que cuenta cuantas veces se salto.
% 
% pred estatica: fija.
    % segun desplazamiento: si es hacia detras, saltar (pensar en bucles), si no, no saltar (salir de un bucle).
    % podemos encontrar en ejs: siempre se predice saltar o siempre no.
% 
% Implementaciones rudimentarias, las actuales son más complejas.
% 
% ¿Por qué estado empieza?
% Se usa estatica para la para la primera vez.
% 


# Ganancia con la extracción de paralelismo del hardware
El software puede mejorar los tiempos:
El compilador puede intercambiar el add con el sub, eliminando el RAW y por tanto la espera por estaciones de reserva.
Beneficioso para superescalares y obligatorio para VLIW. Eliminamos las penalizaciones que suponen las RAW (no las podemos eliminar).








# VLIW
Sólo vamos a ver que los compiladores de un VLIW ponen juntas en memoria (para que se capten juntas) las instrucciones que se van a emitir en cada ciclo de reloj.

Suponemos que tenemos 4 unidades funcionales, luego va a poner junas 4 instrucciones.

¿Siempre va a encontrar 4 instrucciones de cada tipo independientes?
No, cuando no lo hace introduce instrucciones nop.

Hay procesadores VLIW comerciales.









Ejercicio 1. ENUNCIADO:
UNidades: 1 LD (2 ciclos), 1 ST (1 ciclos), 3 ADD/SUB (1), 1 mul (4).
Recomienda resumir datos en un dibujo:
IF --> ID --> En filas: Arriba --> WB
se captan: 4i/c, se codifican 4 y se emiten 4.

Emisión ordenada (en orden del programa), estación de reserva centralizada.
Supongo que unidades funcionales de ALU no segmentadas.

El ej no lo dice pero tenemos que saber:
- WAW, WAR se eliminan.
- RAW y estructurales se ocupa estacion de reserva.
- Instruccion no pasa a EX hasta operandos y unidad libre.

Suelen decir que no debemos preocuparnos del tamaño para ejecutarlo.

En gris lo que aún no ha ocurrido.
Todos los registros que no se han escrito se suponen dato disponible.
Los bits del inicio es si los operandos están o no disponibles (Si esta en gris es que no estan en la estacion de reserva).



Se pasan a EX las que tienen operando disponible y unidad.
TENER EN CUENTA ORDEN DEL PROGRAMA EN ESTE EJERCICIO: emitir a la vez o despues de la ultima.


Retirar de ROB: Etapa de WB.
IMPORTANTE: 
    Ver si emisión es ordenada o no
    Ver si envío desde unidades de reserva es ordenado o no.
    Si unidades segmentadas o no.
    Ciclos de cada unidad, intrucciones por ciclo, \ldots


Ver pdf de ejercicios.

Ejercicio 2.
Se captan y decodifica un número distinto.

Etapa de ROB:
    Tenemos un núcleo con 4 unidades pero el ROB no permite más que almacenar el resultado de 2 instrucciones cada ciclo de reloj.
    Problema: terminar mas instrucciones que instrucciones que el ROB puede almacenar a la vez (en un ciclo).
    Por ello, se introduce una etapa extra de ROB (RB). 
