\section{Introducción}

\begin{ejercicio}
    Considerar el siguiente fragmento de programa para 2 procesos \verb|P1| y \verb|P2|: Los dos procesos
    pueden ejecutarse a cualquier velocidad. ¿Cuáles son los posibles valores resultantes para la
    variable \verb|x|? Suponer que \verb|x| debe ser cargada en un registro para incrementarse y que cada
    proceso usa un registro diferente para realizar el incremento.
    \setlength{\columnsep}{2cm} % Ajusta el espacio entre columnas
    \begin{multicols}{2}
        \begin{minted}{pascal}
        {variables compartidas}
        var x : integer := 0 ;
        Process P1;
        var i: integer;
        begin
          begin
            for i:= 1 to 2 do begin
              x:= x + 1;
            end
          end
        end
        \end{minted}
        
        \begin{minted}{pascal}
            

        Process P2;
        var j: integer;
        begin
          begin
            for j:= 1 to 2 do begin
              x:= x + 1;
            end
          end
        end
        \end{minted}
    \end{multicols}

Observando el código, cada proceso hace 2 lecturas y dos escrituras (incrementos) en \verb|x|.
\begin{itemize}
    \item Como cada proceso aumenta dos veces el valor de \verb|x|, el valor de \verb|x| ha de ser, como mínimo, $2$.
    \item Como en total se hacen 4 incrementos, el valor de \verb|x| ha de ser $4$ como máximo.
\end{itemize}

Notando por $l_{ij}$ a la $j$-ésima lectura del proceso $i$ y por $e_{ij}$ a la $j$-ésima escritura del proceso $i$, ambas referidas a la variable \verb|x|, podemos obtener cualquiera de las siguientes trazas de ejecución:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c||c|c|c||c|c|c||c|c|c|}
    \hline
    \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| \\
    \hline
    \hline
    $l_{11}$ & - & 0 & $l_{11}$ & - & 0 & $l_{11}$ & - & 0 & $l_{11}$ & - & 0 \\
    \hline
    $e_{11}$ & - & 1 & - & $l_{21}$ & 0 & $e_{11}$ & - & 1 & - & $l_{21}$ & 0 \\
    \hline
    - & $l_{21}$ & 1 & $e_{11}$ & - & 1 & - & $l_{21}$ & 1 & $e_{11}$ & - & 1 \\
    \hline
    - & $e_{21}$ & 2 & - & $e_{21}$ & 1 & - & $e_{21}$ & 2 & - & $e_{21}$ & 1 \\
    \hline
    $l_{12}$ & - & 2 & $l_{12}$ & - & 1 & $l_{12}$ & - & 2 & $l_{12}$ & - & 1 \\
    \hline
    $e_{12}$ & - & 3 & $e_{12}$ & - & 2 & - & $l_{22}$ & 2 & - & $l_{22}$ & 1 \\
    \hline
    - & $l_{22}$ & 3 & - & $l_{22}$ & 2 & $e_{12}$ & - & 3 & $e_{12}$ & - & 2 \\
    \hline
    - & $e_{22}$ & 4 & - & $e_{22}$ & 3 & - & $e_{22}$ & 3 & - & $e_{22}$ & 2  \\
    \hline
\end{tabular}
\end{table}

Luego los posibles valores resultantes para \verb|x| son: 2, 3 y 4.

\end{ejercicio}


\begin{ejercicio}
    ¿Cómo se podría hacer la copia del fichero \verb|f| en otro \verb|g|, de forma concurrente, utilizando la
    instrucción concurrente \verb|cobegin-coend|? Para ello, suponer que:
    \begin{enumerate}
        \item Los archivos son una secuencia de items de un tipo arbitrario \verb|T|, y se encuentran ya abiertos
        para lectura (\verb|f|) y escritura (\verb|g|). Para leer un ítem de \verb|f| se usa la llamada a función \verb|leer(f)| y
        para saber si se han leído todos los ítems de \verb|f|, se puede usar la llamada \verb|fin(f)| que devuelve
        verdadero si ha habido al menos un intento de leer cuando ya no quedan datos. Para
        escribir un dato \verb|x| en \verb|g| se puede usar la llamada a procedimiento \verb|escribir(g,x)|.

        \item El orden de los items escritos en \verb|g| debe coincidir con el de \verb|f|.
        \item Dos accesos a dos archivos distintos pueden solaparse en el tiempo.
    \end{enumerate}~\\

\noindent
La copia del fichero \verb|f| en el fichero \verb|g| se podría realizar siguiendo el paradigma productor/consumidor que hemos visto en teoría en el Tema 1, mediante el uso de dos procesos:
\begin{itemize}
    \item Uno que lea un ítem del fichero \verb|f| y lo escriba en una variable compartida.
    \item Otro que lea dicha variable compartida y escriba el ítem en el fichero \verb|g|.
\end{itemize}
En dicho código, debemos garantizar que:
\begin{itemize}
    \item El consumidor no lea la variable antes de que el productor escriba en ella.
    \item En la segunda escritura del productor, debemos esperar a que antes la haya leído el consumidor.
    \item En la segunda lectura del consumidor, debemos esperar a que antes haya modificado la variable el productor.
\end{itemize}
Siguiendo estos pasos, obtendríamos un código como el siguiente:
\begin{minted}{pascal}
    process CopiaFicheros ;
    var ant, sig : T ;
    begin
      sig = leer(f) ;
      while not fin(f) do begin
        ant = sig ;
        cobegin
          escribir(g, anterior) ;
          sig = leer(f) ;
        coend
      end
    end
\end{minted}


\end{ejercicio}

\begin{ejercicio}\label{ej:3}
    Construir, utilizando las instrucciones concurrentes \verb|cobegin-coend| y \verb|fork-join|, programas concurrentes que se correspondan con los grafos de precedencia que se muestran en la figura~\ref{fig:grafoEj3}.
    \begin{figure}
        \centering
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=0.5cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left=of P0] (P1) {P1};
                    \node[node, below right=of P0] (P2) {P2};
                    \node[node, below=of P1] (P3) {P3};
                    \node[node, below left=of P3] (P4) {P4};
                    \node[node, below right=of P3] (P5) {P5};
                    \node[node, below=of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P3) -- (P4);
                    \draw[edge] (P3) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge, bend left] (P2) to (P6);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.1}.}
            \label{fig:grafoEj3.1}
            
        \end{subfigure}
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left=of P0] (P1) {P1};
                    \node[node, below right=of P0] (P2) {P2};
                    \node[node, below=of P1] (P3) {P3};
                    \node[node, below left=of P1] (P4) {P4};
                    \node[node, below right=of P1] (P5) {P5};
                    \node[node, below=of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P1) -- (P4);
                    \draw[edge] (P1) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge, bend left] (P2) to (P6);
                    \draw[edge, bend right] (P3) to (P6);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.2}.}
            \label{fig:grafoEj3.2}
            
        \end{subfigure}
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left=of P0] (P1) {P1};
                    \node[node, below right=of P0] (P2) {P2};
                    \node[node, below=of P1] (P3) {P3};
                    \node[node, below left=of P3] (P4) {P4};
                    \node[node, below right=of P3] (P5) {P5};
                    \node[node, below=of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P3) -- (P4);
                    \draw[edge] (P3) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge] (P2) to (P5);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.3}.}
            \label{fig:grafoEj3.3}
            
        \end{subfigure}
        \caption{Grafos de precedencia del ejercicio~\ref{ej:3}.}
        \label{fig:grafoEj3}
    \end{figure}


    \begin{enumerate}
        \item \label{ej:3.1}
         Grafo de precedencia de la figura~\ref{fig:grafoEj3.1}:

         \begin{figure}[H]
             \centering
             \begin{subfigure}[b]{0.45\textwidth}
                \centering
                 \begin{minted}{pascal}
                     begin
                       P0;
                       fork P2; P1;
                       P3;
                       fork P5; P4;
                       join P2; join P5;
                       P6;
                     end
                 \end{minted}
             \end{subfigure}\hfill
             \begin{subfigure}[b]{0.45\textwidth}
                \centering
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         P2;
                         begin
                           P1;
                           P3;
                           cobegin P4; P5; coend
                         end
                       coend
                       P6;
                     end
                 \end{minted}
             \end{subfigure}
         \end{figure}
                 
        \item \label{ej:3.2}
        Grafo de precedencia de la figura~\ref{fig:grafoEj3.2}:
        \begin{figure}[H]
            \centering
            \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \begin{minted}{pascal}
                begin
                  P0;
                  fork P2; P1;
                  fork P5; fork P3; P4;
                  join P2; join P5; join P3;
                  P6;
                end
                \end{minted}
            \end{subfigure}\hfill
            \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \begin{minted}{pascal}
                begin
                  P0;
                  cobegin
                    P2;
                    begin
                      P1;
                      cobegin P4; P3; P5; coend
                    end
                  coend
                  P6;
                end
                \end{minted}
            \end{subfigure}
        \end{figure}
        
         \item \label{ej:3.3}
         Grafo de precedencia de la figura~\ref{fig:grafoEj3.3}:
         \begin{minted}{pascal}
         begin
           P0;
           fork P2; P1;
           P3;
           fork P4; join P2; P5;
           join P4;
           P6;
         end
         \end{minted}

         Sin embargo, no podemos hacer al 100\% el DAG de la figura~\ref{fig:grafoEj3.3}, ya que tras \verb|P3| debemos crear una estructura \verb|cobegin-coend|. Sin embargo, este debe esperar a \verb|P2|, por lo que la estructura \verb|cobegin-coend| tendrá que esperar a \verb|P2|, pero es que \verb|P4| no necesita que \verb|P2| termine. 

         Por tanto, no se puede programar con creación de hebras de forma estructurada. Sin embargo, podemos ofrecer dos soluciones, cada una que impone algo que el grafo no nos dice:
         \begin{enumerate}
             \item Si obligamos a que \verb|P4| también espere a \verb|P2|, obtendríamos el código:
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         P2;
                         begin
                           P1; P3;
                         end
                       coend
                       cobegin P4; P5; coend
                       P6;
                     end
                 \end{minted}
                 
             \item Si ahora queremos ejecutar de forma concurrente el flujo que tiene a \verb|P1|, \verb|P3| y \verb|P4| con el flujo que tiene a \verb|P2|, entonces obligamos a que \verb|P5| espere a \verb|P4| (que no nos lo especifica el DAG, pero lo necesitamos para poder programarlo de forma estructurada):
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         begin P1; P3; P4; end
                         P2;
                       coend
                       P5;
                       P6;
                     end
                 \end{minted}
                 
         \end{enumerate}
    \end{enumerate}

\end{ejercicio}



\begin{ejercicio} \label{ej:4}
    Dados los siguientes fragmentos de programas concurrentes, obtener sus grafos de precedencia asociados:
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                begin
                    P0 ;
                    cobegin
                        P1 ;
                        P2 ;
                        cobegin
                            P3 ; P4 ; P5 ; P6 ;
                        coend ;
                        P7 ;
                    coend
                    P8 ;
                end
            \end{minted}
            \caption{Programa 1.}
            \label{code:prog1_Ej4}
        \end{subfigure}\hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                begin
                    P0 ;
                    cobegin
                        begin
                            cobegin
                                P1 ; P2 ;
                            coend
                            P5 ;
                        end
                        begin
                            cobegin
                                P3 ; P4 ;
                            coend
                            P6 ;
                        end
                    coend
                    P7 ;
                end
            \end{minted}
            \caption{Programa 2.}
            \label{code:prog2_Ej4}
        \end{subfigure}
        \caption{Programas concurrentes del ejercicio~\ref{ej:4}.}
    \end{figure}
    
    \begin{enumerate}
        \item Programa de la figura~\ref{code:prog1_Ej4}.

            \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
                \node[node] (P0) {P0};
                \node[node, below=of P0] (P4) {P4};
                \node[node, left=of P4] (P3) {P3};
                \node[node, left=of P3] (P2) {P2};
                \node[node, left=of P2] (P1) {P1};
                \node[node, right=of P4] (P5) {P5};
                \node[node, right=of P5] (P6) {P6};
                \node[node, right=of P6] (P7) {P7};
                \node[node, below=of P4] (P8) {P8};

                \draw[edge] (P0) -- (P1);
                \draw[edge] (P0) -- (P2);
                \draw[edge] (P0) -- (P3);
                \draw[edge] (P0) -- (P4);
                \draw[edge] (P0) -- (P5);
                \draw[edge] (P0) -- (P6);
                \draw[edge] (P0) -- (P7);

                \draw[edge] (P1) -- (P8);
                \draw[edge] (P2) -- (P8);
                \draw[edge] (P3) -- (P8);
                \draw[edge] (P4) -- (P8);
                \draw[edge] (P5) -- (P8);
                \draw[edge] (P6) -- (P8);
                \draw[edge] (P7) -- (P8);
            \end{tikzpicture}
            \caption{DAG para la figura~\ref{code:prog1_Ej4}.}
            \end{figure}
        \item Programa de la figura~\ref{code:prog2_Ej4}.
            \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node/.style={circle, draw, minimum size=1cm},
                                edge/.style={-stealth}]
                \node[node] (P0) {P0};
                \node[node, below left=of P0] (P2) {P2};
                \node[node, left=of P2] (P1) {P1};
                \node[node, below right=of P0] (P3) {P3};
                \node[node, right=of P3] (P4) {P4};
                \node[node, below right=of P1] (P5) {P5};
                \node[node, below left=of P4] (P6) {P6};

                \node[below=of P0] (A) {};
                \node[below=of A] (B) {};
                \node[node, below=of B] (P7) {P7};
                
                \draw[edge] (P0) -- (P1);
                \draw[edge] (P0) -- (P2);
                \draw[edge] (P0) -- (P3);
                \draw[edge] (P0) -- (P4);
                \draw[edge] (P1) -- (P5);
                \draw[edge] (P2) -- (P5);
                \draw[edge] (P3) -- (P6);
                \draw[edge] (P4) -- (P6);
                \draw[edge] (P5) -- (P7);
                \draw[edge] (P6) -- (P7);
            \end{tikzpicture}
            \caption{DAG para la figura~\ref{code:prog2_Ej4}.}
            \end{figure}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:5}
    Suponer un sistema de tiempo real que dispone de un captador de impulsos conectado a un
    contador de energía eléctrica. La función del sistema consiste en contar el número de impulsos
    producidos en 1 hora (cada Kwh consumido se cuenta como un impulso) e imprimir este número
    en un dispositivo de salida. Para ello se dispone de un programa concurrente con 2 procesos: un
    proceso acumulador (lleva la cuenta de los impulsos recibidos) y un proceso escritor (escribe
    en la impresora). En la variable común a los 2 procesos \verb|n| se lleva la cuenta de los impulsos. El
    proceso acumulador puede invocar un procedimiento \verb|Espera_impulso| para esperar a que llegue
    un impulso, y el proceso escritor puede llamar a \verb|Espera_fin_hora| para esperar a que termine
    una hora. El código de los procesos de este programa podría ser el descrito en el Código Fuente~\ref{code:ej5}.
    \begin{observacion}
        En el programa se usan sentencias de acceso a la variable \verb|n| encerradas entre los símbolos \verb|<| y
        \verb|>|. Esto significa que cada una de esas sentencias se ejecuta en exclusión mutua entre los dos
        procesos, es decir, esas sentencias se ejecutan de principio a fin sin entremezclarse entre ellas.
        Supongamos que en un instante dado el acumulador está esperando un impulso, el escritor está
        esperando el fin de una hora, y la variable \verb|n| vale \verb|k|. Después se produce de forma simultánea
        un nuevo impulso y el fin del periodo de una hora.
    \end{observacion}

    Obtener las posibles secuencias de interfolicación de las instrucciones (1),(2), y (3) a partir de
    dicho instante, e indicar cuales de ellas son correctas y cuales incorrectas (las incorrectas son
    aquellas en las cuales el impulso no se contabiliza).
    \begin{listing}
        \begin{minted}{pascal}
            { variable compartida: }
            var n : integer; { contabiliza impulsos }
            begin
            while true do begin
                Espera_impulso();
                < n := n+1 > ; { (1) }
                end
            end
            process Escritor ;
            begin
            while true do begin
                Espera_fin_hora();
                write( n ) ; { (2) }
                < n := 0 > ; { (3) }
                end
            end
        \end{minted}
        \caption{Código acumulador-escritor del ejercicio~\ref{ej:5}.}
        \label{code:ej5}
    \end{listing}

    En primer lugar, notemos que la intrucción $2$ siempre se ejecutará
    antes que la instrucción $3$, ya que están ambas en el mismo proceso (el escritor).
    Por tanto, las secuencia de instrucciones que se pueden dar son las intercalaciones de la instrucción $1$ con las otras dos instrucciones; es decir: $A)~1-2-3$, $B)~2-1-3$ y $C)~2-3-1$. El análisis de cada una de ellas está en la Tabla~\ref{tab:ej5}.
    \begin{table}
        \centering
        \begin{tabular}{|lcc|lcc|lcc|}
            \hline
            \multicolumn{3}{|c|}{Opción $A$} & \multicolumn{3}{|c|}{Opción $B$} & \multicolumn{3}{|c|}{Opción $C$} \\ \hline
            Operación & \verb|n| & Salida & Operación & \verb|n| & Salida & Operación & \verb|n| & Salida\\
            \hline
            $-$ & $k$ & $-$ & $-$ & $k$ & $-$ & $-$ & $k$ & $-$ \\
            \verb|1|$\to$ \verb|n:=n+1| & $k+1$ & $-$ & \verb|2|$\to$ \verb|write(n)| & $k$ & $k$ & \verb|2|$\to$ \verb|write(n)| & $k$ & $k$ \\
            \verb|2|$\to$ \verb|write(n)| & $k+1$ & $k+1$ & \verb|1|$\to$ \verb|n:=n+1| & $k+1$ & $k$ & \verb|3|$\to$ \verb|n:=0| & $0$ & $k$ \\
            \verb|3|$\to$ \verb|n:=0| & $0$ & $k+1$ & \verb|3|$\to$ \verb|n:=0| & $0$ & $k$ & \verb|1|$\to$ \verb|n:=n+1| & $1$ & $k$ \\
            \hline
        \end{tabular}
        \caption{Tabla de opciones del ejercicio~\ref{ej:5}.}
        \label{tab:ej5}
    \end{table}
    Notemos que tanto la opción $A$ como la $C$ son válidas, ya que en ambas se contabiliza el impulso. No obstante, difieren entre sí, puesto que en la opción $A$ se contabiliza el impulso en la hora que termina (imprimiéndose entonces), mientras que en la opción $C$ se contabiliza el impulso en la hora siguiente (no imprimiéndose entonces en esta salida). No obstante, la opción $B$ es incorrecta, ya que no se contabiliza el impulso en la hora que termina ni en la siguiente.
\end{ejercicio}



\begin{ejercicio} \label{ej:6}
    Supongamos un programa concurrente en el cual hay, en memoria compartida dos vectores \verb|a| y
    \verb|b| de enteros y con tamaño par, declarados como sigue:
    \begin{minted}{pascal}
        var a,b : array[1..2*n] of integer ; { n es una constante predefinida }
    \end{minted}
    Queremos escribir un programa para obtener en \verb|b| una copia ordenada del contenido de \verb|a| (nos
    da igual el estado en que queda \verb|a| después de obtener \verb|b|). Para ello disponemos de la función
    \verb|Sort| que ordena un tramo de \verb|a| (entre las entradas \verb|s| y \verb|t|, ambas incluidas). También disponemos
    la función \verb|Copiar|, que copia un tramo de \verb|a| (desde \verb|s| hasta \verb|t|) en \verb|b| (a partir de \verb|o|). Estas funciones
    se muestran en el Código Fuente~\ref{code:ej_6SortCopiar}.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Sort( s,t : integer );
                var i, j : integer ;
                begin
                    for i := s to t do
                    for j:= s+1 to t do
                        if a[i] < a[j] then
                            swap( a[i], b[j] ) ;
                end

            procedure Copiar( o,s,t : integer );
                var d : integer ;
                begin
                    for d := 0 to t-s do
                        b[o+d] := a[s+d] ;
                end
        \end{minted}
        \caption{Procedimientos \mintinline{pascal}{Sort} y \mintinline{pascal}{Copiar} del ejercicio~\ref{ej:6}.}
        \label{code:ej_6SortCopiar}
    \end{listing}

    El programa para ordenar se puede implementar de dos formas:
    \begin{enumerate}
        \item Ordenar todo el vector \verb|a|, de forma secuencial con la función \verb|Sort|, y después copiar cada
        entrada de \verb|a| en \verb|b|, con la función \verb|Copiar|.
        \item Ordenar las dos mitades de \verb|a| de forma concurrente, y después mezclar dichas dos mitades
        en un segundo vector \verb|b| (para mezclar usamos un procedimiento \verb|Merge|).
    \end{enumerate}
    En el Código Fuente~\ref{code:ej6_2versiones} se muestra el código de ambas versiones.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Secuencial() ;
                var i : integer ;
                begin
                    Sort( 1, 2*n ); { ordena a }
                    Copiar( 1, 2*n ); { copia a en b }
                end

            procedure Concurrente() ;
                begin
                    cobegin
                        Sort( 1, n );
                        Sort( n+1, 2*n );
                    coend
                    Merge( 1, n+1, 2*n );
                end
        \end{minted}
        \caption{Procedimientos \mintinline{pascal}{Secuencial} y \mintinline{pascal}{Concurrente} del ejercicio~\ref{ej:6}.}
        \label{code:ej6_2versiones}
    \end{listing}

    El código de la función \verb|Merge|, disponible en el Código Fuente~\ref{code:ej6_Merge}, se encarga de ir leyendo las dos mitades de \verb|a|, en cada paso, seleccionar el menor elemento de los dos siguientes por leer (uno en cada mitad), y escribir dicho menor elemento en la siguiente mitad del vector mezclado \verb|b|.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Merge( inferior, medio, superior: integer ) ;
                { siguiente posicion a escribir en b }
                var escribir : integer := 1 ;
                { siguiente pos. a leer en primera mitad de a }
                var leer1 : integer := inferior ;
                { siguiente pos. a leer en segunda mitad de a }
                var leer2 : integer := medio ;
                begin
                    { mientras no haya terminado con alguna mitad }
                    while leer1 < medio and leer2 <= superior do begin
                        if a[leer1] < a[leer2] then begin { minimo en la primera mitad }
                            b[escribir] := a[leer1] ;
                            leer1 := leer1 + 1 ;
                        end else begin { minimo en la segunda mitad }
                            b[escribir] := a[leer2] ;
                            leer2 := leer2 + 1 ;
                        end
                        escribir := escribir+1 ;
                    end
                    { se ha terminado de copiar una de las mitades,
                    copiar lo que quede de la otra }
                    if leer2 > superior then
                        { copiar primera } Copiar( escribir, leer1, medio-1 );
                    else Copiar( escribir, leer2, superior ); { copiar segunda }
                end
        \end{minted}
        \caption{Procedimiento \mintinline{pascal}{Merge} del ejercicio~\ref{ej:6}.}
        \label{code:ej6_Merge}
    \end{listing}

    Llamaremos $T_s(k)$ al tiempo que tarda el procedimiento \verb|Sort| cuando actúa sobre un segmento del vector con $k$ entradas. Suponemos que el tiempo que (en media) tarda cada iteración del bucle interno que hay en \verb|Sort| es la unidad (por definición). Es evidente que ese bucle tiene $\dfrac{k(k-1)}{2}$ iteraciones, luego:
    \[
        T_s(k) = \dfrac{k(k-1)}{2} = \dfrac{1}{2}\cdot k^2 - \dfrac{1}{2}\cdot k
    \]

    El tiempo que tarda la versión secuencial sobre $2n$ elementos (llamaremos $S$ a dicho tiempo) será evidentemente $T_s(2n)$, luego:
    \[
        S = T_s(2n) = \dfrac{1}{2}\cdot (2n)^2 - \dfrac{1}{2}\cdot 2n = 2n^2 - n
    \]

    Con estas definiciones, calcular el tiempo que tardará la versión paralela, en los dos siguientes casos. Para esto, hay que suponer que cuando el procedimiento \verb|Merge| actúa sobre un vector con $p$ entradas, tarda $p$ unidades de tiempo en ello, lo cual es razonable teniendo en cuenta que en esas circunstancias \verb|Merge| copia $p$ valores desde \verb|a| hacia \verb|b|. Si llamamos a este tiempo $T_m(p)$, podemos escribir $T_m(p) = p$. Escribe también una comparación cualitativa de los tres tiempos ($S$, $P_1$ y $P_2$). 
    \begin{enumerate}
        \item Las dos instancias concurrentes de \verb|Sort| se ejecutan en el mismo procesador (llamamos $P_1$ al tiempo que tarda).
        
        En este caso, tenemos que hay ganancia de tiempo, ya que las dos instancias de \verb|Sort| no pueden ejecutarse simultáneamente. Por tanto, tenemos que:
        \begin{equation*}
            P_1 = 2\cdot T_s(n) + T_m(2n) = 2\cdot \left( \dfrac{1}{2}\cdot n^2 - \dfrac{1}{2}\cdot n \right) + 2n = n^2 - n + 2n = n^2 + n
        \end{equation*}
        \item Cada instancia de \verb|Sort| se ejecuta en un procesador distinto (lo llamamos $P_2$).
        
        Al poder ejecutarse ahora de forma simultánea, tenemos que:
        \begin{equation*}
            P_2 = \max\{ T_s(n), T_s(n) \} + T_m(2n) = \left( \dfrac{1}{2}\cdot n^2 - \dfrac{1}{2}\cdot n \right) + 2n = \dfrac{1}{2}\cdot n^2 + \dfrac{3}{2}\cdot n
        \end{equation*}
    \end{enumerate}

    Como podemos ver, en los tres casos la eficiencia es del orden cuadrático. No obstante,
    el coeficiente de $n^2$ es distinto en cada caso, siendo el mayor en la versión secuencial. Deducimos por tanto que las versiones concurrentes son más eficientes que la secuencial, y estas mejoras son significativas para valores de $n$ grandes.    

\end{ejercicio}

\begin{ejercicio} \label{ej:7}
    Supongamos que tenemos un programa con tres matrices (\verb|a|, \verb|b| y \verb|c|) de valores flotantes declaradas
    como variables globales. La multiplicación secuencial de \verb|a| y \verb|b| (almacenando el resultado en \verb|c|)
    se puede hacer mediante un procedimiento \verb|MultiplicacionSec| declarado como aparece aquí:
    \begin{minted}{pascal}
        var a, b, c : array[1..3,1..3] of real ;
        procedure MultiplicacionSec()
            var i,j,k : integer ;
            begin
                for i := 1 to 3 do
                    for j := 1 to 3 do begin
                        c[i,j] := 0 ;
                        for k := 1 to 3 do
                            c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                    end
            end
    \end{minted}
    Escribir un programa con el mismo fin, pero que use 3 procesos concurrentes. Suponer que
    los elementos de las matrices \verb|a| y \verb|b| se pueden leer simultáneamente, así como que elementos distintos de \verb|c| pueden escribirse simultáneamente.\\

    Esta solución puede llevarse a cabo de dos formas (tal y como vimos en la asigantura de AC). Crearemos tres procesos, y cada uno puede calcular una fila de la matriz \verb|c| (Código Fuente~\ref{code:ej7_fila}) o bien cada uno puede calcular una columna de la matriz \verb|c| (Código Fuente~\ref{code:ej7_columna}). No obstante, en la asignatura de AC se vio que, por norma general, es más eficiente calcular por filas que por columnas, ya que en el primer caso se accede a la matriz \verb|a| de forma secuencial, aprovechando así la localidad espacial y provocando un número menor de fallos de caché.
    \begin{figure}
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                var a, b, c : array[1..3,1..3] of real ;
                process CalcularFila[ i : 1..3] ;
                    var j, k : integer ;
                    begin
                        for j := 1 to 3 do begin
                            c[i,j] := 0 ;
                            for k := 1 to 3 do
                                c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                        end
                    end
                end
            \end{minted}
            \caption{Procesos concurrentes para calcular por filas.}
            \label{code:ej7_fila}
        \end{subfigure}\hfill
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                var a, b, c : array[1..3,1..3] of real ;
                process CalcularColumna[j : 1..3] ;
                    var i, k : integer ;
                    begin
                        for i := 1 to 3 do begin
                            c[i,j] := 0 ;
                            for k := 1 to 3 do
                                c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                        end
                    end
                end
            \end{minted}
            \caption{Procesos concurrentes para calcular por columnas.}
            \label{code:ej7_columna}
        \end{subfigure}
        \caption{Códigos para el ejercicio~\ref{ej:7}.}
    \end{figure}
    % // TODO: Se lanzan solos?
\end{ejercicio}

\begin{ejercicio}\label{ej:8}
    Un trozo de programa ejecuta nueve rutinas o actividades (\verb|P1|, \verb|P2|, \ldots, \verb|P9|), repetidas veces,
    de forma concurrentemente con \verb|cobegin-coend| (ver trozo de código de la figura~\ref{code:ej8_enunciado}), pero que requieren
    sincronizarse según determinado grafo (ver la figura~\ref{fig:ej8_grafo}).
    \begin{figure}
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                while true do
                cobegin
                    P1 ; P2 ; P3 ;
                    P4 ; P5 ; P6 ;
                    P7 ; P8 ; P9 ;
                coend
            \end{minted}
            \caption{Código del ejercicio~\ref{ej:8}.}
            \label{code:ej8_enunciado}
        \end{subfigure} \hfill
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{tikzpicture}[
                node/.style={circle, draw, minimum size=0.5cm},
                edge/.style={-Stealth}
                ]
    
                % Nodos
                \node[node] (P1) {P1};
                \node[node, right =of P1] (P2) {P2};
                \node[node, right =of P2] (P3) {P3};
                \node[node, below =of P1] (P4) {P4};
                \node[node, right =of P4] (P5) {P5};
                \node[node, right =of P5] (P6) {P6};
                \node[node, below =of P4] (P7) {P7};
                \node[node, right =of P7] (P8) {P8};
                \node[node, right =of P8] (P9) {P9};

                % Aristas
                \draw[edge] (P1) -- (P4);
                \draw[edge] (P1) -- (P2);
                \draw[edge] (P2) -- (P3);
                \draw[edge] (P2) -- (P5);
                \draw[edge] (P3) -- (P6);
                \draw[edge] (P4) -- (P5);
                \draw[edge] (P4) -- (P7);
                \draw[edge] (P5) -- (P6);
                \draw[edge] (P5) -- (P8);
                \draw[edge] (P6) -- (P9);
                \draw[edge] (P7) -- (P8);
                \draw[edge] (P8) -- (P9);
            \end{tikzpicture}
            \caption{DAG del ejercicio~\ref{ej:8}.}
            \label{fig:ej8_grafo}
        \end{subfigure}
        \caption{Figuras del ejercicio~\ref{ej:8}.}
    \end{figure}

    Supón que queremos realizar la sincronización indicada en el grafo, usando para ello llamadas
    desde cada rutina a dos procedimientos (\verb|EsperarPor| y \verb|Acabar|). Se dan los siguientes hechos:
    \begin{itemize}
        \item El procedimiento \verb|EsperarPor(i)| es llamado por una rutina cualquiera (la número $k$) para esperar a que termine la rutina número $i$, usando espera ocupada. Por tanto, se usa por la rutina $k$ al inicio para esperar la terminación de las otras rutinas que corresponda según el grafo.
        \item El procedimiento \verb|Acabar(i)| es llamado por la rutina número $i$, al final de la misma, para indicar que dicha rutina ya ha finalizado.
        \item Ambos procedimientos pueden acceder a variables globales en memoria compartida.
        \item Las rutinas se sincronizan única y exclusivamente mediante llamadas a estos procedimientos, siendo la implementación de los mismos completamente transparente para las rutinas.
    \end{itemize}
    Escribe una implementación de \verb|EsperarPor| y \verb|Acabar| (junto con la declaración e inicialización de las variables compartidas necesarias) que cumpla con los requisitos dados.\\

    Usaremos para ello un vector de variables booleanas \verb|finalizado|, donde \verb|finalizado[i]| indica si la rutina $i$ ha finalizado o no. Inicialmente estará inicializado a \verb|false|, puesto que ningún proceso ha finalizado. Es decir:
    \begin{minted}{pascal}
        var finalizado : array[1..9] of boolean := (false,...,false) ;
    \end{minted}

    El procedimiento \verb|EsperarPor| se implementa de la siguiente forma:
    \begin{minted}{pascal}
        procedure EsperarPor( i : integer ) ;
        begin
            while not finalizado[i] do
            begin
                { no hacer nada }
            end;
        end.
    \end{minted}
    % // TODO: ¿Cuando es procedure y cuándo es process?

    Respecto a la función \verb|Acabar|, podríamos pensar que tan solo se necesita cambiar el valor de la variable \verb|finalizado[i]| a \verb|true|. No obstante, hemos de tener en cuenta que este programa de ejecuta de forma repetida, por lo que si no se reinicia el vector \verb|finalizado| al final de cada ejecución, en la siguiente ejecución ya no habrá la sincronización necesaria. Por tanto, tras el fin del proceso \verb|P9|, se reinicia el vector \verb|finalizado| a \verb|false|.
    \begin{minted}{pascal}
        procedure Acabar( i : integer ) ;
        begin
            finalizado[i] := true ;
            if i >= 9 then
                finalizado := (false,...,false) ;
        end
    \end{minted}
    
\end{ejercicio}


\begin{ejercicio}
    En el ejercicio~\ref{ej:8} los procesos \verb|P1|, \verb|P2|, \ldots, \verb|P9| se ponen en marcha usando \verb|cobegin-coend|.
    Escribe un programa equivalente, que ponga en marcha todos los procesos, pero que use declaración
    estática de procesos, usando un vector de procesos \verb|P|, con índices desde 1 hasta 9, ambos incluidos. El proceso \verb|P[n]| contiene una secuencia de instrucciones desconocida, que llamamos \verb|S_n|, y además debe incluir las llamadas necesarias a \verb|Acabar| y \verb|EsperarPor| (con la misma implementación que antes) para lograr la sincronización adecuada. Se incluye aquí una plantilla:
    \begin{minted}{pascal}
        Process P[ n : 1..9 ]
        begin
            ..... { esperar (si es necesario) a los procesos que corresponda }
            S_n ; { sentencias especificas de este proceso (desconocidas) }
            ..... { senalar que hemos terminado }
        end
    \end{minted}

    En primer lugar, hemos de especificar, en función de $n$, a qué procesos ha de esperar cada uno, lo cual se hará mediante una matriz compartida. Tenemos que:
    \begin{minted}{pascal}
        var espera : array[1..9,1..2] of integer := (
            (-1, -1),   { P1 }
            (1, -1),    { P2 }
            (2, -1),    { P3 }
            (1, -1),    { P4 }
            (2, 4),     { P5 }
            (3, 5),     { P6 }
            (4, -1),    { P7 }
            (5, 7),     { P8 }
            (6, 8)      { P9 }
        ) ;
        Process P[ n : 1..9 ]
        begin
            for i := 1 to 2 do
                if espera[n,i] <> -1 then { != -1 }
                    EsperarPor( espera[n,i] ) ;
            
            S_n ;
            Acabar( n ) ;
        end
    \end{minted}
    % // TODO: Sintaxis en Pascal? Relevante?
\end{ejercicio}

\begin{ejercicio}
    Para los siguientes fragmentos de código, obtener la \emph{poscondición} adecuada para convertirlo en un triple demostrable con la Lógica de Programas:
    \begin{enumerate}
        \item $\{i < 10\} \quad i = 2 \ast i + 1 \quad \{ \}$\\
            Obtenemos la poscondición de este triple razonando matemáticamente:
            \begin{align*}
                i &< 10 \\
                2\ast i &< 20 \\
                i' = 2\ast i + 1 &< 21
            \end{align*}
            donde hemos notado por $i'$ al nuevo valor que adopta la variable $i$.\\

            Por tanto, la poscondición del triple es: $i < 21$.

            Pasamos ahora a demostrar el triple siguiente:
            \begin{equation*}
               \{i < 10\} \quad i = 2 \ast i + 1 \quad \{i<21\}
            \end{equation*}
            
            Usando el axioma de asignación, tenemos que:
            \begin{equation*}
                \{i<21\}^i_{2\ast i + 1}\quad i=2\ast i + 1\quad \{i<21\}
            \end{equation*}

            No obstante, de la definición de Sustitución Textual, tenemos que:
            \begin{equation*}
                \{i<21\}^i_{2\ast i + 1} \equiv \{2\ast i + 1 < 21\} \equiv \{i < 10\} 
            \end{equation*}
            
            Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \begin{equation*}
                \{i<10\}\quad i=2\ast i + 1\quad \{i<21\} \\
            \end{equation*}

        \item $\{i > 0\} \quad i = i - 1; \quad \{ \}$\\
            Obtenemos la poscondición de este triple razonando matemáticamente:
            \begin{align*}
                i &> 0 \\
                i' = i - 1 &> -1
            \end{align*}
            donde hemos notado por $i'$ al nuevo valor que adopta la variable $i$.\\

            Por tanto, la poscondición del triple es: $i > -1$.

            Pasamos ahora a demostrar el triple siguiente:
            \begin{equation*}
                \{i > 0\} \quad i = i - 1; \quad \{i > -1\}
            \end{equation*}

            Usando el axioma de asignación, tenemos que:
            \begin{equation*}
                \{i > -1\}^i_{i-1}\quad i=i-1\quad \{i>-1\}
            \end{equation*}

            No obstante, de la definición de Sustitución Textual, tenemos que:
            \begin{equation*}
                \{i > -1\}^i_{i-1} \equiv \{i-1 > -1\} \equiv \{i > 0\}
            \end{equation*}

            Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \begin{equation*}
                \{i > 0\}\quad i = i - 1\quad \{i > -1\}
            \end{equation*}

        \item $\{i > j\} \quad i = i + 1;~j = j + 1 \quad \{ \}$\\
            De forma matemática y notando por $i'$ y $j'$ a las modificaciones de $i$ y $j$, respectivamente:
            \begin{align*}
                i &> j \\
                i' = i+1 &> j+1=j'\\
                i' &> j'
            \end{align*}

            Por tanto, la poscondición del triple es: $i > j$. Pasamos a demostrar el triple:
            \begin{equation*}
                \{i > j\} \quad i = i + 1;~j = j + 1 \quad \{i>j\}
            \end{equation*}

            Usando la regla de la composición, tenemos que:
            \begin{equation*}
                \dfrac{\{P\}S_1\{Q\}, \{Q\}S_2\{R\}}{\{P\}S_1;S_2\{R\}} \\
            \end{equation*}

            Identificando $Q$ con $i>j+1$, tenemos que bastará con probar los triples:
            \begin{enumerate}
                \item $\{i>j\}\ i=i+1\ \{i>j+1\}$
                
                Mediante el axioma de asignación, tenemos que:
                \begin{equation*}
                    \{i>j\} \equiv \{i+1>j+1\} \equiv \{i>j+1\}^i_{i+1}\ i=i+1\ \{i>j+1\}
                \end{equation*}

                \item $\{i>j+1\}\ j=j+1\ \{i>j\}$
                
                Mediante el axioma de asignación, tenemos que:
                \begin{equation*}
                    \{i>j+1\} \equiv \{i>j\}^j_{j+1}\ j=j+1\ \{i>j\}
                \end{equation*}
            \end{enumerate}

            Como ambos son ciertos, el triple que queríamos demostrar también lo es gracias a la regla de composición.
        \item $\{\text{falso}\} \quad a = a + 7; \quad \{ \}$\\
            En este caso, partimos de un estado del programa inalcanzable, por lo que en la poscondición podemos poner cualquier estado del programa, es decir, $\{\text{verdad}\}$.
        \item $\{\text{verdad}\} \quad i = 3;~j = 2 \ast i \quad \{ \}$\\
            Como partimos de cualquier estado del programa y sólo se realizan asignaciones, es fácil intuir cuál será la poscondición:
            \begin{gather*}
                i = 3 \\
                j = 2\ast i = 2\ast 3 = 6
            \end{gather*}
            Pasamos a demostrar el triple
            \begin{equation*}
                \{\text{verdad}\} \quad i = 3;~j = 2 \ast i \quad \{i=3\ \land\ j=6\}
            \end{equation*}
            Usando la regla de composición, nos será suficiente probar los triples:
            \begin{equation*}
                \{\text{verdad}\}\ i=3\ \{i=3\} \qquad \{i=3\}\ j=2\ast i\ \{i=3\ \land\ j=6\}
            \end{equation*}
            \begin{enumerate}
                \item Para el primer triple, usamos el axioma de asignación:
                \begin{equation*}
                    \{\text{verdad}\} \equiv \{3=3\} \equiv \{i=3\}^i_3\ i=3\ \{i=3\}
                \end{equation*}
                \item Para el segundo, volvemos a usar el axioma de asignación:
                \begin{equation*}
                    \{i=3\ \land\ j=6\}^j_{2\ast i}\ j=2\ast i\ \{i=3\ \land\ j=6\}
                \end{equation*}

                No obstante, de la definición de Sustitución Textual, tenemos que:
                \begin{multline*}
                    \{i=3\ \land\ j=6\}^j_{2\ast i} \equiv \{i=3\ \land\ 2\ast i=6\} \equiv \{i=3\ \land 2\ast 3=6\} \equiv \\ \equiv \{i=3\ \land\ 6=6\} \equiv \{i=3\}
                \end{multline*}

                Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \end{enumerate}
            Ambos triples son ciertos, luego por la regla de la composición tenemos demostrado nuestro triple.
        \item $\{\text{verdad}\} \quad c = a + b;~c = \nicefrac{c}{2} \quad \{ \}$\\
            Notando por $c'$ al nuevo valor de $c$, tenemos que:
            \begin{align*}
                c &= a + b \\
                c' = \nicefrac{c}{2} &= \frac{a+b}{2}
            \end{align*}
            Tratamos por tanto de probar el siguiente triple
            \begin{equation*}
                \{\text{verdad}\} \quad c = a + b;~c = \nicefrac{c}{2} \quad \left\{c=\frac{a+b}{2}\right\}
            \end{equation*}
            Usando la regla de la composición, basta con probar los triples:
            \begin{equation*}
                \{\text{verdad}\}\ c=a+b;\ \{c=a+b\} \qquad \{c=a+b\}\ c=\nicefrac{c}{2};\ \left\{c=\frac{a+b}{2}\right\}
            \end{equation*}
            \begin{enumerate}
                \item Para el primero, usamos el axioma de asignación:
                    \begin{equation*}
                        \{\text{verdad}\}\equiv\{a+b=a+b\}\equiv \{c=a+b\}^c_{a+b}\ c=a+b\ \{c=a+b\}
                    \end{equation*}
                \item Para la segunda, también usamos el axioma de asignación:
                    \begin{equation*}
                        \{c=a+b\}\equiv \left\{\frac{c}{2} = \frac{a+b}{2}\right\} \equiv \left\{c=\frac{a+b}{2}\right\}^c_{\nicefrac{c}{2}}\ c=\nicefrac{c}{2}\ \left\{c=\frac{a+b}{2}\right\}
                    \end{equation*}
            \end{enumerate}
            Usando la relga de composición, tenemos demostrado nuestro triple.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    ¿Cuáles de los siguientes triples no son demostrables con la Lógica de Programas?
    (Considerando que $i,x,a \in \mathbb{Z}$)
    \begin{enumerate}
        \item $\{i > 0\} \quad i = i - 1; \quad \{i \geq 0\}$\\
            El siguiente triple sabemos que es cierto:
            \begin{equation*}
                \{i>0\}\ i=i-1\ \{i>-1\} 
            \end{equation*}
            $\{i>-1\}\rightarrow \{i\geq 0\}$, luego es cierto por la primera regla de la consecuencia.
        \item $\{x \geq 7\} \quad x = x + 3; \quad \{x \geq 9\}$\\
            El siguiente triple sabemos que es cierto:    
            \begin{equation*}
                \{x\geq 7\}\ x=x+3\ \{x\geq 10\}
            \end{equation*}
            $\{x\geq 10\}\rightarrow\{x\geq 9\}$, luego es cierto por la primera regla de la consecuencia.
        \item $\{i < 9\} \quad i = 2 \ast i + 1; \quad \{ i \leq 20\}$\\
            El siguiente triple sabemos que es cierto:
            \begin{equation*}
                \{i<9\}\ i=2\ast i+1\ \{i<19\}
            \end{equation*}
            $\{i<19\}\rightarrow\{i\leq 20\}$, luego es cierto por la primera regla de la consecuencia.
        \item $\{a > 0\} \quad a = a - 7; \quad \{a > -6\}$\\
            \begin{equation*}
                \{a>0\}\ a=a-7\ \{a>-7\}
            \end{equation*}
            Pero $\{a>-7\}\not\rightarrow\{a>-6\}$, luego este triple no es demostrable.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Si el triple $\{P\} C \{Q\}$ es demostrable, indicar por qué los siguientes triples también lo son (o no se pueden demostrar y por qué):
    \begin{enumerate}
        \item $\{P\} C \{Q \lor P\}$\\
           Es demostrable, ya que $\{Q\}\rightarrow\{Q \lor P\}$ y por la primera regla de la consecuencia, tomando $R=Q \lor P$:
            \begin{equation*}
                \dfrac{\{P\}C\{Q\}, \{Q\}\rightarrow\{R\}}{\{P\}C\{R\}}
            \end{equation*}
            Tenemos que se debilita la poscondición.

        \item $\{P \land D\} C \{Q\}$\\
            Es demostrable, ya que $\{P \land D\}\rightarrow\{P\}$ y por la segunda regla de la consecuencia, tomando $R = P \land D$:
            \begin{equation*}
                \dfrac{\{P\}\rightarrow\{R\},\{R\}C\{Q\}}{\{P\}C\{Q\}}
            \end{equation*}
            Tenemos que se fortalece la precondición.
        \item $\{P \lor D\} C \{Q\}$\\
            No es demostrable, porque se debilita la precondición.

        \item $\{P\} C \{Q \lor D\}$\\
            Al igual que hemos hecho en el apartado 1, es demostrable ya que ${\{Q\}\rightarrow\{Q \lor D\}}$ y usando la primera regla de la consecuencia.
        \item $\{P\} C \{Q \land P\}$\\
            No podemos demostrarlo, ya que se fortalece la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Si el triple $\{P\} C \{Q\}$ es demostrable, ¿cuál de los siguientes triples no se puede demostrar?
    \begin{enumerate}
        \item $\{P \land D\} C \{Q\}$\\
            Sabemos que $\{P \land D\}\rightarrow\{P\}$, luego puede demostrarse por la segunda regla de la consecuencia (se fortalece la precondición).
        \item $\{P \lor D\} C \{Q\}$\\
            No puede demostrarse, porque se debilita la precondición.
        \item $\{P\} C \{Q \lor D\}$\\
            Puede demostrarse mediante la primera regla de la consecuencia, ya que se tiene que ${\{Q\}\rightarrow\{Q \lor D\}}$.

        \item $\{P\} C \{Q \lor P\}$\\
        Puede demostrarse mediante la primera regla de la consecuencia, ya que se tiene que ${\{Q\}\rightarrow\{Q \lor P\}}$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Dado el siguiente programa, obtener:
    \begin{minted}{pascal}
        int x = 5, y = 2;
        cobegin
            < x = x + y >;
            < y = x * y >;
        coend
    \end{minted}
    \begin{enumerate}
        \item Valores finales de $x$ e $y$.
        Tenemos dos posibles trazas de ejecución:
        \begin{enumerate}
            \item Primero se ejecuta la primera instrucción, por lo que obtendríamos $x = 7$ y $y = 14$.
            \item Primero se ejecuta la segunda instrucción, por lo que obtendríamos $x = 15$ y $y = 10$.
        \end{enumerate}
        \item Valores finales de $x$ e $y$ si quitamos los símbolos \verb|< >| de instrucción atómica.
        
        Encontramos cada uno de los dos estados anteriores, además de $x = 7$ y $y= 10$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Comprobar si la demostración del siguiente triple interfiere con los teoremas siguientes:
    \[
        \{x \geq 2\} \quad < x = x - 2 > \quad \{x \geq 0\}
    \]
    Es decir, queremos comprobar si $R\equiv <x = x-2>$ con $pre(R) = \{x\geq 2\}$ interfiere con los triples siguientes:
    \begin{enumerate}
        \item $\{x \geq 0\} \quad < x = x + 3 > \quad \{x \geq 3\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 0 \land x \geq 2\}\ <x=x-2>\ \{x\geq 0\}
            \end{equation*}
            Este triple es correcto por la segunda regla de la consecuencia, luego no interfiere con la precondición.\\

            Comprobemos ahora su interferencia con la poscondición:
            \begin{equation*}
                \{x\geq 3 \land x \geq 2\}\ <x=x-2>\ \{x\geq 1\}
            \end{equation*}
            En este caso, $\{x\geq 1\}\not\rightarrow\{x\geq 3\}$, luego este triple no es demostrable y $R$ interfiere con la poscondición del triple en cuestión.

        \item $\{x \geq 0\} \quad < x = x + 3 > \quad \{x \geq 0\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 0 \land x \geq 2\}\ <x=x-2>\ \{x\geq 0\}
            \end{equation*}
            Este triple es correcto por la segunda regla de la consecuencia, luego no interfiere con la precondición.
            Además, como la precondición y la poscondición son iguales, $R$ tampoco interfiere con la poscondición, luego no interfiere con este triple.
        \item $\{x \geq 7\} \quad < x = x + 3 > \quad \{x \geq 10\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 7 \land x \geq 2\}\ <x=x-2>\ \{x\geq 5\}
            \end{equation*}
            No obstante, como $\{x\geq 5\}\not\rightarrow\{x\geq 7\}$, $R$ interfiere con la precondición de este triple.
        \item $\{y \geq 0\} \quad < y = y + 3 > \quad \{y \geq 3\}$\\
            $R$ no interfiere con este triple, ya que son variables disjuntas.
        \item $\{x \text{ es impar}\} \quad < y = x + 1 > \quad \{y \text{ es par}\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x \text{ es impar } \land x\geq 2\}\ <x=x-2>\ \{x \text{ es impar } \land x \geq 0\}
            \end{equation*}
            Por la $2^a$ regla de la consecuencia, como $\{x \text{ es impar } \land x \geq 0\} \rightarrow \{x \text{ es impar}\}$, tenemos que es correcto y $R$ no interfiere con la precondición.

            Comprobamos ahora su interferencia con la poscondición:
            \begin{equation*}
                \{y \text{ es par } \land x \geq 0\}\ <x=x-2>\ \{y \text{ es par } \land x \geq -2\}
            \end{equation*}
            Por la $2^a$ regla de la consecuencia, como $\{y \text{ es par } \land x \geq -2\} \rightarrow \{y \text{ es par}\}$, tenemos que es correcto y $R$ no interfiere con la poscondición. Por tanto, $R$ no interfiere con este triple.
            
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Dado el siguiente triple:
    \begin{gather*}
        \{x = 0\} \\
        \text{cobegin} \\
        <x = x + a> || <x = x + b> || <x = x + c> \\
        \text{coend} \\
        \{x = a + b + c\}
    \end{gather*}
    
    Demostrarlo utilizando la lógica de asertos para cada una de las tres instrucciones atómicas y después que se llega a la poscondición final $x = a + b + c$ utilizando para ello la regla \emph{de la composición concurrente} de instrucciones atómicas.\\

Inicialmente, demostraremos los $3$ siguientes triples, uno por cada instrucción atómica. Hemos de notar que, en cada uno de ellos, como no sabemos en qué orden se ejecutan, tenemos que incluir en las precondiciones y las poscondiciones todas las posibilidades.
\begin{enumerate}
    \item El correspondiente a la primera instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=b \lor x=c \lor x=b+c\}\ <x=x+a>\ \\ \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}
    \end{gather*}

    Mediante el axioma de asignación, tenemos que:
    \begin{gather*}
        \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}_{x+a}^a <x=x+a>\\ \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}
    \end{gather*}

    No obstante, de la definición de Sustitución Textual, tenemos:
    \begin{gather*}
        \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}_{x+a}^a \equiv \\
        \equiv \{x+a=a \lor x+a=a+b \lor x+a=a+c \lor x+a=a+b+c\} \equiv \\
        \equiv \{x=0 \lor x=b \lor x=c \lor x=b+c\}
    \end{gather*}

    Por tanto, el triple en cuestión es cierto.

    \item El correspondiente a la segunda instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=a \lor x=c \lor x=a+c\}\ <x=x+b>\ \\ \{x=b \lor x=a+b \lor x=b+c \lor x=a+b+c\}
    \end{gather*}

    Es cierto, y su demostración es análoga al primer caso.
    \item El correspondiente a la tercera instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=b \lor x=a \lor x=a+b\}\ <x=x+c>\ \\ \{x=c \lor x=a+c \lor x=b+c \lor x=a+b+c\}
    \end{gather*}
    Es cierto, y su demostración es análoga al primer caso.
\end{enumerate}

Seguidamente, tenemos que ver que dichos $3$ triples están libres de interferencias. Para ello, hemos de probar $12$ triples, ya que hay $3$ instrucciones atómicas, cada una de ellas con $2$ asertos, por lo que por cada instrucción hemos de comprobar $4$ asertos:
\begin{align*}
    &NI(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+a>)\\
    &NI(x=b \lor x=a+b \lor x=b+c \lor x=a+b+c, <x=x+a>)\\
    &NI(x=0 \lor x=b \lor x=a \lor x=a+b, <x=x+a>)\\
    &NI(x=c \lor x=a+c \lor x=b+c \lor x=a+b+c, <x=x+a>)\\ \\
    &NI(x=0 \lor x=b \lor x=c \lor x=b+c, <x=x+b>)\\
    &NI(x=a \lor x=a+b \lor x=a+c \lor x=a+b+c, <x=x+b>)\\
    &NI(x=0 \lor x=b \lor x=a \lor x=a+b, <x=x+b>)\\
    &NI(x=c \lor x=a+c \lor x=b+c \lor x=a+b+c, <x=x+b>)\\ \\
    &NI(x=0 \lor x=b \lor x=c \lor x=b+c, <x=x+c>)\\
    &NI(x=a \lor x=a+b \lor x=a+c \lor x=a+b+c, <x=x+c>)\\
    &NI(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+c>)\\
    &NI(x=b \lor x=a+b \lor x=b+c \lor x=a+b+c, <x=x+c>)\\
\end{align*}

Demostremos ahora el primero, ya que el resto son idénticos.
\begin{align*}
    NI&(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+a>)\equiv \\
    &\equiv \{(x=0 \lor x=a \lor x=c \lor x=a+c) \land (x=0 \lor x=b \lor x=c \lor x=b+c)\}\\&\qquad <x=x+a> \{x=0 \lor x=a \lor x=c \lor x=a+c\}\equiv \\
    &\equiv \{x=0 \lor x=c\} <x=x+a> \{x=0 \lor x=a \lor x=c \lor x=a+c\}
\end{align*}
Este triple efectivamente es cierto, lo cual se puede demostrar empleando en primer lugar el Axioma de Sustitución y, posteriormente, la primera regla de la consecuencia.\\

Por tanto, y tras aplicar la Regla de la Composición Concurrente, tenemos de forma directa que:
% // TODO: Añadir las conjunciones
\begin{gather*}
        \{x = 0\} \\
        \text{cobegin} \\
        <x = x + a> || <x = x + b> || <x = x + c> \\
        \text{coend} \\
        \{x = a + b + c\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    El siguiente triple:
    \begin{gather*}
        \{x=0 \land y = 0 \land z = 0\} \\
        <x = z + a> || <y = x+b> \\
        \{(x = a) \land (y = b \lor y = a +b) \land z = 0\}
    \end{gather*}
    \begin{enumerate}
        \item Es indemostrable salvo que se cumpla siempre que $a=0$.
        \item El triple anterior es demostrable para cualquier valor de las variables $a$ o $b$.
        \item Es indemostrable salvo que se cumpla siempre que $b = 0$.
        \item Es indemostrable salvo que se cumpla siempre que $a = 0 \land b = 0$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Suponer que $\{suma>1\}\ suma=suma+4\ \{suma>5\}$ es demostrable, entonces: ¿cuál de los siguientes triples es también demostrable? (indicar por qué)
    \begin{enumerate}
        \item $\{suma>2\}\ suma=suma+4\ \{suma>5\}$.\\
            Es demostrable, ya que $\{suma>2\}\rightarrow\{suma>1\}$ y podemos aplicar la segunda regla de la consecuencia.
        \item $\{suma\geq 1\}\ suma=suma+4\ \{suma > 5\}$.\\
            No es demostarble, ya que debilita la precondición.
        \item $\{suma>0\}\ suma=suma+4\ \{suma > 5\}$.\\
            No es demostarble, ya que debilita la precondición.
        \item $\{suma>1\}\ suma=suma+4\ \{suma > 6\}$.\\
            No es demostrable, ya que fortalece la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Suponer que $\{x<y\}\ C_1\ \{u<v\}$ es demostrable, entonces: ¿cuáles de los siguientes triples son también demostrables? (indicar por qué)
    \begin{enumerate}
        \item $\{x\leq y\}\ C_1\ \{u<v\}$.\\
            No es demostrable, ya que debilita la precondición.
        \item $\{x\leq y-2\}\ C_1\ \{u<v\}$.\\
            Es demostrable, ya que $\{x\leq y-2\}\rightarrow\{x+2\leq y\}\rightarrow\{x<y\}$, y mediante la segunda regla de la consecuencia se tiene que es cierto.
        \item $\{x\leq y\}\ C_1\ \{u\leq v\}$.\\
            El triple $\{x<y\}\ C_1\ \{u\leq v\}$ sí que es demostrable ya que relaja la poscondición, pero el triple que se nos dice no es demostrable, ya que también relaja la precondición.
            Como además no tenemos relación entre $x$ y $u$ ni entre $y$ y $v$, no podemos inferir nada.
        \item $\{x<y\}\ C_1\ \{u<v-2\}$.\\
            No es demostrable, ya que fortalecemos la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Seleccionar el valor correcto de las 2 variables ($x$ e $y$) después de ejecutarse el siguiente programa concurrente:
    \begin{minted}{pascal}
        int x=5, y=2;
        cobegin <x=x+y>; <y=x*y>; <x=x-y>; coend;
    \end{minted}
    \begin{enumerate}[label=(\alph*)]
        \item $x=7$ y $y=14$.
        \item $x=5$ y $y=10$.
        \item $x=-7$ y $y=14$.
        \item $x=-3$ y $y=10$.
    \end{enumerate}

    Numeramos las instrucciones atómicas de la siguiente forma:
    \begin{enumerate}
        \item \verb|<x=x+y>|
        \item \verb|<y=x*y>|
        \item \verb|<x=x-y>|
    \end{enumerate}

    Veamos ahora, en función del orden de ejecución, cuál sería el valor de las variables $x$ e $y$:
    \begin{itemize}
        \item \ul{1, 2, 3}: $x=-7$ y $y=14$.
        \item \ul{1, 3, 2}: $x=5$ y $y=10$.
        \item \ul{3, 1, 2}: $x=5$ y $y=10$.
        \item \ul{2, 1, 3}: $x=5$ y $y=10$.
        \item \ul{2, 3, 1}: $x=5$ y $y=10$.
        \item \ul{3, 2, 1}: $x=9$ y $y=6$.
    \end{itemize}

    Por tanto, las respuestas $b$ y $c$ son correctas.
    % // TODO: Lo ha hecho Arturo. Revisar JJ
\end{ejercicio}

\begin{ejercicio}
    El siguiente código concurrente no puede ser demostrado directamente con la lógica de aserciones (pre y poscondiciones). Elegir la respuesta que explica correctamente la razón de que ocurra esto.
    \begin{minted}{pascal}
        {x=0} cobegin <x=x+a>; <x=x+a> coend; {x=2*a}
        (a es un valor entero positivo)
    \end{minted}
    \begin{enumerate}[label=(\alph*)]
        \item Porque la poscondición que se propone $\{x=2\ast a\}$ es falsa.
        \item Porque falta incluir la posibilidad de que el valor final de $x$ sea también ${\{x=a\}}$.
        \item Porque al aplicar directamente la regla de inferencia de la \textit{composición concurrente} utilizo unas condiciones (pre y post-condiciones) demasiado débiles.
        \item Porque tengo que incluir en los asertos el valor del contador de programa de cada procesador.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
   Estudiar cuáles son los valores finales de las variables \verb|x| e \verb|y| en el siguiente programa. Insertar los asertos adecuados entre llaves, antes y después de cada sentencia, para poder obtener una traza de demostración del programa, que incluya en su último aserto los valores finales de las variables. 
   \begin{minted}{c++}
       int x = c1;
       int y = c2;
       x = x + y;
       y = x * y;
       x = x - y;
   \end{minted}

   Tenemos que cada triple, por orden, es:
   \begin{gather*}
       \{x = c_1 \land y = c_2\}\\
       x = x + y \\
       \{x = c_1 + c_2 \land y =c_2\} \\
       y = x * y \\
       \{x = c_1 + c_2 \land y = (c_1 + c_2)\cdot c_2 \} \\
       x = x - y \\
       \{x = (c_1 + c_2) - (c_1 + c_2)\cdot c_2 = (c_1 + c_2)\cdot (1-c_2) \land y = (c_1 + c_2)\cdot c_2 \}
   \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar que el siguiente triple es cierto:
    \begin{gather*}
        \{x=0\}\\ 
        \texttt{cobegin} \\
        <x=x+1> || <x=x+2> || <x=x+4> \\
        \texttt{coend} \\
        \{x=7\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Dada la siguiente construcción de composición concurrente \verb|P|:
    \begin{gather*}
        \texttt{cobegin} \\
        <x=x-1>;<x=x+1>;||<y=y-1>;<y=y+1>; \\
        \texttt{coend} \\
    \end{gather*}
    demostrar que se cumple la invarianza de $\{x=y\}$, es decir, que $\{x=y\}\ P\ \{x=y\}$ es un triple cierto.\\

Para ello, comenzamos demostrando los triples:
\begin{gather*}
    \{x=y\}\ x=x-1;x=x+1;\ \{x=y\} \\
    \{x=y\}\ y=y-1;y=y+1;\ \{x=y\} \\
\end{gather*}
\begin{enumerate}
    \item 
        \begin{gather*}
            \{x=y\}\ x=x-1\ \{x+1=y\} \\
            \{x+1=y\}\ x=x+1\ \{x=y\}
        \end{gather*}
        y usamos la regla de la composición.
    \item 
        \begin{gather*}
            \{y=x\}\ y=y-1\ \{y+1=x\} \\
            \{y+1=x\}\ y=y+1\ \{y=x\}
        \end{gather*}
        y usamos la regla de la composición.
\end{enumerate}
Ahora, los triples son libres de interferencia, por tener variables disjuntas. Podemos aplicar por tanto la regla de la composición concurrente, llegando a que:
\begin{gather*}
    \{x=y\} \\
    \texttt{cobegin} \\
    <x=x-1>;<x=x+1>;||<y=y-1>;<y=y+1>; \\
    \texttt{coend} \\
    \{x=y\}
\end{gather*}
Que era lo que queríamos probar.
\end{ejercicio}

\begin{ejercicio}
    Usando la regla de la conjunción, demostrar que 
    \begin{equation*}
        \{i>2\}\ i=2\ast i\ \{i>4\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Se dan los siguientes triples de Hoare:
    \begin{gather*}
        \{j>1\}\ i=i+2;\ j=j+3;\ \{j>4\} \\
        \{i>2\}\ i=i+2;\ j=j+3;\ \{i>4\}
    \end{gather*}
    Demostrar que estos triples implican que
    \begin{equation*}
        \{j>1 \land i>2\}\ i=i+2;\ j=j+3\ \{j>4 \land i>4\}
    \end{equation*}
    ¿Qué regla se debe utilizar para la demostración?
\end{ejercicio}

\begin{ejercicio}
    Sean $A$ y $B$ los valores iniciales de $a$ y $b$ respectivamente. Escribir un fragmento de código que tenga $\{a=A+B \land b =A-B\}$ como poscondición y demostrar que el código es correcto.
\end{ejercicio}

\begin{ejercicio}
    Demostrar que la siguiente sentencia tiene la poscondición ${\{x\geq 0, x^2\geq a^2\}}$.
    \verb|if a > 0 then x = a else x = -a|. Es decir, probar el triple:
    \begin{equation*}
        \{V\}\ \texttt{if a >\ 0 then x = a else x = -a}\ \{x\geq 0, x^2\geq a^2\}
    \end{equation*}~\\
    Para ello, tenemos que usar la regla del \verb|if|:
    \begin{equation*}
        \dfrac{\{P\land B\}S_1\{Q\}, \{P\land \lnot B\}S_2\{Q\}}{\{P\}\ \texttt{if B then}\ S_1\ \texttt{else}\ S_2\ \{Q\}}
    \end{equation*}
    Luego bastará con probar los triples
    \begin{gather*}
        \{a>0\} \equiv \{V \land a > 0\}\ x=a\ \{x\geq 0 \land x^2\geq a^2\} \\
        \{a\leq 0\} \equiv \{V \land a \leq 0\}\ x=-a\ \{x\geq 0 \land x^2\geq a^2\}
    \end{gather*}
    \begin{enumerate}
        \item Usando el axioma de asignación:
            \begin{equation*}
                \{a \geq 0\} \equiv \{a \geq 0 \land a^2 \geq a^2\} \equiv \{x\geq 0 \land x^2\geq a^2\}^x_{a}\ x=a\ \{x\geq 0 \land x^2\geq a^2\}
            \end{equation*}
            Como $\{a>0\}\rightarrow\{a\geq 0\}$, usamos la segunda regla de la consecuencia y tenemos el primer triple demostrado.
        \item Usando el axioma de asignación:
            \begin{equation*}
                \{a \leq 0\} \equiv \{-a \geq 0 \land a^2 \geq a^2\} \equiv \{x\geq 0 \land x^2\geq a^2\}^x_{-a}\ x=-a\ \{x\geq 0 \land x^2\geq a^2\}
            \end{equation*}
    \end{enumerate}
    Y acabamos de probar el triple que nos pedía el ejercicio.
\end{ejercicio}

\begin{ejercicio}
    El siguiente fragmento de código tiene $\{P\}\equiv \left\{sum = \frac{j(j-1)}{2}\right\}$ como precondición y poscondición. Demostrar que es verdadero:
    \begin{equation*}
        \{P\}\ sum=sum+j;\ j=j+1;\ \{P\}
    \end{equation*}~\\

    Queremos demostrar el triple:
    \begin{equation*}
        \left\{sum=\frac{j(j-1)}{2} \right\}\ sum=sum+j;\ j=j+1;\ \left\{sum=\frac{j(j-1)}{2}\right\}
    \end{equation*}
    Para ello, será suficiente con demostrar los triples
    \begin{gather*}
        \left\{sum = \frac{j(j-1)}{2} \right\}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \right\} \\
        \left\{sum = \frac{(j+1)j}{2} \right\}\ j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
    \end{gather*}
    y aplicar la regla de composición.

    \begin{enumerate}
        \item Para demostrar el primer triple, usamos el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \right\}^{sum}_{sum+j}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \right\} 
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{(j+1)j}{2} \right\}^{sum}_{sum+j} \equiv \left\{sum+j = \frac{(j+1)j}{2} \right\} \equiv \\ 
                \equiv \left\{sum = \frac{(j+1)j}{2}-j \right\} \equiv \left\{sum = \frac{j(j-1)}{2} \right\}
            \end{gather*}
        \item Para el segundo, usamos también el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} \equiv \left\{sum = \frac{(j+1)(j+1-1)}{2}\right\} \equiv \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{gather*}
    \end{enumerate}
    Por lo que el triple del enunciado es cierto.

\end{ejercicio}

\begin{ejercicio}
    Demostrar que
    \begin{equation*}
        \{i\ast j + 2 \ast j + 3\ast i = 0\}\ j=j+3;\ i=i+2;\ \{i\ast j=6\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    ¿Por qué en la regla del \verb|while B|, la condición \verb|B| debe ser verdadera al comienzo del bucle?
\end{ejercicio}

\begin{ejercicio}
    Considerar una función con dos argumentos que se usa en un programa. Explicar por qué el uso de alias puede ser un problema en este caso.
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente fragmento de programa:
    \begin{gather*}
        sum = 0;  \\
        j = 1; \\
        \texttt{while}(j\ != c) \texttt{do begin}\\
          sum = sum + j;\\
          j = j + 1;\\
          \texttt{end}\\
        \{sum = c*(c-1)/2\}
    \end{gather*}~\\

    Para ello, tenemos que hacer uso de la regla de la iteración: 
    \begin{equation*}
        \dfrac{\{I\land B\}S\{I\}}{\{I\}\ \texttt{while B do}\ S\ \texttt{end do}\ \{I\land \lnot B\}}
    \end{equation*}
    Luego tendremos que probar que se cumple el triple
    \begin{equation*}
        \left\{sum=\frac{j(j-1)}{2} \land j\neq c\right\}\ sum=sum+j;j=j+1;\ \left\{sum=\frac{j(j-1)}{2}\right\}
    \end{equation*}
    Para ello, será suficiente con demostrar los triples
    \begin{gather*}
        \left\{sum = \frac{j(j-1)}{2} \land j\neq c\right\}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} \\
        \left\{sum = \frac{(j+1)j}{2} \land j\neq c\right\}\ j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
    \end{gather*}
    y aplicar la regla de composición.

    \begin{enumerate}
        \item Para demostrar el primer triple, usamos el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\}^{sum}_{sum+j}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} 
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\}^{sum}_{sum+j} \equiv \left\{sum+j = \frac{(j+1)j}{2} \land j \neq c\right\} \equiv \\ 
                \equiv \left\{sum = \frac{(j+1)j}{2}-j \land j \neq c\right\} \equiv \left\{sum = \frac{j(j-1)}{2} \land j \neq c\right\}
            \end{gather*}
        \item Para el segundo, usamos también el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} \equiv \left\{sum = \frac{(j+1)(j+1-1)}{2}\right\} \equiv \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{gather*}
            y como:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} \rightarrow \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{equation*}
            tenemos el segundo triple, usando la segunda regla de la consecuencia.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección del siguiente triple:
    \begin{equation*}
        \{a[i]\geq 0\}\ a[i]=a[i]+a[j];\ \{a[i]\geq a[j]\}
    \end{equation*}

    Para ello, basta aplicar el axioma de la asignación:
    \begin{equation*}
        \{a[i]\geq a[j]\}_{a[i]+a[j]}^{a[i]}\ a[i]=a[i]+a[j];\ \{a[i]\geq a[j]\}
    \end{equation*}
    \begin{equation*}
        \{a[i]\geq a[j]\}_{a[i]+a[j]}^{a[i]}\ \equiv \{a[i]+a[j]\geq a[j]\} \equiv \{a[i] \geq 0\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Verificar el siguiente segmento de programa:
    \begin{gather*}
        \{n\geq 0\}\\ 
        i = 1;\\
        \texttt{while\ } i\leq n \texttt{\ do\ begin}\\
        a[i] = b[i]; \\
        i=i+1;\\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (a[i]=b[i])\right\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    El siguiente fragmento de programa calcula $\displaystyle\sum_{i=1}^{n} i!$. Demostrar que es correcto.
    \begin{minted}{pascal}
        i = 1; sum = 0; f = 1;
        while i <> n+1 do begin
          sum = sum + f;
          i = i + 1;
          f = f * 1;
        end
    \end{minted}
\end{ejercicio}

\begin{ejercicio}
    Hallar la precondición $\{P\}$ que hace que el siguiente triple sea correcto:
    \begin{equation*}
        \{P\}\ a[i]=2\ast b;\ \{j\leq i \land k < i \land a[i] + a[j-1]+a[k]>b\}
    \end{equation*}
    Para ello, basta aplicar el axioma de asignación:
    \begin{gather*}
        \{j\leq i \land k < i \land a[i] + a[j-1]+a[k]>b\}_{2\cdot b}^{a[i]} a[i]=2\ast b;\\ \{j\leq i \land k < i \land a[i] + a[j-1]+a[k]>b\}
    \end{gather*}
    \begin{gather*}
        \{j\leq i \land k < i \land a[i] + a[j-1]+a[k]>b\}_{2\cdot b}^{a[i]} \equiv \\ \equiv \{j\leq i \land k < i \land 2\cdot b + a[j-1]+a[k]>b\}
    \end{gather*}
    Luego estamos buscando la precondición:
    \begin{equation*}
        \{P\} \equiv \{j\leq i \land k < i \land 2\cdot b + a[j-1]+a[k]>b\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar que para $n>0$ el siguiente fragmento de programa termina.
    \begin{minted}{pascal}
        i = 1; f = 1;
        while i <> n do begin
          i = i + 1;
          f = f * r;
        end
    \end{minted}
\end{ejercicio}

\begin{ejercicio}
    Hallar la precondición de la terna:
    \begin{equation*}
        \{P\}\ a[i]=b;\ \{a[j] = 2\ast a[i]\}
    \end{equation*}
    Para ello, simplemente aplicamos el axioma de asignación:
    \begin{equation*}
        \{a[j]=2\ast b\} \equiv \{a[j]=2\ast a[i]\}_{b}^{a[i]}\ a[i]=b;\ \{a[j] = 2\ast a[i]\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Para cada uno de los siguientes fragmentos de código, obtener la poscondición apropiada:
    \begin{enumerate}[label=(\alph*)]
        \item $\{i<10\}\ i=2\ast i+1;$.\\
            La poscondición es $\{i<21\}$:
            \begin{equation*}
                \{i<10\}\ i=2\ast i+1; \{i<21\}
            \end{equation*}
            que puede demostrarse aplicando el axioma de asignación.
        \item $\{i>0\}\ i=i-1;$.\\
            La poscondición es $\{i>-1\}$:
            \begin{equation*}
                \{i>0\}\ i=i-1; \{i>-1\}
            \end{equation*}
            que puede demostrarse aplicando el axioma de asignación.
        \item $\{i>j\}\ i=i+1;\ j=j+1;$.\\
            La poscondición es $\{i>j\}$:
            \begin{gather*}
                \{i>j\}\ i=i+1;\ \{i>j+1\} \\
                \{i>j+1\}\ j=j+1;\ \{i>j\}
            \end{gather*}
            ambos pueden demostrarse aplicando el axioma de asignación y finalmente tenemos que:
            \begin{equation*}
                \{i>j\}\ i=i+1;\ j=j+1;\ \{i>j\}
            \end{equation*}
            aplicando la regla de composición.
        \item $\{V\}\ i=3;\ j=2\ast i$.\\
            La poscondición es $\{i=3 \land j=6\}$:
            \begin{gather*}
                \{V\}\ i=3;\ \{i=3\} \\
                \{i=3\}\ j=2\ast i;\ \{i=3 \land j = 6\}
            \end{gather*}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Para cada uno de los siguientes fragmentos de código, obtener las precondiciones apropiadas.
    \begin{enumerate}[label=(\alph*)]
        \item $i=3\ast k;\ \{i>6\}$.\\
            Aplicando el axioma de asignación:
            \begin{equation*}
                \{k>2\} \equiv \{3\cdot k>6\} \equiv \{i>6\}^i_{3\cdot k}\ i=3\ast k;\ \{i>6\}
            \end{equation*}
            obtenemos que la precondición es $\{k>2\}$.
        \item $a=b\ast c;\ \{a=1\}$.\\
            Aplicando el axioma de asignación:
            \begin{equation*}
                \{b = c^{-1}\} \equiv \{b\cdot c = 1\} \equiv \{a=1\}^a_{b\cdot c}\ a=b\ast c;\ \{a=1\}
            \end{equation*}
        La precondición es $\{b=c^{-1}\}$.
        \item $b=c-2;\ a=a/b;$\footnote{Esto es lo que pone en la relación, falta la poscondición para poder hacerse.}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Verificar el siguiente código. Indicar todas las reglas usadas.
    \begin{equation*}
        \{y>0\}\ xa=x+y;\ xb=x-y;
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Verificar el siguiente código, indicando todas las reglas usadas.
    \begin{equation*}
        \{V\}\ if\ x < 0\ then\ x = -x\ \{x\geq 0\}
    \end{equation*}
    Para comenzar, probamos que $\{x<0\}\ x=-x;\ \{x\geq 0\}$ usando el axioma de asignación:
    \begin{equation*}
        \{x<0\} \equiv \{-x\geq 0\} \equiv \{x\geq 0\}^x_{-x}\ x=-x;\ \{x\geq 0\}
    \end{equation*}
    Posteriormente, como sabemos que $\{V \land x<0\}\equiv \{x<0\}$ y que ${\{x\geq 0\}\ null\ \{x\geq 0\}}$ por el axioma de la sentencia nula, podemos aplicar la regla del \texttt{if}:
    \begin{equation*}
        \dfrac{\{V \land x<0\}\ x=-x;\ \{x\geq 0\}, \{V \land x\geq 0\}\ null\ \{x\geq 0\}}{\{V\}\ \texttt{if\ }x<0 \texttt{\ then\ }x=-x \texttt{\ else\ null\ } \{x\geq 0\}}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}\label{ej_rel1_44}
    Verificar el siguiente segmento de programa:
    \begin{gather*}
        max = a[1]; i = 1; \\
        \texttt{while\ } i <> n+1 \texttt{\ do\ begin} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i];\\
        i=i+1; \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (max \geq a[i])\right\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código:
    \begin{gather*}
        max = a[1]; i = 1; \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i +1; \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i]; \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (max \geq a[i]), \bigvee_{j=1}^n (max = a[i]) \right\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código:
    \begin{gather*}
        i = 0; j= n; \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i + 1; \\
        j = j - 1; \\
        a[i] = b[j] \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n(a[i] = b[n-i])\right\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código:
    \begin{minted}{pascal}
        i = 0;
        s = 0;
        while i <= n do begin
          s = s + a[i];
          a[i] = s;
          i = i + 1;
        end
    \end{minted}
\end{ejercicio}

\begin{ejercicio}
    Dados $n\geq 0$, $i\leq n$, demostrar que el siguiente segmento de progama evalúa
    \begin{equation*}
        \dfrac{n!}{i!(n-i)!}
    \end{equation*}
    \begin{minted}{pascal}
        k = 0; fact = 1;
        while k <> n do begin
          k = k + 1;
          fact = fact * k;
          if k <= i then afact = fact;
          if k <= n-i then bfact = fact;
        end
        bcof = fact/(afact*bfact);
    \end{minted}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la terminación del fragmento de programa dado en el problema~\ref{ej_rel1_44} ¿Qué condición se debe imponer para realizar la demostración?
\end{ejercicio}
