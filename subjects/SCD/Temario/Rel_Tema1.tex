\section{Introducción}

\begin{ejercicio}
    Considerar el siguiente fragmento de programa para 2 procesos \verb|P1| y \verb|P2|: Los dos procesos
    pueden ejecutarse a cualquier velocidad. ¿Cuáles son los posibles valores resultantes para la
    variable \verb|x|? Suponer que \verb|x| debe ser cargada en un registro para incrementarse y que cada
    proceso usa un registro diferente para realizar el incremento.
    \setlength{\columnsep}{2cm} % Ajusta el espacio entre columnas
    \begin{multicols}{2}
        \begin{minted}{pascal}
        {variables compartidas}
        var x : integer := 0 ;
        Process P1;
        var i: integer;
        begin
          begin
            for i:= 1 to 2 do begin
              x:= x + 1;
            end
          end
        end
        \end{minted}
        
        \begin{minted}{pascal}
            

        Process P2;
        var j: integer;
        begin
          begin
            for j:= 1 to 2 do begin
              x:= x + 1;
            end
          end
        end
        \end{minted}
    \end{multicols}

Observando el código, cada proceso hace 2 lecturas y dos escrituras (incrementos) en \verb|x|.
\begin{itemize}
    \item Como cada proceso aumenta dos veces el valor de \verb|x|, el valor de \verb|x| ha de ser, como mínimo, $2$.
    \item Como en total se hacen 4 incrementos, el valor de \verb|x| ha de ser $4$ como máximo.
\end{itemize}

Notando por $l_{ij}$ a la $j$-ésima lectura del proceso $i$ y por $e_{ij}$ a la $j$-ésima escritura del proceso $i$, ambas referidas a la variable \verb|x|, podemos obtener cualquiera de las siguientes trazas de ejecución:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c||c|c|c||c|c|c||c|c|c|}
    \hline
    \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| & \verb|P1| & \verb|P2| & \verb|x| \\
    \hline
    \hline
    $l_{11}$ & - & 0 & $l_{11}$ & - & 0 & $l_{11}$ & - & 0 & $l_{11}$ & - & 0 \\
    \hline
    $e_{11}$ & - & 1 & - & $l_{21}$ & 0 & $e_{11}$ & - & 1 & - & $l_{21}$ & 0 \\
    \hline
    - & $l_{21}$ & 1 & $e_{11}$ & - & 1 & - & $l_{21}$ & 1 & $e_{11}$ & - & 1 \\
    \hline
    - & $e_{21}$ & 2 & - & $e_{21}$ & 1 & - & $e_{21}$ & 2 & - & $e_{21}$ & 1 \\
    \hline
    $l_{12}$ & - & 2 & $l_{12}$ & - & 1 & $l_{12}$ & - & 2 & $l_{12}$ & - & 1 \\
    \hline
    $e_{12}$ & - & 3 & $e_{12}$ & - & 2 & - & $l_{22}$ & 2 & - & $l_{22}$ & 1 \\
    \hline
    - & $l_{22}$ & 3 & - & $l_{22}$ & 2 & $e_{12}$ & - & 3 & $e_{12}$ & - & 2 \\
    \hline
    - & $e_{22}$ & 4 & - & $e_{22}$ & 3 & - & $e_{22}$ & 3 & - & $e_{22}$ & 2  \\
    \hline
\end{tabular}
\end{table}

Luego los posibles valores resultantes para \verb|x| son: 2, 3 y 4.

\end{ejercicio}


\begin{ejercicio}
    ¿Cómo se podría hacer la copia del fichero \verb|f| en otro \verb|g|, de forma concurrente, utilizando la
    instrucción concurrente \verb|cobegin-coend|? Para ello, suponer que:
    \begin{enumerate}
        \item Los archivos son una secuencia de items de un tipo arbitrario \verb|T|, y se encuentran ya abiertos
        para lectura (\verb|f|) y escritura (\verb|g|). Para leer un ítem de \verb|f| se usa la llamada a función \verb|leer(f)| y
        para saber si se han leído todos los ítems de \verb|f|, se puede usar la llamada \verb|fin(f)| que devuelve
        verdadero si ha habido al menos un intento de leer cuando ya no quedan datos. Para
        escribir un dato \verb|x| en \verb|g| se puede usar la llamada a procedimiento \verb|escribir(g,x)|.

        \item El orden de los items escritos en \verb|g| debe coincidir con el de \verb|f|.
        \item Dos accesos a dos archivos distintos pueden solaparse en el tiempo.
    \end{enumerate}~\\

\noindent
La copia del fichero \verb|f| en el fichero \verb|g| se podría realizar siguiendo el paradigma productor/consumidor que hemos visto en teoría en el Tema 1, mediante el uso de dos procesos:
\begin{itemize}
    \item Uno que lea un ítem del fichero \verb|f| y lo escriba en una variable compartida.
    \item Otro que lea dicha variable compartida y escriba el ítem en el fichero \verb|g|.
\end{itemize}
En dicho código, debemos garantizar que:
\begin{itemize}
    \item El consumidor no lea la variable antes de que el productor escriba en ella.
    \item En la segunda escritura del productor, debemos esperar a que antes la haya leído el consumidor.
    \item En la segunda lectura del consumidor, debemos esperar a que antes haya modificado la variable el productor.
\end{itemize}
Siguiendo estos pasos, obtendríamos un código como el siguiente:
\begin{minted}{pascal}
    process CopiaFicheros ;
    var ant, sig : T ;
    begin
      sig = leer(f) ;
      while not fin(f) do begin
        ant = sig ;
        cobegin
          escribir(g, ant) ;
          sig = leer(f) ;
        coend
      end
    end
\end{minted}


\end{ejercicio}

\begin{ejercicio}\label{ej:3}
    Construir, utilizando las instrucciones concurrentes \verb|cobegin-coend| y \verb|fork-join|, programas concurrentes que se correspondan con los grafos de precedencia que se muestran en la figura~\ref{fig:grafoEj3}.
    \begin{figure}
        \centering
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=0.5cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left =of P0] (P1) {P1};
                    \node[node, below right =of P0] (P2) {P2};
                    \node[node, below =of P1] (P3) {P3};
                    \node[node, below left =of P3] (P4) {P4};
                    \node[node, below right =of P3] (P5) {P5};
                    \node[node, below =of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P3) -- (P4);
                    \draw[edge] (P3) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge, bend left] (P2) to (P6);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.1}.}
            \label{fig:grafoEj3.1}
            
        \end{subfigure}
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left =of P0] (P1) {P1};
                    \node[node, below right =of P0] (P2) {P2};
                    \node[node, below =of P1] (P3) {P3};
                    \node[node, below left =of P1] (P4) {P4};
                    \node[node, below right =of P1] (P5) {P5};
                    \node[node, below =of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P1) -- (P4);
                    \draw[edge] (P1) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge, bend left] (P2) to (P6);
                    \draw[edge, bend right] (P3) to (P6);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.2}.}
            \label{fig:grafoEj3.2}
            
        \end{subfigure}
        \begin{subfigure}{0.3\textwidth}
            \centering
            \resizebox{\linewidth}{!}{
                \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
        
                    % Nodos
                    \node[node] (P0) {P0};
                    \node[node, below left =of P0] (P1) {P1};
                    \node[node, below right =of P0] (P2) {P2};
                    \node[node, below =of P1] (P3) {P3};
                    \node[node, below left =of P3] (P4) {P4};
                    \node[node, below right =of P3] (P5) {P5};
                    \node[node, below =of P5] (P6) {P6};
        
                    % Aristas
                    \draw[edge] (P0) -- (P1);
                    \draw[edge] (P0) -- (P2);
                    \draw[edge] (P1) -- (P3);
                    \draw[edge] (P3) -- (P4);
                    \draw[edge] (P3) -- (P5);
                    \draw[edge, bend right] (P4) to (P6);
                    \draw[edge] (P5) -- (P6);
                    \draw[edge] (P2) to (P5);
                
                \end{tikzpicture}
            }
            \caption{DAG del apartado~\ref{ej:3.3}.}
            \label{fig:grafoEj3.3}
            
        \end{subfigure}
        \caption{Grafos de precedencia del ejercicio~\ref{ej:3}.}
        \label{fig:grafoEj3}
    \end{figure}


    \begin{enumerate}
        \item \label{ej:3.1}
         Grafo de precedencia de la figura~\ref{fig:grafoEj3.1}:

         \begin{figure}[H]
             \centering
             \begin{subfigure}[b]{0.45\textwidth}
                \centering
                 \begin{minted}{pascal}
                     begin
                       P0;
                       fork P2; P1;
                       P3;
                       fork P5; P4;
                       join P2; join P5;
                       P6;
                     end
                 \end{minted}
             \end{subfigure}\hfill
             \begin{subfigure}[b]{0.45\textwidth}
                \centering
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         P2;
                         begin
                           P1;
                           P3;
                           cobegin P4; P5; coend
                         end
                       coend
                       P6;
                     end
                 \end{minted}
             \end{subfigure}
         \end{figure}
                 
        \item \label{ej:3.2}
        Grafo de precedencia de la figura~\ref{fig:grafoEj3.2}:
        \begin{figure}[H]
            \centering
            \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \begin{minted}{pascal}
                begin
                  P0;
                  fork P2; P1;
                  fork P5; fork P3; P4;
                  join P2; join P5; join P3;
                  P6;
                end
                \end{minted}
            \end{subfigure}\hfill
            \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \begin{minted}{pascal}
                begin
                  P0;
                  cobegin
                    P2;
                    begin
                      P1;
                      cobegin P4; P3; P5; coend
                    end
                  coend
                  P6;
                end
                \end{minted}
            \end{subfigure}
        \end{figure}
        
         \item \label{ej:3.3}
         Grafo de precedencia de la figura~\ref{fig:grafoEj3.3}:
         \begin{minted}{pascal}
         begin
           P0;
           fork P2; P1;
           P3;
           fork P4; join P2; P5;
           join P4;
           P6;
         end
         \end{minted}

         Sin embargo, no podemos hacer al 100\% el DAG de la figura~\ref{fig:grafoEj3.3}, ya que tras \verb|P3| debemos crear una estructura \verb|cobegin-coend|. Sin embargo, este debe esperar a \verb|P2|, por lo que la estructura \verb|cobegin-coend| tendrá que esperar a \verb|P2|, pero es que \verb|P4| no necesita que \verb|P2| termine. 

         Por tanto, no se puede programar con creación de hebras de forma estructurada. Sin embargo, podemos ofrecer dos soluciones, cada una que impone algo que el grafo no nos dice:
         \begin{enumerate}
             \item Si obligamos a que \verb|P4| también espere a \verb|P2|, obtendríamos el código:
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         P2;
                         begin
                           P1; P3;
                         end
                       coend
                       cobegin P4; P5; coend
                       P6;
                     end
                 \end{minted}
                 
             \item Si ahora queremos ejecutar de forma concurrente el flujo que tiene a \verb|P1|, \verb|P3| y \verb|P4| con el flujo que tiene a \verb|P2|, entonces obligamos a que \verb|P5| espere a \verb|P4| (que no nos lo especifica el DAG, pero lo necesitamos para poder programarlo de forma estructurada):
                 \begin{minted}{pascal}
                     begin
                       P0;
                       cobegin
                         begin P1; P3; P4; end
                         P2;
                       coend
                       P5;
                       P6;
                     end
                 \end{minted}
                 
         \end{enumerate}
    \end{enumerate}

\end{ejercicio}



\begin{ejercicio} \label{ej:4}
    Dados los siguientes fragmentos de programas concurrentes, obtener sus grafos de precedencia asociados:
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                begin
                    P0 ;
                    cobegin
                        P1 ;
                        P2 ;
                        cobegin
                            P3 ; P4 ; P5 ; P6 ;
                        coend ;
                        P7 ;
                    coend
                    P8 ;
                end
            \end{minted}
            \caption{Programa 1.}
            \label{code:prog1_Ej4}
        \end{subfigure}\hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                begin
                    P0 ;
                    cobegin
                        begin
                            cobegin
                                P1 ; P2 ;
                            coend
                            P5 ;
                        end
                        begin
                            cobegin
                                P3 ; P4 ;
                            coend
                            P6 ;
                        end
                    coend
                    P7 ;
                end
            \end{minted}
            \caption{Programa 2.}
            \label{code:prog2_Ej4}
        \end{subfigure}
        \caption{Programas concurrentes del ejercicio~\ref{ej:4}.}
    \end{figure}
    
    \begin{enumerate}
        \item Programa de la figura~\ref{code:prog1_Ej4}.

            \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    node/.style={circle, draw, minimum size=1cm},
                    edge/.style={-stealth}
                    ]
                \node[node] (P0) {P0};
                \node[node, below =of P0] (P4) {P4};
                \node[node, left =of P4] (P3) {P3};
                \node[node, left =of P3] (P2) {P2};
                \node[node, left =of P2] (P1) {P1};
                \node[node, right =of P4] (P5) {P5};
                \node[node, right =of P5] (P6) {P6};
                \node[node, right =of P6] (P7) {P7};
                \node[node, below =of P4] (P8) {P8};

                \draw[edge] (P0) -- (P1);
                \draw[edge] (P0) -- (P2);
                \draw[edge] (P0) -- (P3);
                \draw[edge] (P0) -- (P4);
                \draw[edge] (P0) -- (P5);
                \draw[edge] (P0) -- (P6);
                \draw[edge] (P0) -- (P7);

                \draw[edge] (P1) -- (P8);
                \draw[edge] (P2) -- (P8);
                \draw[edge] (P3) -- (P8);
                \draw[edge] (P4) -- (P8);
                \draw[edge] (P5) -- (P8);
                \draw[edge] (P6) -- (P8);
                \draw[edge] (P7) -- (P8);
            \end{tikzpicture}
            \caption{DAG para la figura~\ref{code:prog1_Ej4}.}
            \end{figure}
        \item Programa de la figura~\ref{code:prog2_Ej4}.
            \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node/.style={circle, draw, minimum size=1cm},
                                edge/.style={-stealth}]
                \node[node] (P0) {P0};
                \node[node, below left =of P0] (P2) {P2};
                \node[node, left =of P2] (P1) {P1};
                \node[node, below right =of P0] (P3) {P3};
                \node[node, right =of P3] (P4) {P4};
                \node[node, below right =of P1] (P5) {P5};
                \node[node, below left =of P4] (P6) {P6};

                \node[below =of P0] (A) {};
                \node[below =of A] (B) {};
                \node[node, below =of B] (P7) {P7};
                
                \draw[edge] (P0) -- (P1);
                \draw[edge] (P0) -- (P2);
                \draw[edge] (P0) -- (P3);
                \draw[edge] (P0) -- (P4);
                \draw[edge] (P1) -- (P5);
                \draw[edge] (P2) -- (P5);
                \draw[edge] (P3) -- (P6);
                \draw[edge] (P4) -- (P6);
                \draw[edge] (P5) -- (P7);
                \draw[edge] (P6) -- (P7);
            \end{tikzpicture}
            \caption{DAG para la figura~\ref{code:prog2_Ej4}.}
            \end{figure}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:5}
    Suponer un sistema de tiempo real que dispone de un captador de impulsos conectado a un
    contador de energía eléctrica. La función del sistema consiste en contar el número de impulsos
    producidos en 1 hora (cada Kwh consumido se cuenta como un impulso) e imprimir este número
    en un dispositivo de salida. Para ello se dispone de un programa concurrente con 2 procesos: un
    proceso acumulador (lleva la cuenta de los impulsos recibidos) y un proceso escritor (escribe
    en la impresora). En la variable común a los 2 procesos \verb|n| se lleva la cuenta de los impulsos. El
    proceso acumulador puede invocar un procedimiento \verb|Espera_impulso| para esperar a que llegue
    un impulso, y el proceso escritor puede llamar a \verb|Espera_fin_hora| para esperar a que termine
    una hora. El código de los procesos de este programa podría ser el descrito en el Código Fuente~\ref{code:ej5}.
    \begin{observacion}
        En el programa se usan sentencias de acceso a la variable \verb|n| encerradas entre los símbolos \verb|<| y
        \verb|>|. Esto significa que cada una de esas sentencias se ejecuta en exclusión mutua entre los dos
        procesos, es decir, esas sentencias se ejecutan de principio a fin sin entremezclarse entre ellas.
    \end{observacion}

    
    Supongamos que en un instante dado el acumulador está esperando un impulso, el escritor está
    esperando el fin de una hora, y la variable \verb|n| vale \verb|k|. Después se produce de forma simultánea
    un nuevo impulso y el fin del periodo de una hora.
    Obtener las posibles secuencias de interfolicación de las instrucciones (1),(2), y (3) a partir de
    dicho instante, e indicar cuales de ellas son correctas y cuales incorrectas (las incorrectas son
    aquellas en las cuales el impulso no se contabiliza).
    \begin{listing}
        \begin{minted}{pascal}
            { variable compartida: }
            var n : integer; { contabiliza impulsos }
            begin
            while true do begin
                Espera_impulso();
                < n := n+1 > ; { (1) }
                end
            end
            process Escritor ;
            begin
            while true do begin
                Espera_fin_hora();
                write( n ) ; { (2) }
                < n := 0 > ; { (3) }
                end
            end
        \end{minted}
        \caption{Código acumulador-escritor del ejercicio~\ref{ej:5}.}
        \label{code:ej5}
    \end{listing}

    En primer lugar, notemos que la intrucción $2$ siempre se ejecutará
    antes que la instrucción $3$, ya que están ambas en el mismo proceso (el escritor).
    Por tanto, las secuencia de instrucciones que se pueden dar son las intercalaciones de la instrucción $1$ con las otras dos instrucciones; es decir: $A)~1-2-3$, $B)~2-1-3$ y $C)~2-3-1$. El análisis de cada una de ellas está en la Tabla~\ref{tab:ej5}.
    \begin{table}
        \centering
        \begin{tabular}{|lcc|lcc|lcc|}
            \hline
            \multicolumn{3}{|c|}{Opción $A$} & \multicolumn{3}{|c|}{Opción $B$} & \multicolumn{3}{|c|}{Opción $C$} \\ \hline
            Operación & \verb|n| & Salida & Operación & \verb|n| & Salida & Operación & \verb|n| & Salida\\
            \hline
            $-$ & $k$ & $-$ & $-$ & $k$ & $-$ & $-$ & $k$ & $-$ \\
            \verb|1|$\to$ \verb|n:=n+1| & $k+1$ & $-$ & \verb|2|$\to$ \verb|write(n)| & $k$ & $k$ & \verb|2|$\to$ \verb|write(n)| & $k$ & $k$ \\
            \verb|2|$\to$ \verb|write(n)| & $k+1$ & $k+1$ & \verb|1|$\to$ \verb|n:=n+1| & $k+1$ & $k$ & \verb|3|$\to$ \verb|n:=0| & $0$ & $k$ \\
            \verb|3|$\to$ \verb|n:=0| & $0$ & $k+1$ & \verb|3|$\to$ \verb|n:=0| & $0$ & $k$ & \verb|1|$\to$ \verb|n:=n+1| & $1$ & $k$ \\
            \hline
        \end{tabular}
        \caption{Tabla de opciones del ejercicio~\ref{ej:5}.}
        \label{tab:ej5}
    \end{table}
    Notemos que tanto la opción $A$ como la $C$ son válidas, ya que en ambas se contabiliza el impulso. No obstante, difieren entre sí, puesto que en la opción $A$ se contabiliza el impulso en la hora que termina (imprimiéndose entonces), mientras que en la opción $C$ se contabiliza el impulso en la hora siguiente (no imprimiéndose entonces en esta salida). No obstante, la opción $B$ es incorrecta, ya que no se contabiliza el impulso en la hora que termina ni en la siguiente.
\end{ejercicio}



\begin{ejercicio} \label{ej:6}
    Supongamos un programa concurrente en el cual hay, en memoria compartida dos vectores \verb|a| y
    \verb|b| de enteros y con tamaño par, declarados como sigue:
    \begin{minted}{pascal}
        var a,b : array[1..2*n] of integer ; { n es una constante predefinida }
    \end{minted}
    Queremos escribir un programa para obtener en \verb|b| una copia ordenada del contenido de \verb|a| (nos
    da igual el estado en que queda \verb|a| después de obtener \verb|b|). Para ello disponemos de la función
    \verb|Sort| que ordena un tramo de \verb|a| (entre las entradas \verb|s| y \verb|t|, ambas incluidas). También disponemos
    la función \verb|Copiar|, que copia un tramo de \verb|a| (desde \verb|s| hasta \verb|t|) en \verb|b| (a partir de \verb|o|). Estas funciones
    se muestran en el Código Fuente~\ref{code:ej_6SortCopiar}.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Sort( s,t : integer );
                var i, j : integer ;
                begin
                    for i := s to t do
                    for j:= s+1 to t do
                        if a[i] < a[j] then
                            swap( a[i], b[j] ) ;
                end

            procedure Copiar( o,s,t : integer );
                var d : integer ;
                begin
                    for d := 0 to t-s do
                        b[o+d] := a[s+d] ;
                end
        \end{minted}
        \caption{Procedimientos \mintinline{pascal}{Sort} y \mintinline{pascal}{Copiar} del ejercicio~\ref{ej:6}.}
        \label{code:ej_6SortCopiar}
    \end{listing}

    El programa para ordenar se puede implementar de dos formas:
    \begin{enumerate}
        \item Ordenar todo el vector \verb|a|, de forma secuencial con la función \verb|Sort|, y después copiar cada
        entrada de \verb|a| en \verb|b|, con la función \verb|Copiar|.
        \item Ordenar las dos mitades de \verb|a| de forma concurrente, y después mezclar dichas dos mitades
        en un segundo vector \verb|b| (para mezclar usamos un procedimiento \verb|Merge|).
    \end{enumerate}
    En el Código Fuente~\ref{code:ej6_2versiones} se muestra el código de ambas versiones.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Secuencial() ;
                var i : integer ;
                begin
                    Sort( 1, 2*n ); { ordena a }
                    Copiar( 1, 2*n ); { copia a en b }
                end

            procedure Concurrente() ;
                begin
                    cobegin
                        Sort( 1, n );
                        Sort( n+1, 2*n );
                    coend
                    Merge( 1, n+1, 2*n );
                end
        \end{minted}
        \caption{Procedimientos \mintinline{pascal}{Secuencial} y \mintinline{pascal}{Concurrente} del ejercicio~\ref{ej:6}.}
        \label{code:ej6_2versiones}
    \end{listing}

    El código de la función \verb|Merge|, disponible en el Código Fuente~\ref{code:ej6_Merge}, se encarga de ir leyendo las dos mitades de \verb|a|, en cada paso, seleccionar el menor elemento de los dos siguientes por leer (uno en cada mitad), y escribir dicho menor elemento en la siguiente mitad del vector mezclado \verb|b|.
    \begin{listing}
        \begin{minted}{pascal}
            procedure Merge( inferior, medio, superior: integer ) ;
                { siguiente posicion a escribir en b }
                var escribir : integer := 1 ;
                { siguiente pos. a leer en primera mitad de a }
                var leer1 : integer := inferior ;
                { siguiente pos. a leer en segunda mitad de a }
                var leer2 : integer := medio ;
                begin
                    { mientras no haya terminado con alguna mitad }
                    while leer1 < medio and leer2 <= superior do begin
                        if a[leer1] < a[leer2] then begin { minimo en la primera mitad }
                            b[escribir] := a[leer1] ;
                            leer1 := leer1 + 1 ;
                        end else begin { minimo en la segunda mitad }
                            b[escribir] := a[leer2] ;
                            leer2 := leer2 + 1 ;
                        end
                        escribir := escribir+1 ;
                    end
                    { se ha terminado de copiar una de las mitades,
                    copiar lo que quede de la otra }
                    if leer2 > superior then
                        { copiar primera } Copiar( escribir, leer1, medio-1 );
                    else Copiar( escribir, leer2, superior ); { copiar segunda }
                end
        \end{minted}
        \caption{Procedimiento \mintinline{pascal}{Merge} del ejercicio~\ref{ej:6}.}
        \label{code:ej6_Merge}
    \end{listing}

    Llamaremos $T_s(k)$ al tiempo que tarda el procedimiento \verb|Sort| cuando actúa sobre un segmento del vector con $k$ entradas. Suponemos que el tiempo que (en media) tarda cada iteración del bucle interno que hay en \verb|Sort| es la unidad (por definición). Es evidente que ese bucle tiene $\dfrac{k(k-1)}{2}$ iteraciones, luego:
    \[
        T_s(k) = \dfrac{k(k-1)}{2} = \dfrac{1}{2}\cdot k^2 - \dfrac{1}{2}\cdot k
    \]

    El tiempo que tarda la versión secuencial sobre $2n$ elementos (llamaremos $S$ a dicho tiempo) será evidentemente $T_s(2n)$, luego:
    \[
        S = T_s(2n) = \dfrac{1}{2}\cdot (2n)^2 - \dfrac{1}{2}\cdot 2n = 2n^2 - n
    \]

    Con estas definiciones, calcular el tiempo que tardará la versión paralela, en los dos siguientes casos. Para esto, hay que suponer que cuando el procedimiento \verb|Merge| actúa sobre un vector con $p$ entradas, tarda $p$ unidades de tiempo en ello, lo cual es razonable teniendo en cuenta que en esas circunstancias \verb|Merge| copia $p$ valores desde \verb|a| hacia \verb|b|. Si llamamos a este tiempo $T_m(p)$, podemos escribir $T_m(p) = p$. Escribe también una comparación cualitativa de los tres tiempos ($S$, $P_1$ y $P_2$). 
    \begin{enumerate}
        \item Las dos instancias concurrentes de \verb|Sort| se ejecutan en el mismo procesador (llamamos $P_1$ al tiempo que tarda).
        
        En este caso, tenemos que hay ganancia de tiempo, ya que las dos instancias de \verb|Sort| no pueden ejecutarse simultáneamente. Por tanto, tenemos que:
        \begin{equation*}
            P_1 = 2\cdot T_s(n) + T_m(2n) = 2\cdot \left( \dfrac{1}{2}\cdot n^2 - \dfrac{1}{2}\cdot n \right) + 2n = n^2 - n + 2n = n^2 + n
        \end{equation*}
        \item Cada instancia de \verb|Sort| se ejecuta en un procesador distinto (lo llamamos $P_2$).
        
        Al poder ejecutarse ahora de forma simultánea, tenemos que:
        \begin{equation*}
            P_2 = \max\{ T_s(n), T_s(n) \} + T_m(2n) = \left( \dfrac{1}{2}\cdot n^2 - \dfrac{1}{2}\cdot n \right) + 2n = \dfrac{1}{2}\cdot n^2 + \dfrac{3}{2}\cdot n
        \end{equation*}
    \end{enumerate}

    Como podemos ver, en los tres casos la eficiencia es del orden cuadrático. No obstante,
    el coeficiente de $n^2$ es distinto en cada caso, siendo el mayor en la versión secuencial. Deducimos por tanto que las versiones concurrentes son más eficientes que la secuencial, y estas mejoras son significativas para valores de $n$ grandes.    

\end{ejercicio}

\begin{ejercicio} \label{ej:7}
    Supongamos que tenemos un programa con tres matrices (\verb|a|, \verb|b| y \verb|c|) de valores flotantes declaradas
    como variables globales. La multiplicación secuencial de \verb|a| y \verb|b| (almacenando el resultado en \verb|c|)
    se puede hacer mediante un procedimiento \verb|MultiplicacionSec| declarado como aparece aquí:
    \begin{minted}{pascal}
        var a, b, c : array[1..3,1..3] of real ;
        procedure MultiplicacionSec()
            var i,j,k : integer ;
            begin
                for i := 1 to 3 do
                    for j := 1 to 3 do begin
                        c[i,j] := 0 ;
                        for k := 1 to 3 do
                            c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                    end
            end
    \end{minted}
    Escribir un programa con el mismo fin, pero que use 3 procesos concurrentes. Suponer que
    los elementos de las matrices \verb|a| y \verb|b| se pueden leer simultáneamente, así como que elementos distintos de \verb|c| pueden escribirse simultáneamente.\\

    Esta solución puede llevarse a cabo de dos formas (tal y como vimos en la asigantura de AC). Crearemos tres procesos, y cada uno puede calcular una fila de la matriz \verb|c| (Código Fuente~\ref{code:ej7_fila}) o bien cada uno puede calcular una columna de la matriz \verb|c| (Código Fuente~\ref{code:ej7_columna}). No obstante, en la asignatura de AC se vio que, por norma general, es más eficiente calcular por filas que por columnas, ya que en el primer caso se accede a la matriz \verb|a| de forma secuencial, aprovechando así la localidad espacial y provocando un número menor de fallos de caché.
    \begin{figure}
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                var a, b, c : array[1..3,1..3] of real ;
                process CalcularFila[ i : 1..3] ;
                    var j, k : integer ;
                    begin
                        for j := 1 to 3 do begin
                            c[i,j] := 0 ;
                            for k := 1 to 3 do
                                c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                        end
                    end
                end
            \end{minted}
            \caption{Procesos concurrentes para calcular por filas.}
            \label{code:ej7_fila}
        \end{subfigure}\hfill
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                var a, b, c : array[1..3,1..3] of real ;
                process CalcularColumna[j : 1..3] ;
                    var i, k : integer ;
                    begin
                        for i := 1 to 3 do begin
                            c[i,j] := 0 ;
                            for k := 1 to 3 do
                                c[i,j] := c[i,j] + a[i,k]*b[k,j] ;
                        end
                    end
                end
            \end{minted}
            \caption{Procesos concurrentes para calcular por columnas.}
            \label{code:ej7_columna}
        \end{subfigure}
        \caption{Códigos para el ejercicio~\ref{ej:7}.}
    \end{figure}
\end{ejercicio}

\begin{ejercicio}\label{ej:8}
    Un trozo de programa ejecuta nueve rutinas o actividades (\verb|P1|, \verb|P2|, \ldots, \verb|P9|), repetidas veces,
    de forma concurrentemente con \verb|cobegin-coend| (ver trozo de código de la figura~\ref{code:ej8_enunciado}), pero que requieren
    sincronizarse según determinado grafo (ver la figura~\ref{fig:ej8_grafo}).
    \begin{figure}
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{minted}{pascal}
                while true do
                cobegin
                    P1 ; P2 ; P3 ;
                    P4 ; P5 ; P6 ;
                    P7 ; P8 ; P9 ;
                coend
            \end{minted}
            \caption{Código del ejercicio~\ref{ej:8}.}
            \label{code:ej8_enunciado}
        \end{subfigure} \hfill
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{tikzpicture}[
                node/.style={circle, draw, minimum size=0.5cm},
                edge/.style={-Stealth}
                ]
    
                % Nodos
                \node[node] (P1) {P1};
                \node[node, right  =of P1] (P2) {P2};
                \node[node, right  =of P2] (P3) {P3};
                \node[node, below  =of P1] (P4) {P4};
                \node[node, right  =of P4] (P5) {P5};
                \node[node, right  =of P5] (P6) {P6};
                \node[node, below  =of P4] (P7) {P7};
                \node[node, right  =of P7] (P8) {P8};
                \node[node, right  =of P8] (P9) {P9};

                % Aristas
                \draw[edge] (P1) -- (P4);
                \draw[edge] (P1) -- (P2);
                \draw[edge] (P2) -- (P3);
                \draw[edge] (P2) -- (P5);
                \draw[edge] (P3) -- (P6);
                \draw[edge] (P4) -- (P5);
                \draw[edge] (P4) -- (P7);
                \draw[edge] (P5) -- (P6);
                \draw[edge] (P5) -- (P8);
                \draw[edge] (P6) -- (P9);
                \draw[edge] (P7) -- (P8);
                \draw[edge] (P8) -- (P9);
            \end{tikzpicture}
            \caption{DAG del ejercicio~\ref{ej:8}.}
            \label{fig:ej8_grafo}
        \end{subfigure}
        \caption{Figuras del ejercicio~\ref{ej:8}.}
    \end{figure}

    Supón que queremos realizar la sincronización indicada en el grafo, usando para ello llamadas
    desde cada rutina a dos procedimientos (\verb|EsperarPor| y \verb|Acabar|). Se dan los siguientes hechos:
    \begin{itemize}
        \item El procedimiento \verb|EsperarPor(i)| es llamado por una rutina cualquiera (la número $k$) para esperar a que termine la rutina número $i$, usando espera ocupada. Por tanto, se usa por la rutina $k$ al inicio para esperar la terminación de las otras rutinas que corresponda según el grafo.
        \item El procedimiento \verb|Acabar(i)| es llamado por la rutina número $i$, al final de la misma, para indicar que dicha rutina ya ha finalizado.
        \item Ambos procedimientos pueden acceder a variables globales en memoria compartida.
        \item Las rutinas se sincronizan única y exclusivamente mediante llamadas a estos procedimientos, siendo la implementación de los mismos completamente transparente para las rutinas.
    \end{itemize}
    Escribe una implementación de \verb|EsperarPor| y \verb|Acabar| (junto con la declaración e inicialización de las variables compartidas necesarias) que cumpla con los requisitos dados.\\

    Usaremos para ello un vector de variables booleanas \verb|finalizado|, donde \verb|finalizado[i]| indica si la rutina $i$ ha finalizado o no. Inicialmente estará inicializado a \verb|false|, puesto que ningún proceso ha finalizado. Es decir:
    \begin{minted}{pascal}
        var finalizado : array[1..9] of boolean := (false,...,false) ;
    \end{minted}

    El procedimiento \verb|EsperarPor| se implementa de la siguiente forma:
    \begin{minted}{pascal}
        procedure EsperarPor( i : integer ) ;
        begin
            while not finalizado[i] do
            begin
                { no hacer nada }
            end;
        end.
    \end{minted}

    Respecto a la función \verb|Acabar|, podríamos pensar que tan solo se necesita cambiar el valor de la variable \verb|finalizado[i]| a \verb|true|. No obstante, hemos de tener en cuenta que este programa se ejecuta de forma repetida, por lo que si no se reinicia el vector \verb|finalizado| al final de cada ejecución, en la siguiente ejecución ya no habrá la sincronización necesaria. Por tanto, tras el fin del proceso \verb|P9|, se reinicia el vector \verb|finalizado| a \verb|false|.
    \begin{minted}{pascal}
        procedure Acabar( i : integer ) ;
        begin
            finalizado[i] := true ;
            if i >= 9 then
                finalizado := (false,...,false) ;
        end
    \end{minted}
    
\end{ejercicio}


\begin{ejercicio}
    En el ejercicio~\ref{ej:8} los procesos \verb|P1|, \verb|P2|, \ldots, \verb|P9| se ponen en marcha usando \verb|cobegin-coend|.
    Escribe un programa equivalente, que ponga en marcha todos los procesos, pero que use declaración
    estática de procesos, usando un vector de procesos \verb|P|, con índices desde 1 hasta 9, ambos incluidos. El proceso \verb|P[n]| contiene una secuencia de instrucciones desconocida, que llamamos \verb|S_n|, y además debe incluir las llamadas necesarias a \verb|Acabar| y \verb|EsperarPor| (con la misma implementación que antes) para lograr la sincronización adecuada. Se incluye aquí una plantilla:
    \begin{minted}{pascal}
        Process P[ n : 1..9 ]
        begin
            ..... { esperar (si es necesario) a los procesos que corresponda }
            S_n ; { sentencias especificas de este proceso (desconocidas) }
            ..... { senalar que hemos terminado }
        end
    \end{minted}

    En este ejercicio contamos con dos alternativas: una que es más larga pero más general, y una más corta pero específica para este problema.
    \begin{description}
        \item[Matriz de esperas]
        En primer lugar, hemos de especificar, en función de $n$, a qué procesos ha de esperar cada uno, lo cual se hará mediante una matriz compartida. Tenemos que:
        \begin{minted}{pascal}
            var espera : array[1..9,1..2] of integer := (
                (-1, -1),   { P1 }
                (1, -1),    { P2 }
                (2, -1),    { P3 }
                (1, -1),    { P4 }
                (2, 4),     { P5 }
                (3, 5),     { P6 }
                (4, -1),    { P7 }
                (5, 7),     { P8 }
                (6, 8)      { P9 }
            ) ;
            Process P[ n : 1..9 ]
            begin
                for i := 1 to 2 do
                    if espera[n,i] <> -1 then { != -1 }
                        EsperarPor( espera[n,i] ) ;
                
                S_n ;
                Acabar( n ) ;
            end
        \end{minted}

        \item[Usando operaciones]
        En esta alternativa, emplearemos operaciones para determinar a qué procesos esperar.
        \begin{minted}{pascal}
            Process P[ n : 1..9 ]
            begin
                {Esperamos al proceso de arriba}
                if (n > 3) then
                    EsperarPor( n-3 ) ;
                
                {Esperamos al proceso de la izquierda}
                if (n mod 3) <> 1 then
                    EsperarPor( n-1 ) ;                
                
                S_n ;
                Acabar( n ) ;
            end
        \end{minted}
    \end{description}
\end{ejercicio}

\begin{ejercicio}
    Para los siguientes fragmentos de código, obtener la \emph{poscondición} adecuada para convertirlo en un triple demostrable con la Lógica de Programas:
    \begin{enumerate}
        \item $\{i < 10\} \quad i = 2 \ast i + 1 \quad \{ \}$\\
            Obtenemos la poscondición de este triple razonando matemáticamente:
            \begin{align*}
                i &< 10 \\
                2\ast i &< 20 \\
                i' = 2\ast i + 1 &< 21
            \end{align*}
            donde hemos notado por $i'$ al nuevo valor que adopta la variable $i$.\\

            Por tanto, la poscondición del triple es: $i < 21$.

            Pasamos ahora a demostrar el triple siguiente:
            \begin{equation*}
               \{i < 10\} \quad i = 2 \ast i + 1 \quad \{i<21\}
            \end{equation*}
            
            Usando el axioma de asignación, tenemos que:
            \begin{equation*}
                \{i<21\}^i_{2\ast i + 1}\quad i=2\ast i + 1\quad \{i<21\}
            \end{equation*}

            No obstante, de la definición de Sustitución Textual, tenemos que:
            \begin{equation*}
                \{i<21\}^i_{2\ast i + 1} \equiv \{2\ast i + 1 < 21\} \equiv \{i < 10\} 
            \end{equation*}
            
            Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \begin{equation*}
                \{i<10\}\quad i=2\ast i + 1\quad \{i<21\} \\
            \end{equation*}

        \item $\{i > 0\} \quad i = i - 1; \quad \{ \}$\\
            Obtenemos la poscondición de este triple razonando matemáticamente:
            \begin{align*}
                i &> 0 \\
                i' = i - 1 &> -1
            \end{align*}
            donde hemos notado por $i'$ al nuevo valor que adopta la variable $i$.\\

            Por tanto, la poscondición del triple es: $i > -1$.

            Pasamos ahora a demostrar el triple siguiente:
            \begin{equation*}
                \{i > 0\} \quad i = i - 1; \quad \{i > -1\}
            \end{equation*}

            Usando el axioma de asignación, tenemos que:
            \begin{equation*}
                \{i > -1\}^i_{i-1}\quad i=i-1\quad \{i>-1\}
            \end{equation*}

            No obstante, de la definición de Sustitución Textual, tenemos que:
            \begin{equation*}
                \{i > -1\}^i_{i-1} \equiv \{i-1 > -1\} \equiv \{i > 0\}
            \end{equation*}

            Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \begin{equation*}
                \{i > 0\}\quad i = i - 1\quad \{i > -1\}
            \end{equation*}

        \item $\{i > j\} \quad i = i + 1;~j = j + 1 \quad \{ \}$\\
            De forma matemática y notando por $i'$ y $j'$ a las modificaciones de $i$ y $j$, respectivamente:
            \begin{align*}
                i &> j \\
                i' = i+1 &> j+1=j'\\
                i' &> j'
            \end{align*}

            Por tanto, la poscondición del triple es: $i > j$. Pasamos a demostrar el triple:
            \begin{equation*}
                \{i > j\} \quad i = i + 1;~j = j + 1 \quad \{i>j\}
            \end{equation*}

            Usando la regla de la composición, tenemos que:
            \begin{equation*}
                \dfrac{\{P\}S_1\{Q\}, \{Q\}S_2\{R\}}{\{P\}S_1;S_2\{R\}} \\
            \end{equation*}

            Identificando $Q$ con $i>j+1$, tenemos que bastará con probar los triples:
            \begin{enumerate}
                \item $\{i>j\}\ i=i+1\ \{i>j+1\}$
                
                Mediante el axioma de asignación, tenemos que:
                \begin{equation*}
                    \{i>j\} \equiv \{i+1>j+1\} \equiv \{i>j+1\}^i_{i+1}\ i=i+1\ \{i>j+1\}
                \end{equation*}

                \item $\{i>j+1\}\ j=j+1\ \{i>j\}$
                
                Mediante el axioma de asignación, tenemos que:
                \begin{equation*}
                    \{i>j+1\} \equiv \{i>j\}^j_{j+1}\ j=j+1\ \{i>j\}
                \end{equation*}
            \end{enumerate}

            Como ambos son ciertos, el triple que queríamos demostrar también lo es gracias a la regla de composición.
        \item $\{\text{falso}\} \quad a = a + 7; \quad \{ \}$\\
            En este caso, partimos de un estado del programa inalcanzable, por lo que en la poscondición podemos poner cualquier estado del programa, es decir, $\{\text{verdad}\}$.
        \item $\{\text{verdad}\} \quad i = 3;~j = 2 \ast i \quad \{ \}$\\
            Como partimos de cualquier estado del programa y sólo se realizan asignaciones, es fácil intuir cuál será la poscondición:
            \begin{gather*}
                i = 3 \\
                j = 2\ast i = 2\ast 3 = 6
            \end{gather*}
            Pasamos a demostrar el triple
            \begin{equation*}
                \{\text{verdad}\} \quad i = 3;~j = 2 \ast i \quad \{i=3\ \land\ j=6\}
            \end{equation*}
            Usando la regla de composición, nos será suficiente probar los triples:
            \begin{equation*}
                \{\text{verdad}\}\ i=3\ \{i=3\} \qquad \{i=3\}\ j=2\ast i\ \{i=3\ \land\ j=6\}
            \end{equation*}
            \begin{enumerate}
                \item Para el primer triple, usamos el axioma de asignación:
                \begin{equation*}
                    \{\text{verdad}\} \equiv \{3=3\} \equiv \{i=3\}^i_3\ i=3\ \{i=3\}
                \end{equation*}
                \item Para el segundo, volvemos a usar el axioma de asignación:
                \begin{equation*}
                    \{i=3\ \land\ j=6\}^j_{2\ast i}\ j=2\ast i\ \{i=3\ \land\ j=6\}
                \end{equation*}

                No obstante, de la definición de Sustitución Textual, tenemos que:
                \begin{multline*}
                    \{i=3\ \land\ j=6\}^j_{2\ast i} \equiv \{i=3\ \land\ 2\ast i=6\} \equiv \{i=3\ \land 2\ast 3=6\} \equiv \\ \equiv \{i=3\ \land\ 6=6\} \equiv \{i=3\}
                \end{multline*}

                Uniendo ambas ecuaciones, obtenemos que el triple es cierto.
            \end{enumerate}
            Ambos triples son ciertos, luego por la regla de la composición tenemos demostrado nuestro triple.
        \item $\{\text{verdad}\} \quad c = a + b;~c = \nicefrac{c}{2} \quad \{ \}$\\
            Notando por $c'$ al nuevo valor de $c$, tenemos que:
            \begin{align*}
                c &= a + b \\
                c' = \nicefrac{c}{2} &= \frac{a+b}{2}
            \end{align*}
            Tratamos por tanto de probar el siguiente triple
            \begin{equation*}
                \{\text{verdad}\} \quad c = a + b;~c = \nicefrac{c}{2} \quad \left\{c=\frac{a+b}{2}\right\}
            \end{equation*}
            Usando la regla de la composición, basta con probar los triples:
            \begin{equation*}
                \{\text{verdad}\}\ c=a+b;\ \{c=a+b\} \qquad \{c=a+b\}\ c=\nicefrac{c}{2};\ \left\{c=\frac{a+b}{2}\right\}
            \end{equation*}
            \begin{enumerate}
                \item Para el primero, usamos el axioma de asignación:
                    \begin{equation*}
                        \{\text{verdad}\}\equiv\{a+b=a+b\}\equiv \{c=a+b\}^c_{a+b}\ c=a+b\ \{c=a+b\}
                    \end{equation*}
                \item Para la segunda, también usamos el axioma de asignación:
                    \begin{equation*}
                        \{c=a+b\}\equiv \left\{\frac{c}{2} = \frac{a+b}{2}\right\} \equiv \left\{c=\frac{a+b}{2}\right\}^c_{\nicefrac{c}{2}}\ c=\nicefrac{c}{2}\ \left\{c=\frac{a+b}{2}\right\}
                    \end{equation*}
            \end{enumerate}
            Usando la relga de composición, tenemos demostrado nuestro triple.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    ¿Cuáles de los siguientes triples no son demostrables con la Lógica de Programas?
    (Considerando que $i,x,a \in \mathbb{Z}$)
    \begin{enumerate}
        \item $\{i > 0\} \quad i = i - 1; \quad \{i \geq 0\}$\\
            El siguiente triple sabemos que es cierto:
            \begin{equation*}
                \{i>0\}\ i=i-1\ \{i>-1\} 
            \end{equation*}
            Y como $\{i>-1\}\equiv \{i\geq 0\}$, el triple es cierto.
        \item $\{x \geq 7\} \quad x = x + 3; \quad \{x \geq 9\}$\\
            El siguiente triple sabemos que es cierto:    
            \begin{equation*}
                \{x\geq 7\}\ x=x+3\ \{x\geq 10\}
            \end{equation*}
            $\{x\geq 10\}\rightarrow\{x\geq 9\}$, luego es cierto por la primera regla de la consecuencia.
        \item $\{i < 9\} \quad i = 2 \ast i + 1; \quad \{ i \leq 20\}$\\
            El siguiente triple sabemos que es cierto:
            \begin{equation*}
                \{i<9\}\ i=2\ast i+1\ \{i<19\}
            \end{equation*}
            $\{i<19\}\rightarrow\{i\leq 20\}$, luego es cierto por la primera regla de la consecuencia.
        \item $\{a > 0\} \quad a = a - 7; \quad \{a > -6\}$\\
            \begin{equation*}
                \{a>0\}\ a=a-7\ \{a>-7\}
            \end{equation*}
            Pero $\{a>-7\}\not\rightarrow\{a>-6\}$, luego este triple no es demostrable.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Si el triple $\{P\} C \{Q\}$ es demostrable, indicar por qué los siguientes triples también lo son (o no se pueden demostrar y por qué):
    \begin{enumerate}
        \item $\{P\} C \{Q \lor P\}$\\
           Es demostrable, ya que $\{Q\}\rightarrow\{Q \lor P\}$ y por la primera regla de la consecuencia, tomando $R=Q \lor P$:
            \begin{equation*}
                \dfrac{\{P\}C\{Q\}, \{Q\}\rightarrow\{R\}}{\{P\}C\{R\}}
            \end{equation*}
            Tenemos que se debilita la poscondición.

        \item $\{P \land D\} C \{Q\}$\\
            Es demostrable, ya que $\{P \land D\}\rightarrow\{P\}$ y por la segunda regla de la consecuencia, tomando $R = P \land D$:
            \begin{equation*}
                \dfrac{\{P\}\rightarrow\{R\},\{R\}C\{Q\}}{\{P\}C\{Q\}}
            \end{equation*}
            Tenemos que se fortalece la precondición.
        \item $\{P \lor D\} C \{Q\}$\\
            No es demostrable, porque se debilita la precondición.

        \item $\{P\} C \{Q \lor D\}$\\
            Al igual que hemos hecho en el apartado 1, es demostrable ya que ${\{Q\}\rightarrow\{Q \lor D\}}$ y usando la primera regla de la consecuencia.
        \item $\{P\} C \{Q \land P\}$\\
            No podemos demostrarlo, ya que se fortalece la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Si el triple $\{P\} C \{Q\}$ es demostrable, ¿cuál de los siguientes triples no se puede demostrar?
    \begin{enumerate}
        \item $\{P \land D\} C \{Q\}$\\
            Sabemos que $\{P \land D\}\rightarrow\{P\}$, luego puede demostrarse por la segunda regla de la consecuencia (se fortalece la precondición).
        \item $\{P \lor D\} C \{Q\}$\\
            No puede demostrarse, porque se debilita la precondición.
        \item $\{P\} C \{Q \lor D\}$\\
            Puede demostrarse mediante la primera regla de la consecuencia, ya que se tiene que ${\{Q\}\rightarrow\{Q \lor D\}}$.

        \item $\{P\} C \{Q \lor P\}$\\
        Puede demostrarse mediante la primera regla de la consecuencia, ya que se tiene que ${\{Q\}\rightarrow\{Q \lor P\}}$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Dado el siguiente programa, obtener:
    \begin{minted}{pascal}
        int x = 5, y = 2;
        cobegin
            < x = x + y >;
            < y = x * y >;
        coend
    \end{minted}
    \begin{enumerate}
        \item Valores finales de $x$ e $y$.
        Tenemos dos posibles trazas de ejecución:
        \begin{enumerate}
            \item Primero se ejecuta la primera instrucción, por lo que obtendríamos $x = 7$ y $y = 14$.
            \item Primero se ejecuta la segunda instrucción, por lo que obtendríamos $x = 15$ y $y = 10$.
        \end{enumerate}
        \item Valores finales de $x$ e $y$ si quitamos los símbolos \verb|< >| de instrucción atómica.
        
        Encontramos cada uno de los dos estados anteriores, además de $x = 7$ y $y= 10$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Comprobar si la demostración del siguiente triple interfiere con los teoremas siguientes:
    \[
        \{x \geq 2\} \quad < x = x - 2 > \quad \{x \geq 0\}
    \]
    Es decir, queremos comprobar si $R\equiv <x = x-2>$ con $pre(R) = \{x\geq 2\}$ interfiere con los triples siguientes:
    \begin{enumerate}
        \item $\{x \geq 0\} \quad < x = x + 3 > \quad \{x \geq 3\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 0 \land x \geq 2\}\ <x=x-2>\ \{x\geq 0\}
            \end{equation*}
            Este triple es correcto por la segunda regla de la consecuencia, luego no interfiere con la precondición.\\

            Comprobemos ahora su interferencia con la poscondición:
            \begin{equation*}
                \{x\geq 3 \land x \geq 2\}\ <x=x-2>\ \{x\geq 1\}
            \end{equation*}
            En este caso, $\{x\geq 1\}\not\rightarrow\{x\geq 3\}$, luego este triple no es demostrable y $R$ interfiere con la poscondición del triple en cuestión.

        \item $\{x \geq 0\} \quad < x = x + 3 > \quad \{x \geq 0\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 0 \land x \geq 2\}\ <x=x-2>\ \{x\geq 0\}
            \end{equation*}
            Este triple es correcto por la segunda regla de la consecuencia, luego no interfiere con la precondición.
            Además, como la precondición y la poscondición son iguales, $R$ tampoco interfiere con la poscondición, luego no interfiere con este triple.
        \item $\{x \geq 7\} \quad < x = x + 3 > \quad \{x \geq 10\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x\geq 7 \land x \geq 2\}\ <x=x-2>\ \{x\geq 5\}
            \end{equation*}
            No obstante, como $\{x\geq 5\}\not\rightarrow\{x\geq 7\}$, $R$ interfiere con la precondición de este triple.
        \item $\{y \geq 0\} \quad < y = y + 3 > \quad \{y \geq 3\}$\\
            $R$ no interfiere con este triple, ya que son variables disjuntas.
        \item $\{x \text{ es impar}\} \quad < y = x + 1 > \quad \{y \text{ es par}\}$\\
            Comprobamos en primer lugar su interferencia con la precondición:
            \begin{equation*}
                \{x \text{ es impar } \land x\geq 2\}\ <x=x-2>\ \{x \text{ es impar } \land x \geq 0\}
            \end{equation*}
            Por la $1^a$ regla de la consecuencia, como $\{x \text{ es impar } \land x \geq 0\} \rightarrow \{x \text{ es impar}\}$, tenemos que es correcto y $R$ no interfiere con la precondición.

            Comprobamos ahora su interferencia con la poscondición:
            \begin{equation*}
                \{y \text{ es par } \land x \geq 2\}\ <x=x-2>\ \{y \text{ es par } \land x \geq 0\}
            \end{equation*}
            Por la $1^a$ regla de la consecuencia, como $\{y \text{ es par } \land x \geq 0\} \rightarrow \{y \text{ es par}\}$, tenemos que es correcto y $R$ no interfiere con la poscondición. Por tanto, $R$ no interfiere con este triple.
            
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Dado el siguiente triple:
    \begin{gather*}
        \{x = 0\} \\
        \text{cobegin} \\
        <x = x + a> || <x = x + b> || <x = x + c> \\
        \text{coend} \\
        \{x = a + b + c\}
    \end{gather*}
    
    Demostrarlo utilizando la lógica de asertos para cada una de las tres instrucciones atómicas y después que se llega a la poscondición final $x = a + b + c$ utilizando para ello la regla \emph{de la composición concurrente} de instrucciones atómicas.\\

Inicialmente, demostraremos los $3$ siguientes triples, uno por cada instrucción atómica. Hemos de notar que, en cada uno de ellos, como no sabemos en qué orden se ejecutan, tenemos que incluir en las precondiciones y las poscondiciones todas las posibilidades.
\begin{enumerate}
    \item El correspondiente a la primera instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=b \lor x=c \lor x=b+c\}\ <x=x+a>\ \\ \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}
    \end{gather*}

    Mediante el axioma de asignación, tenemos que:
    \begin{gather*}
        \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}_{x+a}^x <x=x+a>\\ \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}
    \end{gather*}

    No obstante, de la definición de Sustitución Textual, tenemos:
    \begin{gather*}
        \{x=a \lor x=a+b \lor x=a+c \lor x=a+b+c\}_{x+a}^x \equiv \\
        \equiv \{x+a=a \lor x+a=a+b \lor x+a=a+c \lor x+a=a+b+c\} \equiv \\
        \equiv \{x=0 \lor x=b \lor x=c \lor x=b+c\}
    \end{gather*}

    Por tanto, el triple en cuestión es cierto.

    \item El correspondiente a la segunda instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=a \lor x=c \lor x=a+c\}\ <x=x+b>\ \\ \{x=b \lor x=a+b \lor x=b+c \lor x=a+b+c\}
    \end{gather*}

    Es cierto, y su demostración es análoga al primer caso.
    \item El correspondiente a la tercera instrucción atómica:
    \begin{gather*}
        \{x=0 \lor x=b \lor x=a \lor x=a+b\}\ <x=x+c>\ \\ \{x=c \lor x=a+c \lor x=b+c \lor x=a+b+c\}
    \end{gather*}
    Es cierto, y su demostración es análoga al primer caso.
\end{enumerate}

Seguidamente, tenemos que ver que dichos $3$ triples están libres de interferencias. Para ello, hemos de probar $12$ triples, ya que hay $3$ instrucciones atómicas, cada una de ellas con $2$ asertos, por lo que por cada instrucción hemos de comprobar $4$ asertos:
\begin{align*}
    &NI(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+a>)\\
    &NI(x=b \lor x=a+b \lor x=b+c \lor x=a+b+c, <x=x+a>)\\
    &NI(x=0 \lor x=b \lor x=a \lor x=a+b, <x=x+a>)\\
    &NI(x=c \lor x=a+c \lor x=b+c \lor x=a+b+c, <x=x+a>)\\ \\
    &NI(x=0 \lor x=b \lor x=c \lor x=b+c, <x=x+b>)\\
    &NI(x=a \lor x=a+b \lor x=a+c \lor x=a+b+c, <x=x+b>)\\
    &NI(x=0 \lor x=b \lor x=a \lor x=a+b, <x=x+b>)\\
    &NI(x=c \lor x=a+c \lor x=b+c \lor x=a+b+c, <x=x+b>)\\ \\
    &NI(x=0 \lor x=b \lor x=c \lor x=b+c, <x=x+c>)\\
    &NI(x=a \lor x=a+b \lor x=a+c \lor x=a+b+c, <x=x+c>)\\
    &NI(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+c>)\\
    &NI(x=b \lor x=a+b \lor x=b+c \lor x=a+b+c, <x=x+c>)\\
\end{align*}

Demostremos ahora el primero, ya que el resto son idénticos.
\begin{align*}
    NI&(x=0 \lor x=a \lor x=c \lor x=a+c, <x=x+a>)\equiv \\
    &\equiv \{(x=0 \lor x=a \lor x=c \lor x=a+c) \land (x=0 \lor x=b \lor x=c \lor x=b+c)\}\\&\qquad <x=x+a> \{x=0 \lor x=a \lor x=c \lor x=a+c\}\equiv \\
    &\equiv \{x=0 \lor x=c\} <x=x+a> \{x=0 \lor x=a \lor x=c \lor x=a+c\}
\end{align*}
Este triple efectivamente es cierto, lo cual se puede demostrar empleando en primer lugar el Axioma de Sustitución y, posteriormente, la primera regla de la consecuencia.\\

Por tanto, y tras aplicar la Regla de la Composición Concurrente, tenemos de forma directa que:
    \begin{gather*}
        \{x = 0\} \\
        \text{cobegin} \\
        <x = x + a> || <x = x + b> || <x = x + c> \\
        \text{coend} \\
        \{x = a + b + c\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    El siguiente triple:
    \begin{gather*}
        \{x=0 \land y = 0 \land z = 0\} \\
        <x = z + a> || <y = x+b> \\
        \{(x = a) \land (y = b \lor y = a +b) \land z = 0\}
    \end{gather*}
    \begin{enumerate}[label=(\alph*)]
        \item Es indemostrable salvo que se cumpla siempre que $a=0$.
        \item El triple anterior es demostrable para cualquier valor de las variables $a$ o $b$.
        \item Es indemostrable salvo que se cumpla siempre que $b = 0$.
        \item Es indemostrable salvo que se cumpla siempre que $a = 0 \land b = 0$.
    \end{enumerate}

    Veamos si podemos demostrarlo. Para ello, notamos cada instrucción atómica de la siguiente forma:
    \begin{align*}
        S_1 &= <x = z + a> \\
        S_2 &= <y = x + b>
    \end{align*}

    Veamos cuál ha de ser la precondición de cada instrucción atómica:
    \begin{align*}
        P_1 &= x=0 \land (y=0 \lor y=b) \land z=0 \\
        P_2 &= (x=0\lor x=a) \land y=0 \land z=0
    \end{align*}

    Veamos cuál ha de ser la poscondición de cada instrucción atómica:
    \begin{align*}
        Q_1 &= x=a\land (y=0 \lor y=b)\land z=0 \\
        Q_2 &= [(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0
    \end{align*}

    Vemos por tanto que ambos triples son ciertos:
    \begin{enumerate}
        \item $\{P_1\} S_1 \{Q_1\}$
        
        De la definición de Sustitución Textual, tenemos que:
        \begin{multline*}
            \{x=a \land (y=0 \lor y=b) \land z = 0\}_{z+a}^x \equiv \{z+a=a \land (y=0 \lor y=b) \land z = 0\} \equiv\\\equiv \{(y=0 \lor y=b) \land z=0\}
        \end{multline*}

        Por tanto, del Axioma de Asignación, tenemos que:
        \begin{equation*}
            \{(y=0 \lor y=b) \land z = 0\} <x = z + a> \{x=a \land (y=0 \lor y=b) \land z = 0\}
        \end{equation*}

        Finalmente, usando la segunda regla de la consecuencia, como se tiene que $\{P_1\}\rightarrow\{(y=0 \lor y=b) \land z = 0\}$, tenemos que el triple es cierto.
        
        \item $\{P_2\} S_2 \{Q_2\}$
        
        De la definición de Sustitución Textual, tenemos que:
        \begin{multline*}
            \{[(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0\}_{x+b}^y \equiv \\ \equiv \{[(x=0\land x+b=b) \lor (x=a\land x+b=a+b)] \land z = 0\} \equiv \\ \equiv \{(x=0\lor x=a) \land z = 0\}
        \end{multline*}

        Por tanto, del Axioma de Asignación, tenemos que:
        \begin{multline*}
            \{(x=0\lor x=a) \land z = 0\} <y = x + b> \\ \{[(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0\}
        \end{multline*}

        Por tanto, usando la segunda regla de la consecuencia, como se tiene que $\{P_2\}\rightarrow\{(x=0\lor x=a) \land z = 0\}$, tenemos que el triple es cierto.
    \end{enumerate}

    Veamos ahora que no interfieren entre sí. Como tenemos dos instrucciones atómicas, cada una con dos asertos, hemos de comprobar $4$ asertos:
    \begin{align*}
        NI(P_2, S_1) & \equiv \{P_1\land P_2\} S_1 \{P_2\} \\
        NI(Q_2, S_1) & \equiv \{P_1\land Q_2\} S_1 \{Q_2\} \\
        NI(P_1, S_2) & \equiv \{P_2\land P_1\} S_2 \{P_1\} \\
        NI(Q_1, S_2) & \equiv \{P_2\land Q_1\} S_2 \{Q_1\}
    \end{align*}

    Veamos por tanto en qué queda cada uno de ellos:
    \begin{align*}
        NI(P_2, S_1) & \equiv \{x=0 \land y=0 \land z=0\} <x=z+a> \{(x=0\lor x=a) \land y=0 \land z=0\} \\
        NI(Q_2, S_1) & \equiv \{x=0 \land y=b \land z=0\} <x=z+a>\\&\hspace{5cm} \{[(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0\} \\
        NI(P_1, S_2) & \equiv \{x=0 \land y=0 \land z=0\} <y=x+b> \{x=0 \land (y=0\lor y=b) \land z=0\} \\
        NI(Q_1, S_2) & \equiv \{x=a \land y=0 \land z=0\} <y=x+b> \{x=a \land (y=0\lor y=b) \land z=0\}
    \end{align*}

    Intentemos demostrar el segundo. Usando la definición de Sustitución Textual, tenemos que:
    \begin{multline*}
        \{[(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0\}_{z+a}^x \equiv \\ \equiv \{[(z+a=0\land y=b) \lor (z+a=a\land y=a+b)] \land z=0\} \equiv \\ \equiv \{y=a+b \land z=0\}
    \end{multline*}
    Por tanto, del Axioma de Asignación, tenemos que:
    \begin{multline*}
        \{y=a+b \land z=0\} <x=z+a> \{[(x=0\land y=b) \lor (x=a\land y=a+b)] \land z=0\}
    \end{multline*}
    No obstante, de forma general, tenemos que $\{x=0\land y=b\land z=0\}\not\rightarrow\{y=a+b \land z=0\}$, por lo que $NI(Q_2, S_1)$ no es demostrable. No obstante, si $a=0$, entonces sí que sería demostrable. Supongamos por tanto a partir de ahora que \ul{$a=0$}.

    Intentemos ahora demostrar el cuarto. Usando la definición de Sustitución Textual, tenemos que:
    \begin{multline*}
        \{x=a \land (y=0 \lor y=b) \land z = 0\}_{x+b}^y \equiv \\ \equiv \{x=a \land (x+b=0 \lor x+b=b) \land z = 0\} \equiv \\ \equiv \{x=a \land (x=-b\lor x=0) \land z = 0\} \equiv 
        \{x=0 \land z = 0\}
    \end{multline*}
    donde en la última igualdad hemos usado que \ul{$a=0$}. Por tanto, del Axioma de Asignación, tenemos que:
    \begin{multline*}
        \{x=0 \land z = 0\} <y=x+b> \{x=a \land (y=0 \lor y=b) \land z = 0\}
    \end{multline*}
    Además, como \ul{$a=0$}, tenemos que $\{x=a \land y=0 \land z=0\}\rightarrow\{x=0\land z=0\}$, y por tanto es cierto. Por tanto, $NI(Q_1, S_2)$ es demostrable.

    Los otros dos triples son análogamente ciertos, por lo que podemos aplicar la regla de la composición concurrente y llegar al siguiente triple:
    \begin{gather*}
        \{x=0 \land y = 0 \land z = 0\} \\
        <x = z + a> || <y = x+b> \\
        \{x = a \land  y = a +b \land z = 0\}
    \end{gather*}
    Este es el triple que queríamos demostrar, suponiendo que \ul{$a=0$}. Por tanto, la respuesta correcta es la \textbf{a)}, ya que no es demostrable salvo que se cumpla siempre que $a=0$.
\end{ejercicio}

\begin{ejercicio}
    Suponer que $\{suma>1\}\ suma=suma+4\ \{suma>5\}$ es demostrable, entonces: ¿cuál de los siguientes triples es también demostrable? (indicar por qué)
    \begin{enumerate}
        \item $\{suma>2\}\ suma=suma+4\ \{suma>5\}$.\\
            Es demostrable, ya que $\{suma>2\}\rightarrow\{suma>1\}$ y podemos aplicar la segunda regla de la consecuencia.
        \item $\{suma\geq 1\}\ suma=suma+4\ \{suma > 5\}$.\\
            No es demostarble, ya que debilita la precondición.
        \item $\{suma>0\}\ suma=suma+4\ \{suma > 5\}$.\\
            No es demostarble, ya que debilita la precondición.
        \item $\{suma>1\}\ suma=suma+4\ \{suma > 6\}$.\\
            No es demostrable, ya que fortalece la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Suponer que $\{x<y\}\ C_1\ \{u<v\}$ es demostrable, entonces: ¿cuáles de los siguientes triples son también demostrables? (indicar por qué)
    \begin{enumerate}
        \item $\{x\leq y\}\ C_1\ \{u<v\}$.\\
            No es demostrable, ya que debilita la precondición.
        \item $\{x\leq y-2\}\ C_1\ \{u<v\}$.\\
            Es demostrable, ya que $\{x\leq y-2\}\rightarrow\{x+2\leq y\}\rightarrow\{x<y\}$, y mediante la segunda regla de la consecuencia se tiene que es cierto.
        \item $\{x\leq y\}\ C_1\ \{u\leq v\}$.\\
            El triple $\{x<y\}\ C_1\ \{u\leq v\}$ sí que es demostrable ya que relaja la poscondición, pero el triple que se nos dice no es demostrable, ya que también relaja la precondición.
            Como además no tenemos relación entre $x$ y $u$ ni entre $y$ y $v$, no podemos inferir nada.
        \item $\{x<y\}\ C_1\ \{u<v-2\}$.\\
            No es demostrable, ya que fortalecemos la poscondición.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Seleccionar el valor correcto de las 2 variables ($x$ e $y$) después de ejecutarse el siguiente programa concurrente:
    \begin{minted}{pascal}
        int x=5, y=2;
        cobegin <x=x+y>; <y=x*y>; <x=x-y>; coend;
    \end{minted}
    \begin{enumerate}[label=(\alph*)]
        \item $x=7$ y $y=14$.
        \item $x=5$ y $y=10$.
        \item $x=-7$ y $y=14$.
        \item $x=-3$ y $y=10$.
    \end{enumerate}

    Numeramos las instrucciones atómicas de la siguiente forma:
    \begin{enumerate}
        \item \verb|<x=x+y>|
        \item \verb|<y=x*y>|
        \item \verb|<x=x-y>|
    \end{enumerate}

    Veamos ahora, en función del orden de ejecución, cuál sería el valor de las variables $x$ e $y$:
    \begin{itemize}
        \item \ul{1, 2, 3}: $x=-7$ y $y=14$.
        \item \ul{1, 3, 2}: $x=5$ y $y=10$.
        \item \ul{3, 1, 2}: $x=5$ y $y=10$.
        \item \ul{2, 1, 3}: $x=5$ y $y=10$.
        \item \ul{2, 3, 1}: $x=5$ y $y=10$.
        \item \ul{3, 2, 1}: $x=9$ y $y=6$.
    \end{itemize}

    Por tanto, las respuestas $b$ y $c$ son correctas.
\end{ejercicio}

\begin{ejercicio}
    El siguiente código concurrente no puede ser demostrado directamente con la lógica de aserciones (pre y poscondiciones). Elegir la respuesta que explica correctamente la razón de que ocurra esto.
    \begin{minted}{pascal}
        {x=0} cobegin <x=x+a>; <x=x+a> coend; {x=2*a}
        {(a es un valor entero positivo)}
    \end{minted}
    \begin{enumerate}[label=(\alph*)]
        \item Porque la poscondición que se propone $\{x=2\ast a\}$ es falsa.
        \item Porque falta incluir la posibilidad de que el valor final de $x$ sea también ${\{x=a\}}$.
        \item Porque al aplicar directamente la regla de inferencia de la \textit{composición concurrente} utilizo unas condiciones (pre y post-condiciones) demasiado débiles.
        \item Porque tengo que incluir en los asertos el valor del contador de programa de cada procesador.
    \end{enumerate}

    Notamos cada instrucción atómica de la siguiente forma:
    \begin{equation*}
        S_1 = S_2 = <x=x+a>
    \end{equation*}

    Veamos cuál ha de ser la precondición de cada instrucción atómica:
    \begin{equation*}
        P_1 = P_2 = \{x=0 \lor x=a\}
    \end{equation*}

    Veamos cuál ha de ser la poscondición de cada instrucción atómica:
    \begin{equation*}
        Q_1 = Q_2 = \{x=a \lor x=2a\}
    \end{equation*}

    Veamos ahora que cada triple es cierto. Como son los mismos, hemos de demostrar:
    \begin{equation*}
        \{x=0 \lor x=a\} <x=x+a> \{x=a \lor x=2a\}
    \end{equation*}
    
    Este se demuestra de forma directa. Además, también hemos de demostrar que no interfieren entre sí. Tenemos que demostrar:
    \begin{align*}
        NI(P_1, S_2) &\equiv \{x=0 \lor x=a\} <x=x+a> \{x=0 \lor x=a\} \\
        NI(Q_1, S_2) &\equiv \{x=a\} <x=x+a> \{x=a \lor x=2a\}
    \end{align*}

    \begin{comment}
    Estos también son ciertos, por lo que podemos aplicar la regla de la composición concurrente y llegar al siguiente triple:
    \begin{equation*}
        \{x=0 \lor x=a\}\texttt{cobegin}<x=x+a>; <x=x+a>\texttt{coend}; \{x=a\lor x=2a\}
    \end{equation*}

    Por la primera regla de la consecuencia, podemos debilitar la precondición, llegando al siguiente triple:
    \begin{equation*}
        \{x=0\}\texttt{cobegin}<x=x+a>; <x=x+a>\texttt{coend}; \{x=a\lor x=2a\}
    \end{equation*}

    No obstante, la poscondición no se puede debilitar, por lo que la respuesta correcta es la \textbf{b)}, ya que falta incluir en los asertos el valor final de $x$ sea también $\{x=a\}$.
    \end{comment}

    El primer triple no es cierto, ya que por el Axioma de Asignación, tenemos que el triple correcto es:
    \begin{equation*}
        \{x=-a \lor x=0\} <x=x+a> \{x=0 \lor x=a\}
    \end{equation*}
    Como estamos debilitando la precondición, este triple no es cierto. Por tanto, la respuesta correcta es la \textbf{c)}, ya que al aplicar directamente la regla de inferencia de la \textit{composición concurrente} utilizo unas condiciones (pre y post-condiciones) demasiado débiles.
    
    
    \begin{observacion}
        Notemos que esto puede parecer contraintuitivo, ya que el lector sabe que ese triple es cierto. La lógica de Hoare no nos dice que sea falso, sino que tal y como lo hemos planteado no es demostrable. Se podría plantear con otras precondiciones y poscondiciones más fuertes, estudiando el orden de ejecución de cada una de las instrucciones atómicas, y llegaríamos entonces a que es cierto, pero esta demostración es mucho más compleja.
    \end{observacion}
\end{ejercicio}

\begin{ejercicio}
   Estudiar cuáles son los valores finales de las variables \verb|x| e \verb|y| en el siguiente programa. Insertar los asertos adecuados entre llaves, antes y después de cada sentencia, para poder obtener una traza de demostración del programa, que incluya en su último aserto los valores finales de las variables. 
   \begin{minted}{c++}
       int x = c1;
       int y = c2;
       x = x + y;
       y = x * y;
       x = x - y;
   \end{minted}

   Tenemos que cada triple, por orden, es:
   \begin{gather*}
       \{x = c_1 \land y = c_2\}\\
       x = x + y \\
       \{x = c_1 + c_2 \land y =c_2\} \\
       y = x * y \\
       \{x = c_1 + c_2 \land y = (c_1 + c_2)\cdot c_2 \} \\
       x = x - y \\
       \{x = (c_1 + c_2) - (c_1 + c_2)\cdot c_2 = (c_1 + c_2)\cdot (1-c_2) \land y = (c_1 + c_2)\cdot c_2 \}
   \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar que el siguiente triple es cierto:
    \begin{gather*}
        \{x=0\}\\ 
        \texttt{cobegin} \\
        <x=x+1> || <x=x+2> || <x=x+4> \\
        \texttt{coend} \\
        \{x=7\}
    \end{gather*}

    Notamos cada instrucción atómica de la siguiente forma:
    \begin{align*}
        S_1 &= <x=x+1> \\
        S_2 &= <x=x+2> \\
        S_3 &= <x=x+4>
    \end{align*}

    Veamos cuál ha de ser la precondición de cada instrucción atómica:
    \begin{align*}
        P_1 = x=0 \lor x=2 \lor x=4 \lor x=6 \\
        P_2 = x=0 \lor x=1 \lor x=4 \lor x=5 \\
        P_3 = x=0 \lor x=1 \lor x=2 \lor x=3
    \end{align*}

    Veamos cuál ha de ser la poscondición de cada instrucción atómica:
    \begin{align*}
        Q_1 = x=1 \lor x=3 \lor x=5 \lor x=7 \\
        Q_2 = x=2 \lor x=3 \lor x=6 \lor x=7 \\
        Q_3 = x=4 \lor x=5 \lor x=6 \lor x=7
    \end{align*}

    Cada triple es directamente cierto por el Axioma de Asignación. Veamos ahora que no interfieren entre sí. Tenemos que demostrar:
    \begin{align*}
        NI(P_2, S_1) &\equiv \{x=0 \lor x=4\} <x=x+1> \{x=0\lor x=1\lor x=4\lor x=5\} \\
        NI(Q_2, S_1) &\equiv \{x=2 \lor x=6\} <x=x+1> \{x=2\lor x=3\lor x=6\lor x=7\} \\
        NI(P_3, S_1) &\equiv \{x=0 \lor x=2\} <x=x+1> \{x=0\lor x=1\lor x=2\lor x=3\} \\
        NI(Q_3, S_1) &\equiv \{x=4 \lor x=6\} <x=x+1> \{x=4\lor x=5\lor x=6\lor x=7\} \\ \\
        NI(P_1, S_2) &\equiv \{x=0 \lor x=4\} <x=x+2> \{x=0\lor x=2\lor x=4\lor x=6\} \\
        NI(Q_1, S_2) &\equiv \{x=1 \lor x=5\} <x=x+2> \{x=1\lor x=3\lor x=5\lor x=7\} \\
        NI(P_3, S_2) &\equiv \{x=0 \lor x=1\} <x=x+2> \{x=0\lor x=1\lor x=2\lor x=3\} \\
        NI(Q_3, S_2) &\equiv \{x=4 \lor x=5\} <x=x+2> \{x=4\lor x=5\lor x=6\lor x=7\} \\ \\
        NI(P_1, S_3) &\equiv \{x=0 \lor x=2\} <x=x+4> \{x=0\lor x=2\lor x=4\lor x=6\} \\
        NI(Q_1, S_3) &\equiv \{x=1 \lor x=3\} <x=x+4> \{x=1\lor x=3\lor x=5\lor x=7\} \\
        NI(P_2, S_3) &\equiv \{x=0 \lor x=1\} <x=x+4> \{x=0\lor x=1\lor x=4\lor x=5\} \\
        NI(Q_2, S_3) &\equiv \{x=2 \lor x=3\} <x=x+4> \{x=2\lor x=3\lor x=6\lor x=7\}
    \end{align*}

    Todos estos son ciertos, por lo que podemos aplicar la regla de la composición concurrente y llegar al siguiente triple:
    \begin{gather*}
        \{x=0\} \\
        \texttt{cobegin} \\
        <x=x+1> || <x=x+2> || <x=x+4> \\
        \texttt{coend} \\
        \{x=7\}
    \end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Dada la siguiente construcción de composición concurrente \verb|P|:
    \begin{gather*}
        \texttt{cobegin} \\
        <x=x-1>;<x=x+1>;||<y=y-1>;<y=y+1>; \\
        \texttt{coend} \\
    \end{gather*}
    demostrar que se cumple la invarianza de $\{x=y\}$, es decir, que $\{x=y\}\ P\ \{x=y\}$ es un triple cierto.\\

Para ello, comenzamos demostrando los siguientes triples (se ha de mantener la invarianza en el código secuencial)
\begin{gather*}
    \{x=y\}\ x=x-1;x=x+1;\ \{x=y\} \\
    \{x=y\}\ y=y-1;y=y+1;\ \{x=y\} \\
\end{gather*}
\begin{enumerate}
    \item Respecto al primero, tenemos que los siguientes triples son ciertos:
        \begin{gather*}
            \{x=y\}\ x=x-1\ \{x+1=y\} \\
            \{x+1=y\}\ x=x+1\ \{x=y\}
        \end{gather*}
        Usando la regla de la composición, se tiene.
    \item Respecto al segundo, tenemos que los siguientes triples son ciertos:
        \begin{gather*}
            \{y=x\}\ y=y-1\ \{y+1=x\} \\
            \{y+1=x\}\ y=y+1\ \{y=x\}
        \end{gather*}
        Usando la regla de la composición, se tiene.
\end{enumerate}
Ahora, los triples son libres de interferencia por tener variables disjuntas. Podemos aplicar por tanto la regla de la composición concurrente, llegando a lo que queríamos probar:
\begin{gather*}
    \{x=y\} \\
    \texttt{cobegin} \\
    <x=x-1>;<x=x+1>;||<y=y-1>;<y=y+1>; \\
    \texttt{coend} \\
    \{x=y\}
\end{gather*}
\end{ejercicio}

\begin{ejercicio}
    Usando la regla de la conjunción, demostrar que 
    \begin{equation*}
        \{i>2\}\ i=2\ast i\ \{i>4\}
    \end{equation*}
    
    Aunque se podría demostrar de forma directa mediante el axioma de asignación, vamos a demostrarlo mediante la regla de la conjunción. Para ello, consideramos los siguientes triples:
    \begin{gather*}
        \{V\} \ i=2\ast i\ \{i=2\ast i\} \\
        \{i> 2\} \ i=2\ast i\ \{i>2\}
    \end{gather*}

    Estos son directamente ciertos por el axioma de asignación. Por tanto, podemos aplicar la regla de la conjunción, llegando a que el siguiente triple es cierto:
    \begin{equation*}
        \{i>2\}\equiv \{V\land i>2\}\ i=2\ast i\ \{i>2\land i=2\cdot i\}\equiv \{i>4\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Se dan los siguientes triples de Hoare:
    \begin{gather*}
        \{j>1\}\ i=i+2;\ j=j+3;\ \{j>4\} \\
        \{i>2\}\ i=i+2;\ j=j+3;\ \{i>4\}
    \end{gather*}
    Demostrar que estos triples implican que
    \begin{equation*}
        \{j>1 \land i>2\}\ i=i+2;\ j=j+3\ \{j>4 \land i>4\}
    \end{equation*}
    ¿Qué regla se debe utilizar para la demostración?

    Se tiene de forma directa mediante la regla de la conjunción.
\end{ejercicio}

\begin{ejercicio}
    Sean $A$ y $B$ los valores iniciales de $a$ y $b$ respectivamente. Escribir un fragmento de código que tenga $\{a=A+B \land b =A-B\}$ como poscondición y demostrar que el código es correcto.\\

    En este caso, nos piden un código $C$ que cumpla:
    \begin{equation*}
        \{a=A \land b=B\}\ C\ \{a=A+B \land b =A-B\}
    \end{equation*}

    Sea $C=<a=a+b; b=a-2b>$. Buscamnos entonces demostrar los siguientes triples:
    \begin{gather*}
        \{a=A \land b=B\}\ a=a+b\ \{a=A+B \land b=B\} \\
        \{a=A+B \land b=B\}\ b=a-2b\ \{a=A+B \land b=A-B\}
    \end{gather*}

    Demostramos cada uno por separado:
    \begin{enumerate}
        \item Usando el axioma de asignación:
            \begin{align*}
                \{a=A+B \land b=B\}_{a+b}^a
                &\equiv \{a+b=A+B \land b=B\}
                \equiv\\&\equiv \{a=A\land b=B\}\ a=a+b\ \{a=A+B \land b=B\}
            \end{align*}
        \item Usando el axioma de asignación:
            \begin{align*}
                \{a=A+B &\land b=A-B\}_{a-2b}^b
                \equiv \{a=A+B \land a-2b=A-B\}
                \equiv\\& \equiv \{a=A+B \land A+B-2b=A-B\}
                \equiv\\& \equiv \{a=A+B \land b=B\}\ b=a-2b\ \{a=A+B \land b=A-B\}
            \end{align*}
    \end{enumerate}
    Usando la regla de la composición, tenemos que el código es correcto.

\end{ejercicio}

\begin{ejercicio}
    Demostrar que la siguiente sentencia tiene la poscondición ${\{x\geq 0, x^2\geq a^2\}}$:
    \begin{center}
        \verb|if a > 0 then x = a else x = -a|
    \end{center}
    Es decir, probar el triple:
    \begin{equation*}
        \{V\}\ \texttt{if a >\ 0 then x = a else x = -a}\ \{x\geq 0, x^2\geq a^2\}
    \end{equation*}~\\
    Para ello, tenemos que usar la regla del \verb|if|:
    \begin{equation*}
        \dfrac{\{P\land B\}S_1\{Q\}, \{P\land \lnot B\}S_2\{Q\}}{\{P\}\ \texttt{if B then}\ S_1\ \texttt{else}\ S_2\ \{Q\}}
    \end{equation*}
    Luego bastará con probar los triples
    \begin{gather*}
        \{a>0\} \equiv \{V \land a > 0\}\ x=a\ \{x\geq 0 \land x^2\geq a^2\} \\
        \{a\leq 0\} \equiv \{V \land a \leq 0\}\ x=-a\ \{x\geq 0 \land x^2\geq a^2\}
    \end{gather*}
    \begin{enumerate}
        \item Usando el axioma de asignación:
            \begin{equation*}
                \{a \geq 0\} \equiv \{a \geq 0 \land a^2 \geq a^2\} \equiv \{x\geq 0 \land x^2\geq a^2\}^x_{a}\ x=a\ \{x\geq 0 \land x^2\geq a^2\}
            \end{equation*}
            Como $\{a>0\}\rightarrow\{a\geq 0\}$, usamos la segunda regla de la consecuencia y tenemos el primer triple demostrado.
        \item Usando el axioma de asignación:
            \begin{equation*}
                \{a \leq 0\} \equiv \{-a \geq 0 \land a^2 \geq a^2\} \equiv \{x\geq 0 \land x^2\geq a^2\}^x_{-a}\ x=-a\ \{x\geq 0 \land x^2\geq a^2\}
            \end{equation*}
    \end{enumerate}
    Y acabamos de probar el triple que nos pedía el ejercicio.
\end{ejercicio}

\begin{ejercicio}
    El siguiente fragmento de código tiene $\{P\}\equiv \left\{sum = \frac{j(j-1)}{2}\right\}$ como precondición y poscondición. Demostrar que es verdadero:
    \begin{equation*}
        \{P\}\ sum=sum+j;\ j=j+1;\ \{P\}
    \end{equation*}

    Queremos demostrar el triple:
    \begin{equation*}
        \left\{sum=\frac{j(j-1)}{2} \right\}\ sum=sum+j;\ j=j+1;\ \left\{sum=\frac{j(j-1)}{2}\right\}
    \end{equation*}
    Para ello, será suficiente con demostrar los triples
    \begin{gather*}
        \left\{sum = \frac{j(j-1)}{2} \right\}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \right\} \\
        \left\{sum = \frac{(j+1)j}{2} \right\}\ j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
    \end{gather*}
    y aplicar la regla de composición.

    \begin{enumerate}
        \item Para demostrar el primer triple, usamos el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \right\}^{sum}_{sum+j}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \right\} 
            \end{equation*}
            Usando la definición de Sustitución Textual, tenemos que:
            \begin{gather*}
                \left\{sum = \frac{(j+1)j}{2} \right\}^{sum}_{sum+j} \equiv \left\{sum+j = \frac{(j+1)j}{2} \right\} \equiv \\ 
                \equiv \left\{sum = \frac{(j+1)j}{2}-j \right\} \equiv \left\{sum = \frac{j(j-1)}{2} \right\}
            \end{gather*}
        \item Para el segundo, usamos también el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
            \end{equation*}
            Usando de nuevo la definición de Sustitución Textual, tenemos que:
            \begin{gather*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} \equiv \left\{sum = \frac{(j+1)(j+1-1)}{2}\right\} \equiv \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{gather*}
    \end{enumerate}
    Por lo que el triple del enunciado es cierto.

\end{ejercicio}

\begin{ejercicio}
    Demostrar que
    \begin{equation*}
        \{i\ast j + 2 \ast j + 3\ast i = 0\}\ j=j+3;\ i=i+2;\ \{i\ast j=6\}
    \end{equation*}

    Vamos buscando aplicar la regla de la composición. Para ello, y como desconocemos el estado intermedio por el que debemos pasar, usamos directamente la Sustitución Textual al final, para así obtener la precondición del segundo triple.
    \begin{equation*}
        \{i\ast j=6\}_{i+2}^i \equiv \{(i+2)\ast j=6\} \equiv \{i\ast j+2\ast j=6\} \equiv \{j\ast(i+2)=6\}
    \end{equation*}

    Usando esa precondición, el segundo libre se demuestra directamente con el axioma de asignación. Demostramos ahora el primer triple:
    \begin{gather*}
        \{i\ast j + 2 \ast j + 3\ast i = 0\}\ j=j+3;\ \{j\ast(i+2)=6\}
    \end{gather*}

    Usando la sustitución textual, tenemos que:
    \begin{align*}
        \{j\ast(i+2)=6\}_{j+3}^j &\equiv \{(j+3)\ast(i+2)=6\} \equiv
        \{j\ast(i+2)+3\ast(i+2)=6\} \equiv \\ &\equiv \{i\ast j + 2 \ast j + 3\ast i = 0\}
    \end{align*}

    Por lo que, tras usar la regla de la composición, vemos que el triple del enunciado es cierto.
\end{ejercicio}

\begin{ejercicio}
    ¿Por qué en la regla del \verb|while B|, la condición \verb|B| debe ser verdadera al comienzo del bucle?

\end{ejercicio}

\begin{ejercicio}
    Considerar una función con dos argumentos que se usa en un programa. Explicar por qué el uso de alias puede ser un problema en este caso.

\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente fragmento de programa:
    \begin{minted}{pascal}
        sum:= 0; j:= 1;
        while j <> c do begin {<> es !=}
            sum:= sum+j;
            j:= j+1;
        end
        {sum = c*(c-1)/2}
    \end{minted}

    Para ello, tenemos que hacer uso de la regla de la iteración: 
    \begin{equation*}
        \dfrac{\{I\land B\}S\{I\}}{\{I\}\ \texttt{while B do}\ S\ \texttt{end do}\ \{I\land \lnot B\}}
    \end{equation*}

    Identificando términos, sean:
    \begin{align*}
        I &\equiv sum = \frac{j(j-1)}{2} \\
        B &\equiv j \neq c \\
        S &= sum = sum+j;\ j = j+1
    \end{align*}
    Luego tendremos que probar que se cumple el triple
    \begin{equation*}
        \left\{sum=\frac{j(j-1)}{2} \land j\neq c\right\}\ sum=sum+j;j=j+1;\ \left\{sum=\frac{j(j-1)}{2}\right\}
    \end{equation*}
    Para ello, será suficiente con demostrar los triples
    \begin{gather*}
        \left\{sum = \frac{j(j-1)}{2} \land j\neq c\right\}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} \\
        \left\{sum = \frac{(j+1)j}{2} \land j\neq c\right\}\ j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
    \end{gather*}
    y aplicar la regla de composición.

    \begin{enumerate}
        \item Para demostrar el primer triple, usamos el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\}^{sum}_{sum+j}\ sum = sum + j;\ \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} 
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\}^{sum}_{sum+j} \equiv \left\{sum+j = \frac{(j+1)j}{2} \land j \neq c\right\} \equiv \\ 
                \equiv \left\{sum = \frac{(j+1)j}{2}-j \land j \neq c\right\} \equiv \left\{sum = \frac{j(j-1)}{2} \land j \neq c\right\}
            \end{gather*}
        \item Para el segundo, usamos también el axioma de asignación:
            \begin{equation*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} j=j+1;\ \left\{sum = \frac{j(j-1)}{2}\right\}
            \end{equation*}
            \begin{gather*}
                \left\{sum = \frac{j(j-1)}{2}\right\}^j_{j+1} \equiv \left\{sum = \frac{(j+1)(j+1-1)}{2}\right\} \equiv \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{gather*}
            Además, tenemos que se tiene:
            \begin{equation*}
                \left\{sum = \frac{(j+1)j}{2} \land j \neq c\right\} \rightarrow \left\{sum = \frac{(j+1)j}{2}\right\}
            \end{equation*}
            Por tanto, usando la segunda regla de la consecuencia, tenemos que el segundo triple es cierto.
    \end{enumerate}

    Por tanto, mediante la regla de la iteración, tenemos que:
    \begin{equation*}
        \left\{sum=\frac{j(j-1)}{2}\right\}\ \texttt{while j <> c do begin sum:= sum+j; j:= j+1 end}\ \left\{sum=\frac{c(c-1)}{2}\right\}
    \end{equation*}
    Como inicialmente $j=1$ y $sum=0$, tenemos que este triple coincide con el enunciado del ejercicio.
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección del siguiente triple:
    \begin{equation*}
        \{a[i]\geq 0\}\ a[i]=a[i]+a[j];\ \{a[i]\geq a[j]\}
    \end{equation*}

    Distinguimos en función de los valores de $i$ y $j$:
    \begin{itemize}
        \item Si $i=j$, entonces la poscondición queda $\{V\}$, luego el siguiente triple es cierto:
        \begin{equation*}
            \{V\}\ a[i]=a[i]+a[i];\ \{a[i]\geq a[i]\}\equiv \{V\}
        \end{equation*}

        Por tanto, como $\{a[i]\geq 0\}\subset \{V\}$, se tiene que $\{a[i]\geq 0\}\rightarrow \{V\}$, por lo que el triple del enunciado es cierto.
        \item Si $i\neq j$, entonces basta aplicar el axioma de la asignación:
        \begin{equation*}
            \{a[i]\geq a[j]\}_{a[i]+a[j]}^{a[i]}\ a[i]=a[i]+a[j];\ \{a[i]\geq a[j]\}
        \end{equation*}
        \begin{equation*}
            \{a[i]\geq a[j]\}_{a[i]+a[j]}^{a[i]}\ \equiv \{a[i]+a[j]\geq a[j]\} \equiv \{a[i] \geq 0\}
        \end{equation*}
    \end{itemize}
\end{ejercicio}


\begin{ejercicio}
    Verificar el siguiente segmento de programa:
    \begin{gather*}
        \{n\geq 0\}\\ 
        i = 1;\\
        \texttt{while\ } i\leq n \texttt{\ do\ begin}\\
        a[i] = b[i]; \\
        i=i+1;\\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (a[i]=b[i])\right\}
    \end{gather*}
    Para ello, como tenemos que demostrar la corrección de un bucle, hemos de buscar un invariante global que nos lleve a la poscondición indicada. Queremos demostrar que el programa copia el vector \verb|b| en el \verb|a|, por lo que un invariante que puede servirnos es
    \begin{equation*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i-1}(a[j] = b[j])\right\}
    \end{equation*}
    Primero, comprobamos que el invariante es cierto antes de entrar al bucle, es decir:
    \begin{gather*}
        \{n\geq 0\}\ i = 1;\ \{I\}
    \end{gather*}
    \begin{itemize}
        \item Usando el axioma de asignación, tenemos que:
            \begin{gather*}
                \{n\geq 0\}\ i = 1;\ \{n\geq 0 \land i = 1\}
            \end{gather*}

        \item Usando la regla de la consecuencia tenemos que es cierto, ya que:
        \begin{gather*}
            \{n\geq 0 \land i = 1\}\rightarrow \{i=1\} \equiv \left\{\bigwedge_{j=1}^{i-1}(a[j] = b[j]) \land i = 1\right\} \rightarrow \{I\}
        \end{gather*}
    \end{itemize}
    Posteriormente, hemos de demostrar que $\{I \land B\}\ S\ \{I\}$ con $\{B\} \equiv \{i \leq n\}$ y $S$ el cuerpo del bucle para poder aplicar la regla de la iteración.
    Esto lo hacemos empleando la regla de la composición y la regla de la consecuencia:
    \begin{gather*}
        \{I \land B\} \equiv \left\{\bigwedge_{j=1}^{i-1}(a[j]=b[j]) \land i\leq n\right\} \\
        a[i] = b[i]; \\
        \left\{\bigwedge_{j=1}^{i}(a[j]=b[j]) \land i\leq n\right\} \\
        i = i + 1; \\
        \left\{\bigwedge_{j=1}^{i-1}(a[j]=b[j]) \land i\leq n+1\right\} \rightarrow \{I\}
    \end{gather*}
    Habiendo demostrado que dicho triple es cierto, podemos aplicar la regla de iteración. Usando esta y la regla de la consecuencia, tenemos que:
    \begin{gather*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i-1}(a[j]= b[j])\right\} \\
        \texttt{while\ } i\leq n \texttt{\ do\ begin}\\
        a[i] = b[i]; \\
        i=i+1;\\
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{\bigwedge_{j=1}^{i-1} (a[j]=b[j]) \land i > n\right\} \equiv \left\{\bigwedge_{j=1}^{i-1} (a[j]=b[j]) \land i-1 \geq n\right\} \rightarrow \left\{\bigwedge_{j=1}^{n} (a[j]=b[j])\right\}
    \end{gather*}
    Uniendo por tanto los triples, mediante la regla de la composición tenemos que:
    \begin{gather*}
        \{n\geq 0\}\\ 
        i = 1;\\
        \{I\}\\
        \texttt{while\ } i\leq n \texttt{\ do\ begin}\\
        a[i] = b[i]; \\
        i=i+1;\\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (a[i]=b[i])\right\}
    \end{gather*}
    Esto es por tanto cierto, y hemos demostrado la corrección del programa.
\end{ejercicio}

\begin{ejercicio}
    El siguiente fragmento de programa calcula $\displaystyle\sum_{i=1}^{n} i!$. Demostrar que es correcto.
    \begin{minted}{pascal}
        i = 1; sum = 0; f = 1;
        while i <> n+1 do begin     {<> es !=}
          sum = sum + f;
          i = i + 1;
          f = f * i;
        end
    \end{minted}
    Para ello, usaremos la regla de iteración:
    \begin{equation*}
        \dfrac{\{I \land B\}\ S\ \{I\}}{\{I\}\ \texttt{while\ } B \texttt{\ do\ begin\ } S \texttt{\ end\ do}\ \{I \land \lnot B\}}
    \end{equation*}
    Por lo que tenemos que buscar un invariante global $I$ que nos permita concluir al final que el programa calcula $\displaystyle\sum_{i=1}^{n} i!$.

    Observando el código, podemos ver que en \verb|sum| va almacenando dicho número, mientras incrementa \verb|i| en cada iteración y va calculando en \verb|f| el factorial de \verb|i|. Planteamos por tanto el siguiente invariante $I$:
    \begin{equation*}
        \{I\} \equiv \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i! \right\}
    \end{equation*}
    En primer lugar, demostramos el triple para comprobar que el invariante es cierto al inicio del programa:
    \begin{gather*}
        \{V\}\ i = 1;\ sum = 0;\ f=1;\ \{I\}
    \end{gather*}
    Este es directamente cierto usando el axioma de asignación:
    \begin{equation*}
        \{V\}\ i=1;\ sum=0;\ f=1;\ \{i=1 \land sum = 0 \land f = 1\}\equiv \left\{i=1 \land f=1! \land sum = \sum_{j=1}^0 j! = 0\right\}
    \end{equation*}
    A continuación, trataremos de probar el triple $\{I \land B\}\ S\ \{I\}$, para $B \equiv \{i \neq n+1\}$ y $S$ el cuerpo del bucle:
    \begin{gather*}
        \{I \land B\} \equiv \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i! \land i\neq n+1\right\} \\
        sum = sum + f; \\
        \left\{ sum = \left(\sum_{j=1}^{i-1} j!\right)+i! \land f = i! \land i\neq n+1\right\} \equiv \left\{ sum = \sum_{j=1}^{i} j! \land f = i! \land i\neq n+1\right\} \\
        i = i + 1; \\
        \left\{ sum = \sum_{j=1}^{i-1} j! \land f = (i-1)! \land i\neq n+2\right\} \\
        f = f * i; \\
        \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i\cdot (i-1)! \land i\neq n+2\right\} \equiv \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i! \land i\neq n+2\right\} \rightarrow \{I\}
    \end{gather*}
    Luego podemos aplicar la regla de iteración, para obtener finalmente que:
    \begin{gather*}
        \{I\} \equiv \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i!\right\} \\
        \texttt{while\ } i \neq n+1 \texttt{\ do\ begin} \\
        sum = sum + f; \\
        i = i + 1;\\
        f = f * i;\\ 
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{ sum = \sum_{j=1}^{i-1} j! \land f = i! \land i = n+1\right\} \rightarrow  \left\{sum = \sum_{j=1}^n j! \land f = (n+1)! \right\}
    \end{gather*}
    Si tomamos \verb|sum| como la salida del programa, tenemos probado lo que queríamos.
\end{ejercicio}

\begin{ejercicio}
    Hallar la precondición $\{P\}$ que hace que el siguiente triple sea correcto:
    \begin{equation*}
        \{P\}\ a[i]=2\ast b;\ \{j\leq i ~\land~ k < i ~\land~ a[i] + a[j-1]+a[k]>b\}
    \end{equation*}
    Para ello, basta aplicar el axioma de asignación:
    \begin{gather*}
        \{j\leq i~\land~ k < i ~\land~ a[i] + a[j-1]+a[k]>b\}_{2\cdot b}^{a[i]} a[i]=2\ast b;\\ \{j\leq i ~\land~ k < i ~\land~ a[i] + a[j-1]+a[k]>b\}
    \end{gather*}

    Usando la definición de Sustitución Textual, tenemos que:
    \begin{gather*}
        \{j\leq i~\land~ k < i ~\land~ a[i] + a[j-1]+a[k]>b\}_{2\cdot b}^{a[i]} \equiv \\ \equiv \{j\leq i ~\land~ k < i ~\land~ 2\cdot b + a[j-1]+a[k]>b\}
        \ \equiv\\ \equiv \{j\leq i ~\land~ k < i ~\land~ b + a[j-1]+a[k]>0\}
    \end{gather*}
    Luego estamos buscando la precondición:
    \begin{equation*}
        \{P\} \equiv \{j\leq i ~\land~ k < i ~\land ~b + a[j-1]+a[k]>0\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Demostrar que para $n>0$ el siguiente fragmento de programa termina.
    \begin{minted}{pascal}
        i = 1; f = 1;
        while i <> n do begin
          i = i + 1;
          f = f * i;
        end
    \end{minted}

    La condición del bucle es $B=\{i \neq n\}$, y en esa condición, la única variable ``variante'' es \verb|i|.
    El vector variante de dicha condición está formado por los valores de \verb|i|, es decir, es:
    $$\{1, 2, \ldots, n\}$$

    Por tanto, nada impide que se llegue a $i=n$, y por tanto el bucle termina.
\end{ejercicio}

\begin{ejercicio}
    Hallar la precondición de la terna:
    \begin{equation*}
        \{P\}\ a[i]=b;\ \{a[j] = 2\ast a[i]\}
    \end{equation*}
    Para ello, simplemente aplicamos el axioma de asignación, distinguiendo en función de $i$ y $j$:
    \begin{itemize}
        \item Si $i\neq j$:
        \begin{equation*}
            \{a[j]=2\ast b\} \equiv \{a[j]=2\ast a[i]\}_{b}^{a[i]}\ a[i]=b;\ \{a[j] = 2\ast a[i]\}
        \end{equation*}
        \item Si $i= j$:
        \begin{equation*}
            \{b=0\}\equiv \{b=2\ast b\} \equiv \{a[i]=2\ast a[i]\}_{b}^{a[i]}\ a[i]=b;\ \{a[i] = 2\ast a[i]\}
        \end{equation*}
    \end{itemize}
\end{ejercicio}

\begin{ejercicio}
    Para cada uno de los siguientes fragmentos de código, obtener la poscondición apropiada:
    \begin{enumerate}
        \item $\{i<10\}\ i=2\ast i+1;$.\\
            La poscondición es $\{i<21\}$:
            \begin{equation*}
                \{i<10\}\ i=2\ast i+1; \{i<21\}
            \end{equation*}
            que puede demostrarse aplicando el axioma de asignación.
        \item $\{i>0\}\ i=i-1;$.\\
            La poscondición es $\{i>-1\}$:
            \begin{equation*}
                \{i>0\}\ i=i-1; \{i>-1\}
            \end{equation*}
            que puede demostrarse aplicando el axioma de asignación.
        \item $\{i>j\}\ i=i+1;\ j=j+1;$.\\
            La poscondición es $\{i>j\}$:
            \begin{gather*}
                \{i>j\}\ i=i+1;\ \{i>j+1\} \\
                \{i>j+1\}\ j=j+1;\ \{i>j\}
            \end{gather*}
            Ambos pueden demostrarse aplicando el axioma de asignación y finalmente tenemos que:
            \begin{equation*}
                \{i>j\}\ i=i+1;\ j=j+1;\ \{i>j\}
            \end{equation*}
            aplicando la regla de composición.
        \item $\{V\}\ i=3;\ j=2\ast i$.\\
            La poscondición es $\{i=3 \land j=6\}$:
            \begin{gather*}
                \{V\}\ i=3;\ \{i=3\} \\
                \{i=3\}\ j=2\ast i;\ \{i=3 \land j = 6\}
            \end{gather*}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Para cada uno de los siguientes fragmentos de código, obtener las precondiciones apropiadas.
    \begin{enumerate}
        \item $i=3\ast k;\ \{i>6\}$.\\
            Aplicando el axioma de asignación:
            \begin{equation*}
                \{k>2\} \equiv \{3\cdot k>6\} \equiv \{i>6\}^i_{3\cdot k}\ i=3\ast k;\ \{i>6\}
            \end{equation*}
            obtenemos que la precondición es $\{k>2\}$.
        \item $a=b\ast c;\ \{a=1\}$.\\
            Aplicando el axioma de asignación:
            \begin{equation*}
                \{b = c^{-1}\} \equiv \{b\cdot c = 1\} \equiv \{a=1\}^a_{b\cdot c}\ a=b\ast c;\ \{a=1\}
            \end{equation*}
        La precondición es $\{b=c^{-1}\}$.
        \item $b=c-2;\ a=a/b;$.
        
        Como no se especifica la poscondición, consideremos que esta es la más débil, $\{V\}$. Como se divide entre $b$, la precondición de la segunda instrucción debe ser $b\neq 0$. Es decir:
        \begin{equation*}
            \{b\neq 0\}\ a=a/b;\ \{V\}
        \end{equation*}

        Aplicando ahora el axioma de sustitución, tenemos que el siguiente triple es cierto:
        \begin{equation*}
            \{c\neq 2\}\equiv \{c-2\neq 0\} \equiv \{b\neq 0\}_{c-2}^b\ b=c-2;\ \{b\neq 0\}
        \end{equation*}

        Por tanto, la precondición es $\{c\neq 2\}$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Obtener la poscondición más fuerte posible del siguiente código. Indicar todas las reglas usadas.
    \begin{equation*}
        \{y>0\}\ xa=x+y;\ xb=x-y;
    \end{equation*}
    
    
    Respecto de la primera instrucción, tenemos por el axioma de asignación que:
    \begin{equation*}
        \{y>0\}\ xa=x+y;\ \{xa>x,\ y>0\}
    \end{equation*}

    Para la segunda instrucción, por el axioma de asignación, tenemos que:
    \begin{equation*}
        \{xa>x,\ y>0\}\ xb=x-y;\ \{xb<xa-y,\ y>0\}
    \end{equation*}

    Por tanto, por la regla de composición, tenemos que:
    \begin{equation*}
        \{y>0\}\ xa=x+y;\ xb=x-y;\ \{xb<xa-y,\ y>0\}
    \end{equation*}

    Aunque no se pide, como poscondición más débil, podemos obtener que:
    \begin{equation*}
        \{y>0\}\ xa=x+y;\ xb=x-y;\ \{xa>xb\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Verificar el siguiente código, indicando todas las reglas usadas.
    \begin{equation*}
        \{V\}\ \texttt{if x < 0 then x = -x}\ \{x\geq 0\}
    \end{equation*}
    Para comenzar, probamos que $\{x<0\}\ x=-x;\ \{x\geq 0\}$ usando el axioma de asignación:
    \begin{equation*}
        \{x\leq0\} \equiv \{-x\geq 0\} \equiv \{x\geq 0\}^x_{-x}\ x=-x;\ \{x\geq 0\}
    \end{equation*}
    Y como $\{x<0\}\rightarrow \{x\leq 0\}$, tenemos que el triple $\{x<0\}\ x=-x;\ \{x\geq 0\}$ es cierto, por fortalecer la precondición.\\
    Posteriormente, como sabemos que $\{V \land (x<0)\}\equiv \{x<0\}$ y que ${\{x\geq 0\}\ null\ \{x\geq 0\}}$ por el axioma de la sentencia nula, podemos aplicar la regla del \texttt{if}:
    \begin{equation*}
        \dfrac{\{V \land (x<0)\}\ x=-x;\ \{x\geq 0\}, \{V \land x\geq 0\}\ null\ \{x\geq 0\}}{\{V\}\ \texttt{if\ }x<0 \texttt{\ then\ }x=-x \texttt{\ else\ null\ } \{x\geq 0\}}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}\label{ej_rel1_44}
    Verificar el siguiente segmento de programa:
    \begin{gather*}
        max = a[1]; i = 1; \\
        \texttt{while\ } i <> n+1 \texttt{\ do\ begin} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i];\\
        i=i+1; \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (max \geq a[i])\right\}
    \end{gather*}
    Es decir, tenemos que probar que el código anterior calcula el máximo del vector \verb|a| de longitud \verb|n| (suponiendo que las posiciones van desde \verb|1| hasta \verb|n|), que se almacena en \verb|max|. Al tratarse de un bucle, hemos de buscar un invariante global para poder aplicar la regla de iteración. El invariante global que usamos\footnote{Para buscarlo, hemos de pensar en una regla que se mantenga iteración tras iteración.} es el siguiente:
    \begin{equation*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j])\right\}
    \end{equation*}
    Para comenzar, hemos de ver que el invariante es cierto al inicio del programa, es decir, que:
    \begin{equation*}
        \{V\}\ max = a[1];\ i=1;\ \{I\}
    \end{equation*}
    Lo cual es cierto, ya que:
    \begin{gather*}
        \{V\}\ max=a[1];\ i=1;\ \{max = a[1] \land i = 1\} \\ 
        \{max = a[1] \land i = 1\}\rightarrow \{max \geq a[1] \land i=1\} \rightarrow \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i = 1\right\} \rightarrow \{I\}
    \end{gather*}
    Posteriormente, pasaremos a demostrar el triple $\{I \land B\}\ S\ \{I\}$ con $\{B\} \equiv \{i\neq n+1\}$ y $S$ el cuerpo del bucle para poder aplicar la regla de iteración:
    \begin{gather*}
        \{I \land B\} \equiv \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i\neq n+1\right\} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i];\\
        \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land i\neq n+1\right\} \\
        i = i +1; \\
        \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i\neq n+2\right\} \rightarrow \{I\}
    \end{gather*}
    Donde hemos usando que el siguiente triple es cierto:
    \begin{gather*}
        \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i\neq n+1\right\} \\ \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i];\\ \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land i\neq n+1\right\} 
    \end{gather*}
    Para comprobar su veracidad, hemos de ver que:
    \begin{gather*}
    \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i\neq n+1 \land a[i] \geq max\right\}\ max = a[i];\ \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land i\neq n+1\right\} \\
    \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i\neq n+1 \land max > a[i]\right\}\ null;\ \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land i\neq n+1\right\} \\
    \end{gather*}
    
    Como ambos se verifican, por la regla del \texttt{if} el triple anterior es cierto, por lo que (usando la regla de la composición), tenemos que $\{I\land B\}\ S\ \{I\}$ es cierto. Por tanto, podemos aplicar la regla de la iteración, y obtener que:
    \begin{gather*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j])\right\} \\
        \texttt{while\ } i <> n+1 \texttt{\ do\ begin} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i];\\
        i=i+1; \\
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land i=n+1\right\} \equiv \left\{\bigwedge_{j=1}^{n} (max \geq a[j])\right\}
    \end{gather*}
    
    Como hemos probado inicialmente que $\{V\}\ max = a[1];\ i=1;\ \{I\}$, por la regla de la composición, hemos demostrado la corrección del programa.
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código:
    \begin{gather*}
        max = a[1]; i = 1; \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i +1; \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i]; \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n (max \geq a[i]), \bigvee_{j=1}^n (max = a[i]) \right\}
    \end{gather*}

    Para demostrar la corrección del programa, hemos de buscar un invariante global que nos permita llegar a la poscondición. Observando el código, vemos que lo que hace es almacenar en \verb|max| el máximo del vector \verb|a| de longitud \verb|n| (de nuevo, suponiendo que las posiciones van desde \verb|1| hasta \verb|n|). Por tanto, un invariante que nos puede servir es:
    \begin{equation*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j])\right\}
    \end{equation*}

    En primer lugar, hemos de ver que el invariante es cierto al inicio del programa:
    \begin{equation*}
        \{V\}\ max = a[1];\ i=1;\ \{I\}
    \end{equation*}
    Esto sabemos que es cierto, ya que:
    \begin{gather*}
        \{V\}\ max = a[1];\ i=1;\ \{max = a[1] \land i = 1\} \\
        \{max = a[1] \land i = 1\}\rightarrow \{max \geq a[1] \land max = a[1] \land i = 1\} \rightarrow \{I\}
    \end{gather*}

    Posteriormente, hemos de demostrar el triple $\{I \land B\}\ S\ \{I\}$ con $\{B\} \equiv \{i < n\}$ y $S$ el cuerpo del bucle para poder aplicar la regla de iteración:
    \begin{gather*}
        \{I \land B\} \equiv \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i < n\right\} \\
        i = i + 1; \\
        \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land \bigvee_{j=1}^{i-1} (max = a[j]) \land i < n+1\right\} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i]; \\
        \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i < n+1\right\} \rightarrow \{I\}
    \end{gather*}
    Donde hemos usado que el siguiente triple es cierto:
    \begin{gather*}
        \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land \bigvee_{j=1}^{i-1} (max = a[j]) \land i < n+1\right\} \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i]; \\
        \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i < n+1\right\}
    \end{gather*}
    Para comprobar su veracidad, hemos de ver que:
    \begin{gather*}
    \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land \bigvee_{j=1}^{i-1} (max = a[j]) \land i < n+1 \land a[i] \geq max\right\}\ max = a[i];\ \\\hspace{20em}\left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i < n+1\right\} \\
    \left\{\bigwedge_{j=1}^{i-1} (max \geq a[j]) \land \bigvee_{j=1}^{i-1} (max = a[j]) \land i < n+1 \land max > a[i]\right\}\ null;\ \\\hspace{20em}\left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i < n+1\right\}
    \end{gather*}

    Como ambos se verifican, por la regla del \texttt{if} el triple anterior es cierto, por lo que (usando la regla de la composición), tenemos que $\{I\land B\}\ S\ \{I\}$ es cierto. Por tanto, podemos aplicar la regla de la iteración, y obtener que:
    \begin{gather*}
        \{I\} \equiv \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j])\right\} \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i + 1; \\
        \texttt{if\ } a[i] \geq max \texttt{\ then\ } max = a[i]; \\
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i \geq n\right\} \rightarrow\\\rightarrow
        \left\{\bigwedge_{j=1}^{i} (max \geq a[j]) \land \bigvee_{j=1}^{i} (max = a[j]) \land i= n\right\}
        \equiv
        \left\{\bigwedge_{j=1}^{n} (max \geq a[j]) \land \bigvee_{j=1}^{n} (max = a[j])\right\}
    \end{gather*}

    Como hemos probado inicialmente que $\{V\}\ max = a[1];\ i=1;\ \{I\}$, por la regla de la composición, hemos demostrado la corrección del programa.
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código:
    \begin{gather*}
        i = 0; j= n; \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i + 1; \\
        j = j - 1; \\
        a[i] = b[j] \\
        \texttt{end} \\
        \left\{\bigwedge_{i=1}^n(a[i] = b[n-i])\right\}
    \end{gather*}
    Como se trata de un bucle, hemos de usar la regla de iteración, por lo que buscamos un invariante globl que nos sirva. Observando el código, vemos que lo que hace es almacenar en el vector \verb|a| el vector simétrico a \verb|b| (es decir, invertir el vector \verb|b|). A partir de esta premisa, pensamos que el invariante que nos sirve puede ser:
    \begin{equation*}
        \{I\} \equiv \left\{\bigwedge_{k=1}^{i}(a[k] = b[n-k]) \land j = n-i\right\}
    \end{equation*}
    En primer lugar, hemos de ver que el invariante se verifica al inicio del programa:
    \begin{equation*}
        \{V\}\ i=0;\ j=n;\ \{I\}
    \end{equation*}
    Lo cual es cierto, ya que
    \begin{gather*}
        \{V\}\ i=0;\ j=n;\ \{i = 0 \land j = n\} \rightarrow \{I\}
    \end{gather*}
    Posteriormente, y con vistas a aplicar la regla de iteración, hemos de ver que se cumple el triple $\{I \land B\}\ S\ \{I\}$, con $\{B\} \equiv \{i < n\}$ y $S$ el cuerpo del bucle:
    \begin{gather*}
        \{I \land B\} \equiv \left\{\bigwedge_{k=1}^{i}(a[k] = b[n-k]) \land j = n-i \land i <n\right\} \\
        i = i + 1; \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k] = b[n-k]) \land j = n-i+1 \land i < n+1\right\} \\
        j = j - 1; \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k] = b[n-k]) \land j = n-i \land i < n+1\right\} \\
        a[i] = b[j]; \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k] = b[n-k]) \land a[i] = b[n-i] \land j = n-i \land i < n+1\right\} \equiv \\
        \equiv \left\{\bigwedge_{k=1}^{i}(a[k] = b[n-k]) \land j = n-i \land i < n+1\right\}\rightarrow \{I\}
    \end{gather*}

    donde hemos usado que
    \begin{equation*}
        \{j = n-i\}\ i=i+1;\ j=j-1;\ \{j = n-i\}
    \end{equation*}

    que puede probarse mediante composición de los triples
    \begin{gather*}
        \{j=n-i\}\ i=i+1;\ \{j=n-i+1\} \\
        \{j=n-i+1\}\ j=j-1;\ \{j=n-i\}
    \end{gather*}

    que sabemos que son ciertos por el axioma de asignación. \\

    Podemos finalmente aplicar la regla de iteración, llegando a que:
    \begin{gather*}
        \{I\} \equiv \left\{\bigwedge_{k=1}^{i}(a[k] = b[n-k]) \land j = n-i\right\} \\
        \texttt{while\ } i < n \texttt{\ do\ begin} \\
        i = i + 1; \\
        j = j - 1; \\
        a[i] = b[j] \\
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{\bigwedge_{k=1}^{i}(a[k] = b[n-k]) \land i\geq n\right\} \rightarrow \left\{\bigwedge_{k=1}^{n}(a[k] = b[n-k]) \right\}
    \end{gather*}
    
    Como hemos probado inicialmente que $\{V\}\ i=0;\ j=n;\ \{I\}$, por la regla de la composición, hemos demostrado la corrección del programa.
\end{ejercicio}

\begin{ejercicio}
    Demostrar la corrección parcial del siguiente código
    suponiendo el invariante:
    \begin{equation*}
        \{I\} \equiv \left\{\bigwedge_{k=1}^{i-1}(a[k] = s) \land s = \sum_{k=1}^{i-1} A[k]\right\}
    \end{equation*}
    Donde el array $A$ representa los valores iniciales del array $a$ antes de ejecutar el programa.
    \begin{minted}{pascal}
        i = 0;
        s = 0;
        while i <= n do begin
          s = s + a[i];
          a[i] = s;
          i = i + 1;
        end
    \end{minted}

    Para ello, primero hemos de ver que el invariante es cierto al inicio del programa:
    \begin{equation*}
        \{V\}\ i=0;\ s=0;\ \{I\}
    \end{equation*}
    Lo cual es cierto. A continuación:
    \begin{gather*}
        \{I\} \equiv \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k]\right\} \\
        \texttt{while\ } i\leq n \texttt{\ do\ begin} \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k] \land i \leq n\right\} \\
        s = s + a[i]; \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k] + A[i] \land i \leq n\right\} \equiv \\ \equiv  \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i}A[k] \land i \leq n\right\} \\
        a[i] = s; \\
        \left\{\bigwedge_{k=1}^{i}(a[k]=s) \land s = \sum_{k=1}^{i}A[k] \land i \leq n\right\} \\
        i = i + 1; \\
        \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k] \land i-1 \leq n\right\} \rightarrow \left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k] \right\} \equiv \{I\} \\
        \texttt{end} \\
\left\{\bigwedge_{k=1}^{i-1}(a[k]=s) \land s = \sum_{k=1}^{i-1}A[k] \land i > n \right\} 
    \end{gather*}
    Donde en el último paso hemos aplicado la regla de la iteración: como $\{I\land B\}\ C\ \{I\}$ siendo $B = i\leq n$ y $C$ el cuerpo del bucle, entonces se tiene que:
    \begin{equation*}
        \{I\}\ \texttt{while\ } B\texttt{\ do\ } C \texttt{\ end}\ \{I \land \lnot B\}
    \end{equation*}
    Finalmente, tendremos que:
    \begin{equation*}
        \left\{\bigwedge_{k=1}^{n}(a[k]=s) \land s = \sum_{k=1}^{n}A[k]\right\}
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Dados $i,n\geq 0$, $i\leq n$, demostrar que el siguiente segmento de progama evalúa
    \begin{equation*}
        \dfrac{n!}{i!(n-i)!}
    \end{equation*}
    \begin{minted}{pascal}
        k = 0; fact = 1;
        while k <> n do begin
          k = k + 1;
          fact = fact * k;
          if k <= i then afact = fact;
          if k <= n-i then bfact = fact;
        end
        bcof = fact/(afact*bfact);
    \end{minted}

    Para demostrar que el código evalúa $\dfrac{n!}{i!(n-i)!}$, hemos de buscar un invariante global que nos permita llegar a la poscondición. Observando el código, vemos que lo que hace es calcular el factorial de \verb|n| y almacenar en \verb|afact| el factorial de \verb|i| y en \verb|bfact| el factorial de \verb|n-i|. Por tanto, un invariante que nos puede servir es:
    \begin{equation*}
        \{I\} \equiv \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})!\right\}
    \end{equation*}

    En primer lugar, hemos de ver que el invariante es cierto al inicio del programa:
    \begin{equation*}
        \{0\leq i\leq n\}\ k=0;\ fact=1;\ \{I\}
    \end{equation*}
    Lo cual es directamente cierto\footnote{Notemos que, para demostrar esto, hemos de suponer valores iniciales de \texttt{afact} y \texttt{bfact}, algo que no supone problema alguno.}. Posteriormente, hemos de demostrar el triple dado por $\{I \land B\}\ S\ \{I\}$ con $\{B\} \equiv \{k \neq n\}$ y $S$ el cuerpo del bucle para poder aplicar la regla de iteración:
    \begin{gather*}
        \{I \land B\} \equiv \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})! \land k \neq n\right\} \\
        k = k + 1; \\
        \left\{fact = (k-1)! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\} \\
        fact = fact * k; \\
        \left\{fact = k! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\} \\
        \texttt{if\ } k \leq i \texttt{\ then\ } afact = fact; \\
        \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\} \\
        \texttt{if\ } k \leq n-i \texttt{\ then\ } bfact = fact; \\
        \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})! \land k \neq n+1\right\} \rightarrow \{I\}
    \end{gather*}
    donde hemos empleado dos veces la regla del \texttt{if}, veámoslo:
    \begin{itemize}
        \item En primer lugar, hemos de demostrar el siguiente triple:
        \begin{gather*}
            \left\{fact = k! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\} \\
            \texttt{if\ } k \leq i \texttt{\ then\ } afact = fact; \\
            \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}
        \end{gather*}

        Para demostrarlo, hemos de demostrar los dos siguientes triples:
        \begin{itemize}
            \item En primer lugar, hemos de demostrar que:
            \begin{gather*}
                \hspace{-1.8cm}\left\{fact = k! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1 \land k \leq i\right\} \\
                afact = fact; \\
                \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}
            \end{gather*}

            Usando la segunda regla de la consecuencia, la sustitución textual y el axioma de asignación, tenemos que:
            \begin{gather*}
                \hspace{-1.8cm}\left\{fact = k! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1 \land k \leq i\right\} \rightarrow \\
                \rightarrow\left\{fact = k! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1 \land k\leq i\right\}\equiv \\
                \equiv\left\{fact = k! \land k! = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}\equiv \\
                \equiv\left\{fact = k! \land fact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}\equiv \\
                \equiv \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}_{{fact}}^{{afact}} \\
                afact = fact; \\
                \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}
            \end{gather*}

            \item En segundo lugar, hemos de demostrar que:
            \begin{gather*}
                \hspace{-1.8cm}\left\{fact = k! \land afact = (\min\{i,k-1\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1 \land k > i\right\} \\
                null \\
                \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\}
            \end{gather*}

            Teniendo en cuenta que $k>i \Longrightarrow k-1 \geq i$, luego $\min\{i,k-1\} = i = \min\{i,k\}$, este sale directo usando el axioma de la sentencia nula y la regla de la consecuencia.
        \end{itemize}

        \item En segundo lugar, hemos de demostrar el siguiente triple:
        \begin{gather*}
            \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k-1\})! \land k \neq n+1\right\} \\
            \texttt{if\ } k \leq n-i \texttt{\ then\ } bfact = fact; \\
            \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})! \land k \neq n+1\right\}
        \end{gather*}

        Esta demostración es análoga a la anterior, por lo que no la repetiremos.        
    \end{itemize}

    Habiendo demostrado que $\{I \land B\}\ S\ \{I\}$, podemos aplicar la regla de iteración, llegando a que:
    \begin{gather*}
        \{I\} \equiv \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})!\right\} \\
        \texttt{while\ } k <> n \texttt{\ do\ begin} \\
        k = k + 1; \\
        fact = fact * k; \\
        \texttt{if\ } k \leq i \texttt{\ then\ } afact = fact; \\
        \texttt{if\ } k \leq n-i \texttt{\ then\ } bfact = fact; \\
        \texttt{end} \\
        \{I \land \lnot B\} \equiv \left\{fact = k! \land afact = (\min\{i,k\})! \land bfact = (\min\{n-i,k\})! \land k=n\right\}
    \end{gather*}

    Usando la regla de la composición (ya que hemos probado que $\{V\}\ k=0;\ fact=1;\ \{I\}$), y usando que $i\leq n$, tenemos que:
    \begin{gather*}
        \{V\}\ \\
        k=0;\ fact=1;
        \texttt{while\ } k <> n \texttt{\ do\ begin} \\
        k = k + 1; \\
        fact = fact * k; \\
        \texttt{if\ } k \leq i \texttt{\ then\ } afact = fact; \\
        \texttt{if\ } k \leq n-i \texttt{\ then\ } bfact = fact; \\
        \texttt{end} \\
        \left\{fact = k! \land afact = i! \land bfact = (n-i)!\right\} \\
        bcof = fact/(afact*bfact); \\
        \left\{bcof = \dfrac{n!}{i!(n-i)!}\right\}
    \end{gather*}
    donde para demostrar el último triple hemos empleado la segunda regla de la consecuencia, la sustitución textual y el axioma de asignación.

        % \item [Versión 2.]~\\
    % A continuación, repetimos el ejercicio, probando ahora con el invariante:
    % \begin{equation*}
        % \{I\} \equiv \{(i>k \lor afact = i!) \land (n-i>k \lor bfact = (n-i)!)\}
    % \end{equation*}
    % En primer lugar, hemos de ver que el invariante es cierto al inicio del programa:
    % \begin{equation*}
        % \{0\leq i\leq n\}\ k=0;\ fact=1;\ \{I\}
    % \end{equation*}
    % Lo cual es cierto si suponemos al inicio del programa que $afact = i!$ y que $bfact = (n-i)!$. Pasamos a probar el cuerpo del bucle:
    % \begin{gather*}
        % \{(i>k \lor afact=i!) \land (n-i>k \lor bfact = (n-i)!)\} \\
        % \texttt{while\ } (k\neq n) \texttt{\ do\ begin} \\
        % \{(i>k \lor afact=i!) \land (n-i>k \lor bfact = (n-i)!) \land k \neq n\} \\
        % k = k + 1; \\
        % \{(i>k-1 \lor afact=i!) \land (n-i>k-1 \lor bfact = (n-i)!) \land k-1 \neq n\} \\
        % fact = fact \ast k; \\
        % \texttt{if\ } (k\leq i) \texttt{\ then} \\
        % afact = fact; \\
        % \texttt{if\ } (k\leq n-i) \texttt{\ then} \\
        % bfact = fact; \\
        % \texttt{end} \\
        % bcof = fact/(afact\ast bfact);
    % \end{gather*}
    % \end{description}
\end{ejercicio}

\begin{ejercicio}
    Demostrar la terminación del fragmento de programa dado en el problema~\ref{ej_rel1_44} ¿Qué condición se debe imponer para realizar la demostración?
    
    En este caso, la condición del bucle es $B=\{i\neq n+1\}$. El vector variante de dicha iteración es:
    \begin{equation*}
        \{1,2,3,\ldots\}
    \end{equation*}

    Por tanto, para demostrar que llega al caso $i=n+1$ (llegando así a terminar), es necesario que $n\geq 0$.
\end{ejercicio}
