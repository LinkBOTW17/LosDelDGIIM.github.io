\section{Sincronización en Memoria Compartida}
\subsection{Exclusión mutua}
\begin{ejercicio}
    Un algoritmo para el cual sólo pudiésemos demostrar que cumple las 4 condiciones de Dijkstra, ¿qué tipo de propiedades concurrentes satisfacería?: 
    \begin{enumerate}[label=(\alph*)]
        \item seguridad.
        \item vivacidad.
        \item equidad.
    \end{enumerate}
    Justificar las respuestas.\\

    Un algoritmo para el cual solo pudiéramos demostrar las 4 condiciones de Dijkstra solo contaría con la propiedad de seguridad de alcanzabilidad (la 4ª condición) y de exclusión mutua, ya que:
    \begin{itemize}
        \item Para la propiedad de vivacidad, deberíamos demostrar que el algoritmo se encuentra libre de interbloqueos.
        \item Para la propiedad de equidad, deberíamos demostrar que cada proceso es capaz de llegar a la sección crítica en un tiempo máximo, con lo que el reparto de la sección crítica es justo para los procesos.
    \end{itemize}
\end{ejercicio}

\begin{ejercicio} % // TODO:
    En algunas aplicaciones es necesario tener exclusión mutua entre procesos con la particularidad de que puede haber como mucho $n$ procesos en una sección crítica, con $n$ arbitrario y fijo, pero no necesariamente igual a la unidad, sino posiblemente mayor. Diseña una solución para este problema basada en el uso de espera ocupada y cerrojos. Estructura dicha solución como un par de subrutinas (usando una misma estructura de datos en memoria compartida), una para el protocolo de entrada y otro el de salida, e incluye el pseudocódigo de las mismas.
\end{ejercicio}

\begin{ejercicio}\label{ej:2.3}
    ¿Podría pensarse que una posible solución al problema de la exclusión mutua, sería el siguiente algoritmo (de la Figura~\ref{fig:cod_3}) que no necesita compartir una variable \verb|turno| entre los 2 procesos? Demostrar (sí o no) se satisfacen las siguientes propiedades:
    \begin{enumerate}[label=(\alph*)]
        \item ¿la exclusión mutua? (propiedad de seguridad)
        \item ¿la ausencia de interbloqueo? (propiedad de alcanzabilidad)
    \end{enumerate}

    \begin{figure}[H]
        \centering
        \begin{minted}{pascal}
            {variables compartidas y valores iniciales}
            var b0 : boolean := false; {true si P0 quiere acceder o esta en SC}
                b1 : boolean := false; {true si P1 quiere acceder o esta en SC}
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                Process P0;
                begin
                while true do begin
                   {Protocolo de entrada}

                   {indica que quiere entrar}
                   b0 := true;
                   {si el otro también}
                   while b1 do begin
                      {cede temporalmente}
                      b0 := false;
                      {espera}
                      while b1 do begin end
                      {vuelve a cerrar el paso}
                      b0 := true;
                   end

                   {Sección crítica}
                   {Protocolo de salida}
                   b0 := false;
                   {Resto de sentencias}
                end {while}
                end
            \end{minted}
            \begin{minted}{pascal}
                Process P1;
                begin
                while true do begin
                   {Protocolo de entrada}

                   {indica que quiere entrar}
                   b1 := true;
                   {si el otro también}
                   while b0 do begin
                      {cede temporalmente}
                      b1 := false;
                      {espera}
                      while b0 do begin end
                      {vuelve a cerrar el paso}
                      b1 := true;
                   end

                   {Sección crítica}
                   {Protocolo de salida}
                   b1 := false;
                   {Resto de sentencias}
                end {while}
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.3}.}
        \label{fig:cod_3}
    \end{figure}
    El código de la Figura~\ref{fig:cod_3} se corresponde con el algoritmo correspondiente a la cuarta etapa del método de refinamiento sucesivo de Dijkstra:
    \begin{enumerate}[label=(\alph*)]
        \item La exclusión mutua puede demostrarse:
            Suponiendo que nos interesa ver las condiciones bajo las cuales el proceso P0 entra en la sección crítica (para el proceso P1 el razonamiento es análogo), este podrá entrar en la sección crítica solo si \verb|b1 = false|, que se dará siempre que:
            \begin{itemize}
                \item El proceso P1 no quiera entrar a la sección crítica (esto es, que este pasivo).
                \item O bien que haya cambiado su clave a \verb|false| en la instrucción de la línea 11, con lo que quedará bloqueado en el bucle más interno (porque \verb|b0 = true|).
            \end{itemize}
            Como ninguna de estas situaciones es compatible con que el proceso P1 entre a la vez con P0 a la sección crítica, concluimos que es imposible que P0 y P1 entren a la vez en sección crítica.
        \item La ausencia de interbloqueo no puede demostrarse:

            Si suponemos que P0 y P1 tienen velocidades de ejecución idénticas y que comienzan con su ejecución en el mismo instante, podemos observar la traza de ejecución:
            \begin{itemize}
                \item Ambos cambian su clave a \verb|true|.
                \item Ambos ven que la clave del otro está a \verb|true|.
                \item Ambos cambian su clave a \verb|false| (no ejecutan el bucle más interno).
                \item Ambos cambian su clave a \verb|true|.
                \item Ambos ven que la clave del otro está a \verb|true|.
                \item Ambos cambian su clave a \verb|false| (no ejecutan el bucle más interno).
                \item Ambos cambian su clave a \verb|true|.
                \item \ldots
            \end{itemize}
            Que lleva a un interbloqueo de ambos procesos, de forma que ninguno consiga al final entrar a al sección crítica.
    \end{enumerate}
    Ahora podemos contestar a la pregunta inicial: aunque el algoritmo garantiza la propiedad de seguridad de la exclusión mutua, como hay una situación de interbloqueo, la bondad del algoritmo depende de la velocidad de ejecución de los procesos que ejecuten el programa, por lo que decimos que no es una buena solución al problema de la exclusión mutua.
\end{ejercicio}

\begin{ejercicio}\label{ej:2.4}
    Al siguiente algoritmo (de la Figura~\ref{fig:cod_4}) se le conoce como solución de Hyman al problema de la exclusión mutua (fue publicado en una revista de impacto en 1966). ¿Es correcta dicha solución?
    \begin{figure}[H]
        \centering
        \begin{minted}{pascal}
        {variables compartidas y valores iniciales}
        var c0 : integer := 1;
            c1 : integer := 1;
            turno : integer := 1;
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                process P0;
                begin
                while true do begin
                   c0 := 0;
                   while turno <> 0 do begin
                      while c1 = 0 do begin end
                      turno := 0;
                   end

                   {Sección crítica}
                   c0 := 1;
                   {Resto de sentencias}
                end
                end
            \end{minted}
            \begin{minted}{pascal}
                process P1;
                begin
                while true do begin
                   c1 := 0;
                   while turno <> 1 do begin
                      while c0 = 0 do begin end
                      turno := 1;
                   end

                   {Sección crítica}
                   c1 := 1;
                   {Resto de sentencias}
                end
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.4}.}
        \label{fig:cod_4}
    \end{figure}
    \ \\

    No es correcta, ya que no se da la propiedad de seguridad de la exclusiún mutua: supongamos que P0 y P1 ejecutan su código de forma que se da la traza de ejecución de la Tabla~\ref{tab:ejecucion_4} (donde indicamos la línea de la instrucción que ejecuta cada proceso en cada instante).
    \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Línea de P0 & Línea de P1 & \verb|c0| & \verb|c1| & \verb|turno| \\
        \hline
        3 & 3 & 1 & 1 & 1 \\
        \hline
        4 & 3 & 0 & 1 & 1 \\
        \hline
        5 & 3 & 0 & 1 & 1 \\
        \hline
        6 & 3 & 0 & 1 & 1 \\
        \hline
        6 & 4 & 0 & 0 & 1 \\
        \hline
        6 & 5 & 0 & 0 & 1 \\
        \hline
        6 & 10 & 0 & 0 & 1 \\
        \hline
        7 & 10 & 0 & 0 & 0 \\
        \hline
        \red{10} & \red{10} & 0 & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Traza de ejecución que lleva a tener dos procesos en SC.}
    \label{tab:ejecucion_4}
    \end{table}
\end{ejercicio}

\begin{ejercicio} % // TODO:
    Supongamos el algoritmo de exclusión mutua que expresamos a continuación. Tenemos los procesos: 0, 1, \ldots, $n-1$. Cada proceso $i$ tiene una variable $s[i]$ inicializada a 0, que puede tomar los valores 0 o 1. El proceso $i$ puede entrar en la sección crítica si y solo si se cumplen las siguientes condiciones:
    \begin{align*}
        s[i] &\neq s[i-1] \text{\ para\ } i>0 \\
        s[0] &= s[n-1] \text{\ para\ } i = 0
    \end{align*}
    Tras ejecutar su sección crítica, el proceso $i$ deberá hacer:
    \begin{align*}
        s[i] &= s[i-1] \text{\ para\ } i> 0 \\
        s[0] &= (s[0] +1 ) \mod 2 \text{\ para\ } i = 0
    \end{align*}
    Se pide:
    \begin{enumerate}
        \item[(i)] Demostrar que el algoritmo anterior solo permite a un proceso acceder a la sección crítica en cualquier configuración (es decir, independientemente de los valores que pueden alcanzar las variables $s[i]$ durante la ejecución del protocolo).
        \item[(ii)] Demostrar también que cada uno de los procesos $p[i]$ conseguirá entrar en la sección crítica ``infinitamente a menudo''.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}\label{ej:2.6}
    Se tienen 2 procesos concurrentes que representan 2 máquinas expendedoras de tickets (en la Figura~\ref{fig:cod_6}) (señalan el turno en que ha de ser atendido el cliente), los números de los tickets se representan por dos variables \verb|n1| y \verb|n2| que valen inicialmente 0. El proceso con el número de ticket más bajo entra en su sección crítica. En caso de tener 2 números iguales se procesa primero el proceso número 1.
    \begin{enumerate}[label=(\alph*)]
        \item Demostrar que se verifica la ausencia de interbloqueo (propiedad de \textit{alcanzabilidad} de la sección crítica), la ausencia de inanición (propiedad de \textit{vivacidad}) y la exclusión mutua (una propiedad de \textit{seguridad}).
        \item Demostrar que las asignaciones \verb|n1:=1| y \verb|n2:=1| son ambas necesarias.
    \end{enumerate}

    \begin{figure}[H]
        \centering
        \begin{minted}{pascal}
            {variables compartidas y valores iniciales}
            var n1 : integer := 0;
                n2 : integer := 0;
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                Process P1;
                begin
                while true do begin
                   n1 := 1; {E1.1}
                   n1 := n2 + 1; {L1.1; E2.1}
                   while n2 <> 0 and {L2.1}
                         n2 < n1 do begin end; {L3.1}

                   {Sección crítica, SC.1}
                   n1 := 0; {E3.1}
                   {Resto de senetencias, RS.1}
                end
                end
            \end{minted}
            \begin{minted}{pascal}
                Process P2;
                begin
                while true do begin
                   n2 := 1; {E1.2}
                   n2 := n1 + 1; {L1.2; E2.2}
                   while n1 <> 0 and {L2.2}
                         n1 <= n2 do begin end; {L3.2}

                   {Sección crítica, SC.2}
                   n2 := 0; {E3.2}
                   {Resto de senetencias, RS.2}
                end
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.6}.}
        \label{fig:cod_6}
    \end{figure}

    \begin{enumerate}[label=(\alph*)]
        \item Demostraremos cada uno de las propiedades requeridas:
            \begin{description}
                \item [Exclusión mutua.]~\\
                    Supongamos que el proceso P1 ha conseguido entrar en su sección crítica, y veamos que mientras esto sucede, el proceso P2 no puede entrar también a la sección crítica. Para ello, supongamos pues que P1 ha entrado en la sección crítica. Entonces, tiene que haber sucedido anteriormente un momento en el que no se daba la condición de espera para P1: \verb|n2 <> 0 and n2 < n1|, con lo que habremos tenido alguno de los dos siguientes momentos:
                    \begin{itemize}
                        \item \verb|n2 = 0|, con lo que cuando P1 entró a la sección crítica, P2 había salido de la suya anteriormente. En este punto, sabemos que \verb|n1 <> 0|, ya que P1 está dentro de su sección crítica, por lo que tenemos que ver que \verb|n1 <= n2|, para concluir que P2 no puede entrar a la sección crítica.

                            Hemos razonado anteriormente que P2 salio de su sección crítica y que luego fue cuando P1 entró a la suya. Si P2 quiere volver a entrar a la sección crítica, debe volver a pasar el procolo de entrada a la misma, con lo que en algún momento ejecutará la instrucción \verb|n2 := n1 + 1;|, y como el valor de la variable \verb|n1| no es modificada por P1 mientras que este está en la sección crítica, tenemos que \verb|n1 < n1 + 1 = n2|, con lo que P2 no podrá entrar a la sección crítica.
                        \item \verb|n2 >= n1|, hasta este momento se ha tenido que ejecutar la instrucción \verb|n1 := n2 + 1|, con lo que \verb|n1 > n2|. Sin embargo, como estamos bajo las hipótesis de \verb|n2 >= n1|, también se habrá tenido que ejecutar la instrucción \verb|n2 := n1 + 1|. En este momento, tendremos que tanto \verb|n1| como \verb|n2| valen 2, con lo que P1 entrará a la sección crítica y P2 no podrá hacerlo, por ser \verb|n1 = n2|.
                    \end{itemize}
                    Supongamos ahora que P2 va a entrar a la sección crítica y vemos si P1 puede entrar tras él. Si P2 ha entrado en la sección crítica es porque en algún momento no se ha cumplido \verb|n1 <> 0 and n1 <= n2|, por lo que han tenido que darse:
                    \begin{itemize}
                        \item \verb|n1 = 0|, por un razonamiento análogo al anterior en el caso \verb|n2 = 0| llegamos a la conclusión de que P1 no puede entrar a la sección crítica.
                        \item \verb|n1 > n2|, en este caso, la instrucción \verb|n2 := n1 + 1;| ya se ha tenido que haber ejecutado, pero en dicho caso tendríamos \verb|n2 > n1|, con lo que sabemos que la instrucción \verb|n1 := n2 + 1;| se tuvo que ejecutar después. Para que P1 entre a la sección crítica con P2, tendría que suceder que \verb|n2 >= n1| (es fácil ver que \verb|n2 <> 0|), pero esto no puede suceder, porque P1 ya no puede modificar ya ninguna variable.

                            Concluimos que P1 no puede entrar a la sección crítica.
                    \end{itemize}
                \item [Alcanzabilidad.]~\\
                    \begin{itemize}
                        \item Si el proceso P1 ejecuta el protocolo de entrada mientras que P2 está ocioso (\verb|n2 = 0|), entonces P1 conseguirá alcanzar la sección crítica. Algo similar sucede cuando P1 está ocioso y es P2 quien queire entrar a la sección crítica.
                        \item Supongamos pues que ambos procesos quieren entrar a la sección crítica. Si ninguno consigue llegar a ella es porque se dan las dos condiciones de espera al mismo tiempo, con lo que tenemos:
                            \begin{equation*}
                                n2 \neq 0 \land n2 < n1 \land n1 \neq 0 \land n1 \leq n2
                            \end{equation*}
                            Es decir, $n1>n2$ y $n1\leq n2$ a la vez, lo cual es imposible, con lo que algún proceso conseguirá entrar a la sección crítica.
                    \end{itemize}
                \item[Ausencia de inanición.]~\\
                    Supongamos que el proceso P1 sufre de inanición porque es continuamente adelantado por el proceso P2. En dicho caso, P1 se mantendrá esperando en su bucle de espera activa bajo la condición \verb|n2 <> 0 and n2 < n1|. Sin embargo, cuando P2 salga de su sección crítica, ejecutará \verb|n2 = 0|, con lo que esta situación (que P2 adelante continuamente a P1) es imposible. Un razonamiento análogo justifica la ausencia de inanición para P2.
            \end{description}
        \item Viendo que en las demostraciones de ausencia de inanición y alcanzabilidad no hemos usado dichas instrucciones, sospechamos que las instrucciones son necesarias para garantizar la exclusión mutua. Pensando un poco, llegamos a la traza de ejecución de la Tabla~\ref{tab:ej_6}, que nos permite meter a P1 y a P2 a la vez en la sección crítica (suponemos que estamos trabajando con el código de la Figura~\ref{fig:cod_6} donde hemos comentado las instrucciones de las líneas 4).
            \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|}
                \hline
                Línea de P1 & Línea de P2 & \verb|n1| & \verb|n2| \\
                \hline
                3 & 3 & 0 & 0 \\
                \hline
                3 & 5 & 0 & 1 \\
                \hline
                3 & 6 & 0 & 1 \\
                \hline
                3 & 9 & 0 & 1 \\
                \hline
                5 & 9 & 1 & 1 \\
                \hline
                6 & 9 & 1 & 1 \\
                \hline
                \red{9} & \red{9} & 1 & 1 \\
                \hline
            \end{tabular}
            \caption{Traza de ejecución que lleva a tener dos procesos en SC.}
            \label{tab:ej_6}
            \end{table}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}\label{ej:2.7}
    El siguiente programa (en la Figura~\ref{fig:cod_7}) es una solución al problema de la exclusión mutua para 2 procesos.  Discutir la corrección de esta solución: si es correcta, entonces probarlo. Si no fuese correcta, escribir escenarios que demuestren que la solución es incorrecta.
    \begin{figure}[H]
        \centering
        \begin{minted}{pascal}
            {variables compartidas y valores iniciales}
            var c0 : integer := 1;
                c1 : integer := 1;
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                Process P0;
                begin
                while true do begin
                   repeat 
                      c0 := 1 - c1;
                   until c1 <> 0;

                   {Sección crítica}
                   c0 := 1;
                   {Resto de sentencias}
                end
                end
            \end{minted}
            \begin{minted}{pascal}
                Process P1;
                begin
                while true do begin
                   repeat 
                      c1 := 1 - c0;
                   until c0 <> 0;

                   {Sección crítica}
                   c1 := 1;
                   {Resto de sentencias}
                end
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.7}.}
        \label{fig:cod_7}
    \end{figure}

    \ \\

    El algoritmo de la Figura~\ref{fig:cod_7} no es una solución correcta al problema de la exclusión mutua, debido a que la instrucción \verb|x := 1 - y| no es atómica, con lo que se podría suceder la traza de ejecución de P0 y P1 de la Tabla~\ref{tab:ej_7} (donde indicamos en cada caso la línea de la instrucción que se ejecuta, siendo \verb|l(5)| la lectura de \verb|c1| en P0 y \verb|e(5)| la escritura en \verb|c0| de P0, de forma análoga con P1), que nos lleva a tener tanto a P0 como a P1 en la sección crítica a la vez, con lo que no cumple con la propiedad de seguridad exigida. 

    \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        Línea de P0 & Línea de P1 & \verb|c0| & \verb|c1| \\
        \hline
        4 & 4 & 1 & 1 \\
        \hline
        \verb|l(5)| & 4 & 1 & \textbf{1} \\
        \hline
        \verb|l(5)| & \verb|l(5)| & \textbf{1} & 1 \\
        \hline
        \verb|e(5)| & \verb|l(5)| & 0 & 1 \\
        \hline
        \verb|e(5)| & \verb|e(5)| & 0 & 0 \\
        \hline
        6 & 6 & 0 & 0 \\
        \hline
        \red{8} & \red{8} & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Traza de ejecución que lleva a tener dos procesos en SC.}
    \label{tab:ej_7}
    \end{table}
\end{ejercicio}

\begin{ejercicio}
    Con respecto al algoritmo de Peterson para $N$ procesos: ¿sería posible que llegaran 2 procesos a la etapa $N-2$, 0 procesos a la etapa $N-3$ y en todas las etapas anteriores existiera al menos 1 proceso? Justificar la respuesta.\\

    No sería posible, ya que contradiría el Lema 3 que demostramos en para demostrar las propiedades del algoritmo de Peterson para $N$ procesos:

    \textit{Si tenemos al menos dos procesos en la etapa $j$, entonces ha de haber, al menos, un proceso en cada etapa anterior.}
\end{ejercicio}

\begin{ejercicio}
    En el \textit{algoritmo de Peterson} para $N$ procesos y considerando cualquier escenario de ejecución de dicho algoritmo, el número máximo de turnos que tiene que esperar cualquier proceso para entrar en sección crítica es $N-1$ turnos.\\

    Falso, en la teoría vimos que el número máximo de turnos que tiene que esperar cualquier proceso para entrar en sección crítica es de $\frac{N(N-1)}{2}$ turnos.
\end{ejercicio}

\begin{ejercicio}\label{ej:2.10}
Con respecto al algoritmo de la Figura~\ref{fig:cod_10} (algoritmo de Dijkstra para $N$ procesos), demostrar la falsedad de la siguiente proposición:\newline

\begin{centering}
\textit{si un conjunto de procesos está intentando pasar simultáneamente el primer bucle} (el de la línea 11), \textit{y el proceso que tiene el turno está pasivo, entonces siempre conseguirá entrar primero en sección crítica el proceso de dicho grupo que consiga asignar la variable turno en último lugar.}
\end{centering}

    \begin{figure}
        \centering
        \begin{minted}{pascal}
            var turno : 0..N-1;
                flag : array[0..N-1] of (pasivo, solicitando, enSC);
            flag := pasivo:

            Process P(i);
            begin
               {Resto de instrucciones}
               repeat
                  flag[i] := solicitando;

                  while turno <> i do begin
                     if flag[turno] = pasivo then 
                        turno := i;
                  end

                  flag[i] := enSC;
                  j := 0;

                  while j < N and ((j=i) or flag[j] <> enSC) do begin
                     j := j + 1;
                  end
               until (j >= N);

               {Sección crítica}
               flag[i] := pasivo;
            end
        \end{minted}
        \caption{Código para el Ejercicio~\ref{ej:2.10}.}
        \label{fig:cod_10}
    \end{figure}
    \ \\

    Para demostrar la falsedad de la afirmación basta con dar una traza de ejecución en la que esta no se cumpla. Para ello, supongamos que tenemos dos procesos, P0 y P1 ejecutando el protocolo de entrada de la sección crítica, de forma que se da la siguiente trzada de ejecución:
    \begin{itemize}
        \item Ambos ejecutan la instrucción de la línea 9, cambiando su flag a \verb|solicitando|.
        \item Ambos consultan que su identificador (\verb|i|) es distinto del turno, con lo que ejecutan el bucle, viendo ambos que \verb|flag[turno] = pasivo|.
        \item Ambos modifican el valor de la variable compartida \verb|turno|, de forma que es el proceso P1 quien modifica dicha variable en último lugar.
        \item Mientras P1 terminaba de modificar la variable \verb|turno|, a P0 le da tiempo a cambiar su flag a \verb|enSC| y de ejecutar el bucle de la línea 19, con lo que le da tiempo a comprobar que ningún otro proceso tiene su flag a \verb|enSC|, saliendo del bucle con un valor de \verb|j = N|, lo que le permite entrar en la sección crítica.
        \item P0 y P1 intentaron pasar simultáneamente el primer bucle, con el proceso del turno en estado pasivo, P1 fue el último en asignar la variable \verb|turno| y al final P0 fue el primer proceso que consiguió entrar en la sección crítica.
    \end{itemize}
\end{ejercicio}

\begin{ejercicio}\label{ej:2.11}
    El algoritmo de la Figura~\ref{fig:cod_11} (algoritmo de Knuth para $N$ procesos) resuelve el problema de la exclusión mutua para $N$ procesos, pra lo cual utiliza $N$ variables booleanas \verb|flag|, una variable \verb|turn| y la variable local \verb|j|.
    \begin{enumerate}[label=(\alph*)]
        \item Demostrar que el algoritmo de Knuth verifica todas las propiedades exigibles a un programa concurrente, incluyendo la de equidad.
        \item Escribir un escenario en el que 2 procesos consiguen pasar el bucle de la instrucción de la línea 13, suponiendo que el turno lo tiene inicialmente el proceso \verb|p(0)|.
    \end{enumerate}

    \begin{figure}
        \centering
        \begin{minted}{pascal}
            var flag : array[0..N-1] of (pasivo, solicitando, enSC);
                turn := 0..N-1;
            flag := pasivo;
            turn := 0;

            Process P(i);
            var j : integer;
            begin
               {Resto de instrucciones}
               repeat
                  flag[i] := solicitando;
                  j := turn;
                  while j <> i do begin
                     if flag[j] <> pasivo then
                        j := turn;
                     else
                        j := (j - 1) mod N;
                     endif;
                  end

                  flag[i] := enSC;
                  j := 0;

                  while (j < N) and ((j=i) or flag[j] <> enSC) do begin
                     j := j + 1;
                  end
               until (j >= N);

               turn := i;
               {Seccion crítica}
               j := (turn + 1) mod N;
               turn := j;
               flag[i] := pasivo;
            end
        \end{minted}
        \caption{Código para el Ejercicio~\ref{ej:2.11}}
        \label{fig:cod_11}
    \end{figure}
    \begin{enumerate}[label=(\alph*)]
        \item Todas estas propiedades fueron ya demostradas en los apuntes de teoría.
        \item Para ello, describiremos a continuación un escenario en el que los procesos P1 y P2 consiguen pasar el bucle de la línea 13 (es decir, llegar a la línea 21), suponiendo que \verb|turno = 0|. El escenario es el contemplado en la Tabla~\ref{tab:ej_10}, donde suponemos que en todo momento el proceso P0 está pasivo, es decir, \verb|flag[0] = pasivo|.

            \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|}
                \hline
                Línea de P1 & Línea de P2 & \verb|j|$_1$ & \verb|j|$_2$ \\
                \hline
                12 & 12 & 0 & 0 \\
                \hline
                13 & 13 & 0 & 0 \\
                \hline
                14 & 14 & 0 & 0 \\
                \hline
                17 & 14 & 2 & 0 \\
                \hline
                13 & 14 & 2 & 0 \\
                \hline
                14 & 14 & 2 & 0 \\
                \hline
                17 & 14 & 1 & 0 \\
                \hline
                13 & 17 & 1 & 2 \\
                \hline
                21 & 13 & 1 & 2 \\
                \hline
                21 & 21 & 1 & 2 \\
                \hline
            \end{tabular}
            \caption{Traza de ejecución en la que 2 procesos pasan el bucle de la línea 13.}
            \label{tab:ej_10}
            \end{table}
    \end{enumerate}
\end{ejercicio}

\newpage
\begin{ejercicio}
    Si en el algoritmo de Dijkstra de la Figura~\ref{fig:cod_10} se cambia la instrucción de la línea 12 por esta otra: \verb|if (flag[turno] <> enSC)|, entonces el algoritmo dejaría de ser correcto. Indicar qué propiedad(es) de corrección faltaría(n) y justificar por qué.\\

    El algoritmo de Dijkstra tiene las propiedades de garantizar la exclusión mutua y de alcanzabilidad. Si observamos la demostración de la propiedad de exclusión mutua que hicimos en teoría, esta no dependía del bucle de la línea 11, con lo que su modificación no dará lugar a que más de un proceso ejecute la sección crítica al mismo tiempo.\\

    Por tanto, podemos pensar que la única propiedad de corrección que faltaría sería la de alcanzabilidad de la sección crítica. Para ver que esta no se da, supongamos un escenario en el que tenemos dos procesos, P0 y P1 ejecutando el protocolo de entrada a la sección crítica del código modificado, de forma que se da la traza de ejecución de la Tabla~\ref{tab:ej_12}. Si la traza del programa continúa siendo las que aparecen entre las dos instruccioens destacadas, estas se repetirían de forma infinita, dándose un interbloqueo entre los dos procesos, ya que después de que uno cambie el turno, el otro proceso comprueba que no tiene el turno y lo cambia antes de que el que lo cambió vea que el turno es igual a su identificador. 

    Al darse una situación de interbloqueo, el algoritmo no cuenta con la propiedad de alcanzabilidad.
    \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Línea de P0 & Línea de P1 & turno \\
        \hline
        9 & 9 & 2 \\
        \hline
        11 & 11 & 2 \\
        \hline
        12 & 11 & 2 \\
        \hline
        \textbf{13} & \textbf{11} & \textbf{0} \\
        \hline
        13 & 12 & 0 \\
        \hline
        13 & 13 & 1 \\
        \hline
        11 & 13 & 1 \\
        \hline
        12 & 13 & 1 \\
        \hline
        13 & 13 & 0 \\
        \hline
        \textbf{13} & \textbf{11} & \textbf{0} \\
        \hline
    \end{tabular}
    \caption{Traza de ejecución que da lugar a un interbloqueo.}
    \label{tab:ej_12}
    \end{table}
\end{ejercicio}

\begin{ejercicio}
    Si en el algoritmo de Knuth de la Figura~\ref{fig:cod_11} se hacen las siguientes sustituciones:
    \begin{itemize}
        \item La condición de la instrucción \verb|until| de la línea 27 por la condición \newline \verb|(j >= N) and (turno = i or flag[turno] = pasivo)|.
        \item Se inserta el siguiente bucle después de la instrucción de la línea 31:
            \begin{minted}{pascal}
                while (j <> turn) and (flag[j] = pasivo) do begin
                   j := j + 1;
                end
            \end{minted}
    \end{itemize}
    \begin{enumerate}[label=(\alph*)]
        \item Verificar las propiedades de exclusión mutua, alcanzabilidad de la sección crítica, vivacidad y equidad del algoritmo.
        \item Calcular el número de turnos máximo que puede llegar a tener que esperar un proceso que quiera entrar en su sección crítica con el algoritmo anterior.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}\label{ej:2.14} % // TODO:
    Demostrar que las instrucciones entre las líneas 18 y 28 del algoritmo de exclusión mutua distribuido de Ricart-Agrawala (de la Figura~\ref{fig:cod_14}) no necesitan ser protegidas dentro de la sección crítica definida por las operaciones \verb|wait()|, \verb|signal()| del semáforo \verb|s|.
    \begin{figure}[H]
        \centering
        \begin{minted}{pascal}
            var token_presente : boolean := false;
                enSC : boolean := false;
                peticion : array[1..n] of boolean := false;
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                Process P(i);
                begin
                   wait(s);
                   if not token_presente then begin
                      broadcast(pet, i);
                      receive(acceso);
                      token_presente := true;
                   end

                   enSC := true;
                   signal(s);

                   {Sección crítica}

                   enSC := false;
                   wait(s);

                   for j := i+1 to n, 1 to i-1 do
                      if peticion[j] and 
                         token_presente then begin

                         token_presente := false;
                         send(j,acceso);
                         peticion[j] := false;
                      end
                   end

                   signal(s);
                end
            \end{minted}
            \begin{minted}{pascal}
                Process Pet(i);
                begin
                   receive(pet, j);
                   wait(s);
                   peticion[j] := true;
                   if token_presente and not enSC then
                      {Repetir líneas 18-28}
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.14}}
        \label{fig:cod_14}
    \end{figure}
\end{ejercicio}

\begin{ejercicio}\label{ej:2.15} % // TODO:
    Suponer que el algoritmo de Suzuki-Kasami para resolver el problema de la exclusión mutua distribuida para $n$-procesos se modifica como aparece en la siguiente figura. Explicar por qué dejaría de ser correcto el algoritmo, relacionándolo con cada una de las propiedades de corrección que se demuestran para el algoritmo original.
    \begin{figure}
        \centering
        \begin{minted}{pascal}
            var token_presente : boolean := false;
                enSC : boolean := false;
                peticion : array[1..n] of boolean := false;
            {En el algoritmo original -> peticion : array[1..n] of 0..+INF}
            {además se declara otro array -> token : array[1..n] of 0..+INF}
        \end{minted}
        \setlength{\columnsep}{1cm}
        \begin{multicols}{2}
            \begin{minted}{pascal}
                Process P(i);
                begin
                   wait(s);
                   if not token_presente then begin
                      broadcast(pet, i);
                      receive(acceso);
                      token_presente := true;
                   end

                   enSC := true;
                   signal(s);

                   { SC }

                   enSC := false;
                   wait(s);

                   for j := i+1 to n, 1 to i-1 do
                      if peticion[j] and
                         token_presente then begin
                         token_presente := false;
                         send(j, acceso);
                         peticion[j] := false;
                      end
                   end
                   signal(s);
                end
            \end{minted}
            \begin{minted}{pascal}
                Process Pet(i);
                begin
                   receive(pet, j);
                   wait(s);
                   peticion[j] := true;
                   if token_presente and
                      not enSC then begin
                      for j := i+1 to n, 1 to i-1 do
                         if peticion[j] and
                            token_presente then begin
                            token_presente := false;
                            send(j, acceso);
                            peticion[j] := false;
                         end
                      end
                      signal(s);
                   end
                end
            \end{minted}
        \end{multicols}
        \caption{Código para el Ejercicio~\ref{ej:2.15}}
        \label{fig:cod_15}
    \end{figure}
\end{ejercicio}
