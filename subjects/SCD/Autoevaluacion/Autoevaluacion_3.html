<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>SCD. Autoevaluación del Tema 2. Exclusión Mutua.</h1>
<hr>
<ul>
<li><strong>Asignatura:</strong> Sistemas Concurrentes y Distribuidos.</li>
<li><strong>Curso Académico:</strong> 2024-25.</li>
<li><strong>Grado:</strong> Doble Grado en Ingeniería Informática y Matemáticas.</li>
<li><strong>Grupo:</strong> Único.</li>
<li><strong>Profesor:</strong> Manuel Isidoro Capel Tuñón.</li>
<li><strong>Descripción:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Sistemas Concurrentes y Distribuidos. En él, se puede encontrar una corta autoevaluación formada por unas 25 preguntas tipo test sobre la parte de exclusión mutua.</li>
</ul>
<hr>
<ol>
<li>
<p>¿Qué garantiza el algoritmo de Dijkstra para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Acceso simultáneo a la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminación de la necesidad de turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Exclusión mutua con tiempo de espera limitado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de variables globales compartidas</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusión mutua sin control de inanición</label></li>
</ul>
</li>
<li>
<p>¿Qué propiedad NO es garantizada por el algoritmo de Dijkstra?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Uso equitativo de los recursos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Alcanzabilidad de la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Exclusión mutua</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ausencia de inanición</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Seguridad en el acceso a recursos compartidos</label></li>
</ul>
</li>
<li>
<p>¿Qué representa el turno en un algoritmo de exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La señal para finalizar el programa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La prioridad fija de un proceso</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El permiso para acceder a la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La posición en la cola de espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La cantidad de procesos activos en el sistema</label></li>
</ul>
</li>
<li>
<p>¿Qué asegura el algoritmo de Peterson al pasar entre etapas?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La etapa más alta siempre está vacía</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos se bloquean indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El acceso a la sección crítica se distribuye aleatoriamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos siempre progresan de forma equitativa</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso no avanza sólo si no está más adelantado que los demás y es el último en asignar el turno</label></li>
</ul>
</li>
<li>
<p>¿Qué asegura el uso de etapas en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Interrupción de procesos de bajo nivel</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminación de etapas redundantes</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Mayor velocidad de procesamiento</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminación del uso de tokens</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusión mutua y equidad</label></li>
</ul>
</li>
<li>
<p>¿Cuál es una de las condiciones de Dijkstra para la exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso fuera de la sección crítica no debe bloquear a otros procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignar recursos de manera aleatoria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usar variables globales como única solución</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse secuencialmente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos pueden detenerse indefinidamente</label></li>
</ul>
</li>
<li>
<p>¿Cómo maneja el algoritmo de Dijkstra las prioridades entre procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Asignando turnos de manera fija</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que los procesos esperen indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando una cola FIFO</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignando valores aleatorios a los procesos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Implementando un contador global de turnos</label></li>
</ul>
</li>
<li>
<p>¿Qué propiedad asegura el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solo funciona con dos procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Necesita una red de comunicaciones</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza exclusión mutua y evita inanición</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Depende de semáforos externos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite acceso prioritario a un proceso</label></li>
</ul>
</li>
<li>
<p>¿Qué significa "progreso finito" en el contexto de Dijkstra? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La ejecución de un proceso no se interrumpe</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos se ejecutan en paralelo</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos avanzan indefinidamente sin detenerse</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los procesos tienen un tiempo finito para entrar a la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El acceso a la memoria es constante</label></li>
</ul>
</li>
<li>
<p>¿Qué mejora introduce el algoritmo de Peterson para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Sustituye la necesidad de semáforos por variables clave locales</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere menos pasos que el algoritmo de Dekker</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite acceso simultáneo a la sección crítica</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza exclusión mutua para cualquier cantidad de procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Elimina la inanición en sistemas distribuidos</label></li>
</ul>
</li>
<li>
<p>¿Cómo soluciona el algoritmo de Knuth la inanición en exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminando los procesos en espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que todos los procesos avancen simultáneamente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizando que el tiempo de espera sea limitado para cada proceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloqueando procesos con menor prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando turnos circulares para la asignación de recursos</label></li>
</ul>
</li>
<li>
<p>¿Qué hace un proceso después de usar la sección crítica en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solicita nuevamente el turno</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Envía mensajes a otros procesos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Libera su bandera de "solicitado"</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquea a los otros procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Incrementa un contador global</label></li>
</ul>
</li>
<li>
<p>¿Qué ocurre si dos procesos intentan acceder simultáneamente en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se produce un interbloqueo</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se respetan las reglas de exclusión mutua</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ambos procesos fallan</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ambos entran a la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uno de ellos puede quedar bloqueado indefinidamente</label></li>
</ul>
</li>
<li>
<p>¿Qué técnica introduce el algoritmo de Knuth?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de prioridad fija entre procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de semáforos para exclusión mutua</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solución parcial para sistemas distribuidos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retraso limitado en el acceso a la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanición de procesos</label></li>
</ul>
</li>
<li>
<p>¿Cómo resuelve el método de refinamiento sucesivo el problema de exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminando el uso de turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que dos procesos entren simultáneamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando semáforos binarios</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Implementando bucles de espera activa para decidir el acceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dividiendo el problema en múltiples secciones críticas</label></li>
</ul>
</li>
<li>
<p>¿Qué es una "etapa" en el algoritmo de Peterson para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un mecanismo de exclusión global</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un nivel de prioridad fijo para los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un bucle infinito en la ejecución</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una fase de sincronización antes de la sección crítica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una señal de error en el sistema</label></li>
</ul>
</li>
<li>
<p>¿Qué condición debe cumplirse para que un proceso entre a la sección crítica en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Su turno no debe coincidir o la clave del otro proceso debe ser falsa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su contador debe superar al de los demás procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su clave de solicitud debe ser verdadera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su prioridad debe ser la más alta</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su solicitud debe ser la primera en la cola</label></li>
</ul>
</li>
<li>
<p>¿Qué problema puede surgir al verificar las claves en algoritmos de refinamiento sucesivo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los turnos se asignan de manera inconsistente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> No se realiza la salida de la espera activa de forma atómica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se producen interrupciones aleatorias</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloqueo mutuo al intercambiar turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos entran en la sección crítica sin permiso</label></li>
</ul>
</li>
<li>
<p>¿Qué problema intenta resolver la exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquear indefinidamente todos los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Evitar el uso de recursos por parte de un proceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitir que todos los procesos accedan a la sección crítica simultáneamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Acelerar el acceso de los procesos a la memoria compartida</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Evitar el acceso simultáneo de múltiples procesos a una sección crítica</label></li>
</ul>
</li>
<li>
<p>¿Qué ocurre si todos los procesos solicitan acceso simultáneamente en el algoritmo de Dijkstra?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos se ordenan en cola de prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se produce un interbloqueo</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Uno de ellos accede según el turno asignado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El sistema queda bloqueado indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos acceden simultáneamente</label></li>
</ul>
</li>
<li>
<p>¿Qué condición garantiza el algoritmo de Knuth?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Reducción del tiempo de espera a 0</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminación de procesos en espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanición de procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Interbloqueo constante</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusión mutua</label></li>
</ul>
</li>
<li>
<p>¿Qué garantiza el algoritmo de Dekker?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Equidad completa entre procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanición de todos los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una solución distribuida</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ejecución simultánea en la sección crítica</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusión mutua, pero puede causar inanición</label></li>
</ul>
</li>
<li>
<p>¿Qué garantiza la propiedad de equidad en exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos son bloqueados simultáneamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos avanzan al mismo tiempo</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solo un proceso ejecuta indefinidamente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los procesos acceden en orden sin preferencia indebida</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No hay necesidad de sincronización</label></li>
</ul>
</li>
<li>
<p>¿Qué asegura la verificación de exclusión mutua en un algoritmo para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquear indefinidamente los procesos que esperan</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizar que solo un proceso entre en la sección crítica a la vez</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignar recursos de manera aleatoria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitir acceso simultáneo a múltiples procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Prohibir la entrada de todos los procesos</label></li>
</ul>
</li>
<li>
<p>¿Cuál es el principal problema de los bucles de espera activa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Reducen el tiempo de espera de los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Facilitan la exclusión mutua</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Pueden generar uso innecesario de recursos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminan la necesidad de sincronización</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Incrementan la equidad del sistema</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-warning');
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-warning');
            } else {
                self.removeClass('text-warning'); // Eliminar la marca de respuesta parcialmente correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>