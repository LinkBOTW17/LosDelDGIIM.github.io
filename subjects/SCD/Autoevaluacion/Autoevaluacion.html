<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>SCD. Preguntas para la autoevaluación del Tema 1.</h1>
<hr>
<ul>
<li><strong>Asignatura:</strong> Sistemas Concurrentes y Distribuidos.</li>
<li><strong>Curso Académico:</strong> 2024-25.</li>
<li><strong>Grado:</strong> Doble Grado en Ingeniería Informática y Matemáticas.</li>
<li><strong>Grupo:</strong> Único.</li>
<li><strong>Profesor:</strong> Manuel Isidoro Capel Tuñón.</li>
<li><strong>Descripción:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Sistemas Concurrentes y Distribuidos. En él, se puede encontrar una corta autoevaluación formada por unas 20 preguntas tipo test.</li>
</ul>
<hr>
<ol>
<li>
<p>¿Qué significa "irrepetibilidad de las secuencias de instrucciones" en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La velocidad de ejecución determina la secuencia de instrucciones.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los programas concurrentes generan muchas intercalaciones de instrucciones posibles, por lo que es poco probable que se repitan caminos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los programas concurrentes nunca tienen errores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos ejecuciones seguirán probablemente el mismo camino.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos siguen siempre la misma secuencia de ejecución.</label></li>
</ul>
</li>
<li>
<p>¿Qué reto presentan las trazas de ejecución de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Las trazas no pueden utilizarse con fines de depuración.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las trazas garantizan que se producirán errores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Generan numerosas secuencias de intercalación posibles, lo que complica la predicción.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre conducen a un punto muerto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siguen un patrón predecible y repetible.</label></li>
</ul>
</li>
<li>
<p>¿Qué son los "errores transitorios" en el contexto de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que nunca se producen en los programas concurrentes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Errores que aparecen en algunas ejecuciones pero no en otras, lo que dificulta su detección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que son fáciles de detectar y solucionar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que aparecen siempre en la misma ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que se producen aleatoriamente y no tienen solución.</label></li>
</ul>
</li>
<li>
<p>¿Por qué es difícil depurar programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Debido a la imprevisibilidad de las secuencias de ejecución y a la posibilidad de que haya trazas diferentes en cada ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Debido a la previsibilidad de las secuencias de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque los errores transitorios aparecen en cada traza.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque los programas concurrentes siempre se ejecutan sin errores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La depuración de programas concurrentes no difiere de la de los secuenciales.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes es una solución para garantizar la corrección de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Ignorar los errores transitorios porque ocurren raramente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Utilizar la fuerza bruta para reejecutar el programa varias veces.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se puede garantizar la corrección sin ningún método formal.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Confiar sólo en la comprobación manual de errores.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Utilizar métodos formales basados en la lógica matemática para verificar la corrección.</label></li>
</ul>
</li>
<li>
<p>¿Qué es una traza en el contexto de la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El historial de cómo se modifican las variables durante la compilación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Una secuencia de operaciones atómicas de un único proceso.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una secuencia de estados del programa producidos por un intercalado específico de instrucciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro de todos los errores en la ejecución de un programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La ejecución de un único proceso de forma aislada.</label></li>
</ul>
</li>
<li>
<p>¿Por qué es peligroso hacer suposiciones sobre la velocidad de ejecución de los procesos en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Las suposiciones de velocidad siempre aumentan la eficacia del programa.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los procesos pueden no funcionar correctamente en diferentes plataformas si se hacen suposiciones sobre la velocidad de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos más rápidos siempre garantizan mejores resultados del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre conduce a un mejor rendimiento en todas las plataformas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La velocidad de ejecución es irrelevante para la programación concurrente.</label></li>
</ul>
</li>
<li>
<p>¿Qué es una "condición de carrera" en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando dos procesos se ejecutan siempre en un orden fijo y predecible.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cuando dos procesos acceden a variables compartidas en un orden impredecible en función de la velocidad de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una situación en la que el orden de ejecución de los procesos no afecta a la salida final del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una situación en la que dos procesos nunca interactúan con recursos compartidos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un escenario en el que la velocidad de ejecución es siempre constante.</label></li>
</ul>
</li>
<li>
<p>¿Qué efecto pueden tener las condiciones de carrera en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Facilitan la depuración debido a su comportamiento coherente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Producen resultados predecibles y correctos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reducen el riesgo de errores en el programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantizan que todos los procesos se ejecuten de forma predecible.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Producen resultados impredecibles o incorrectos según el orden de ejecución de los procesos.</label></li>
</ul>
</li>
<li>
<p>¿En qué tipo de sistema es crítica la velocidad y el orden de ejecución de los procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Sistemas operativos de propósito general.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En los sistemas en tiempo real, donde la velocidad y el orden de ejecución son críticos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo sistemas distribuidos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo en sistemas "multicore"</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En cualquier sistema con procesos concurrentes.</label></li>
</ul>
</li>
<li>
<p>¿Qué implica la "independencia de la velocidad del proceso" en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La velocidad de ejecución siempre determina la corrección del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos más lentos garantizan una mayor estabilidad del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La corrección del proceso debe depender de la velocidad relativa de los procesos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse siempre lo más rápido posible.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La corrección del proceso debe ser independiente de la velocidad de ejecución, evitando las condiciones de carrera.</label></li>
</ul>
</li>
<li>
<p>¿Qué importancia tiene la «hipótesis de progreso finito» en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que los procesos se completen siempre a la misma velocidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite que algunos procesos no terminen nunca sus tareas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo es aplicable a los programas secuenciales.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza que todos los procesos completen la ejecución y progresen, evitando el bloqueo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite que los procesos se detengan indefinidamente sin afectar a la corrección del programa.</label></li>
</ul>
</li>
<li>
<p>¿Qué es el "progreso global" en el contexto de la ejecución concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza que al menos un proceso listo para ejecutarse llegue a ejecutarse, evitando el bloqueo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que ningún proceso pueda bloquear la ejecución de otro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere que todos los procesos se ejecuten al mismo tiempo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que todos los procesos terminen la ejecución inmediatamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es específico sólo de los sistemas en tiempo real.</label></li>
</ul>
</li>
<li>
<p>¿Qué significa "progreso local" en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una vez que un proceso comienza a ejecutarse, debe terminar todo el programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una vez que un proceso empieza a ejecutar una sección de código, debe completarla sin interrupción.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un proceso debe completar siempre todo el programa sin pausa.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso puede detenerse a mitad de ejecución y reanudarse más tarde sin completar la sección actual.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben comunicarse con otros procesos para continuar la ejecución.</label></li>
</ul>
</li>
<li>
<p>¿Cómo evita la hipótesis del progreso finito el bloqueo en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Limitando el número de procesos que pueden ejecutarse simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantizando que los procesos puedan detenerse en cualquier momento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Poniendo en pausa algunos procesos para permitir que otros terminen primero.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizando que todos los procesos acaben progresando, evitando que se atasquen.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Imponiendo límites temporales estrictos a la ejecución de los procesos.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la definición de "propiedad de vivacidad"?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una propiedad que define cuántos procesos pueden ejecutarse simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una propiedad que garantiza que los procesos pueden pausarse indefinidamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una condición que sólo se aplica a los programas secuenciales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una condición que debe cumplirse en cada instante de la ejecución del programa.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una condición que establece que algo bueno debe suceder eventualmente en el futuro.</label></li>
</ul>
</li>
<li>
<p>¿Qué significa el triple <code>{P}C{Q}</code> en el contexto de la lógica de Hoare?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que en la ejecución de varios procesos contenidos <code>C</code> no existen interferencias.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>P</code> y <code>Q</code> son variables que representan el tiempo de ejecución de <code>C</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Si el programa <code>C</code> comienza en un estado en el que <code>P</code> es verdadero, entonces <code>Q</code> será verdadero después de que <code>C</code> termine de ejecutarse.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el programa <code>C</code> se ejecuta, siempre terminará.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el programa <code>C</code> se ejecuta con la máxima velocidad, <code>P</code> siempre será igual a <code>Q</code>.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es el principal reto de aplicar la lógica de Hoare a los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La interferencia entre procesos de ejecución concurrente complica el razonamiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No puede manejar programas sin memoria compartida.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es difícil definir precondiciones y postcondiciones para cada proceso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La lógica de Hoare requiere un número infinito de trazas de ejecución para verificar la corrección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La lógica de Hoare sólo es aplicable a los programas secuenciales, no a los concurrentes.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la principal característica de la regla de no interferencia de la lógica de Hoare para programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo se aplica a los programas secuenciales, no a los concurrentes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza que dos procesos no interfieran entre sí en sus precondiciones y postcondiciones cuando se ejecutan simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que cada proceso termina de ejecutarse antes de que comience el siguiente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite que los procesos se ejecuten sin sincronización y sigue garantizando la corrección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que todos los procesos accedan a los recursos compartidos al mismo tiempo.</label></li>
</ul>
</li>
<li>
<p>En la lógica de Hoare, ¿qué se necesita para verificar la corrección de una composición concurrente de procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse secuencialmente, sin solapar instrucciones.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las precondiciones y postcondiciones de los procesos deben combinarse, y ningún proceso debe invalidar las afirmaciones de los demás.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El sistema debe probarse con todas las configuraciones de hardware posibles para garantizar su corrección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada proceso debe tener su propio espacio de memoria independiente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La composición sólo debe implicar a un único proceso a la vez.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.addClass('text-warning');
            } else {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>