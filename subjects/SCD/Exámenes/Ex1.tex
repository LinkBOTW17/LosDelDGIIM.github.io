\documentclass[12pt]{article}

\input{../../_assets/preambulo.tex}


\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    
    \input{../../_assets/portada}
    \portadaExamen{etsiitA4.jpg}{Sistemas\\ Concurrentes y\\ Distribuidos\\Examen I}{SCD. Examen I}{MidnightBlue}{-8}{28}{2021}{José Juan Urrutia Milán}

    \begin{description}
        \item[Asignatura] Sistemas Concurrentes y Distribuidos.
        \item[Curso Académico] 2021-22.
        \item[Grupo] Único.
        \item[Descripción] Examen parcial de los Temas 1 y 2 de SCD.
        \item[Fecha] 13-01-2021.
    \end{description}
    \newpage


    % ------------------------------------
    
    \subsubsection*{Preguntas de respuesta alternativa: 35\%}
    \begin{ejercicio}
        Seleccione la única respuesta correcta de cada una de las cuestiones siguientes; cada una bien contestada tiene una puntuación de \textbf{0.5}.
        \begin{enumerate}
            \item Un programa concurrente que cumpla la propiedad de \textit{seguridad} para todas sus ejecuciones se considerará correcto si además cumple que:
                \begin{enumerate}[label=(\alph*)]
                    \item Los procesos del programa nunca pueden llegar a una situación de \textit{interbloqueo}.
                    \item Se puede demostrar que sus procesos no sufren \textit{inanición} en ninguna posible ejecución del programa.
                    \item Sus procesos siempre consiguen ejecutar sus instrucciones de forma equitativa o justa.
                    \item Habrá que demostrar la no \textit{inanición} de los procesos y, además, la \textit{vivacidad} (o "liveness").
                \end{enumerate}
            \item La \textit{hipótesis de progreso finito} asegura que durante la ejecución de cualquier programa concurrente se cumplirá:
                \begin{enumerate}[label=(\alph*)]
                    \item La velocidad de ejecución individual de los procesos está limitada por las características del procesador que ejecute el código generado por el compilador.
                    \item Siempre ha de existir algún proceso activo (ejecutándose) durante la ejecución del programa.
                    \item La propiedad de \textit{ausencia de inanición} de los procesos en todo momento.
                    \item Cualquier proceso del programa, que comienza la ejecución de una instrucción, ha de completar alguna vez la ejecución de esta.
                \end{enumerate}
            \item Aplicando la propiedad \textit{como máximo una vez} a la evaluación de sentencias como $x=expresion$, que son evaluadas por los siguientes procesos concurrentes ¿cuál de las siguientes evaluaciones se puede considerar que se realiza \textit{atómicamente} (\verb|<x = expresion>|)? (suponer que los valores iniciales de las variables == 0 y que \verb|a| y \verb|b| son constantes):
                \begin{enumerate}[label=(\alph*)]
                    \item $P_1$: \verb|cobegin x = y + a| \verb+||+ \verb|y = x + b coend|.
                    \item $P_2$: \verb|cobegin x = y + a| \verb+||+ \verb|y = f(x) + b coend|.
                    \item $P_3$: \verb|cobegin x = y + a| \verb+||+ \verb|y = a + b coend|.
                    \item $P_4$: \verb|cobegin x = x / y| \verb+||+ \verb|y = a + x coend|.
                \end{enumerate}
            \item Respecto de la orden de espera selectiva (\verb|select|) utilizadas por sistemas con paso de mensajes bloqueante, se poducirá inmediatamente la elección y ejecución si:
                \begin{enumerate}[label=(\alph*)]
                    \item En ese momento solo exista 1 proceso del programa que haya iniciado el envío de mensaje.
                    \item Sea la única orden \textit{potencialmente ejecutable} de dicha instrucción \verb|select|.
                    \item Sea \textit{potencialmente ejecutable} y se nombre en la guarda un proceso que ya inició su envío.
                    \item Nombre a uno de los procesos del programa que ya iniciaron su envío de mensaje.
                \end{enumerate}
            \item En relación al problema de la sección crítica para N procesos y su relación con las propiedades de corrección de los programas concurrentes se puede afirmar que:
                \begin{enumerate}[label=(\alph*)]
                    \item Si un algoritmo cumple las 4 \textit{condiciones de Dijkstra}, entonces se puede decir que es una solución \textit{totalmente correcta} a tal problema.
                    \item En el algoritmo de Dijkstra se puede afirmar que ningún grupo de procesos puede ser adelantado indefinidamente por otros procesos que consiguen acceder a la sección crítica repetidamente, impidiéndoles a entrar a esta.
                    \item Con el algoritmo de Knuth el mayor retraso que podría sufrir un proceso \textit{solicitante}, sujeto al peor escenario posible de planificación para él, sería esperar como máximo un número de turnos igual al número de procesos anteriores a dicho proceso en el denominado turno cíclico de acceso a la sección crítica.
                    \item Con el algoritmo de Peterson nunca podría ocurrir que existieran etapas vacías (sin ningún proceso esperando) y anteriores a una etapa a la que se acaba de unir un segundo proceso.
                \end{enumerate}
            \item Respecto de la demostración de las propiedades de los monitores:
                \begin{enumerate}[label=(\alph*)]
                    \item El invariante de los monitores –para señales de semántica desplazante (SS,SE,SU)– necesariamente ha de cumplirse después de ejecutar la operación de sincronización \verb|c.wait()| en la programación de los procedimientos de un monitor.
                    \item Con semántica de \textit{señales urgentes} (SU) la ejecución de una operación \verb|c.wait()| nunca puede provocar la entrada al monitor de un proceso suspendido en una cola distinta a la cola de entrada al monitor.
                    \item Para programar correctamente los monitores que usan variables condición del tipo \textit{señalar y salir} (SS) hay que programar siempre la operación de sincronización \verb|c.signal()| como la última instrucción de los procedimientos.
                    \item Si las señales que usa un monitor tienen semántica \textit{señalar y continuar} (SC), el proceso señalador –tras provocar la ejecución de \verb|c.signal()|– sigue su ejecución dentro del monitor pero el proceso notificado solo sale de cola en la que estuviera suspendido.
                \end{enumerate}
            \item Respecto de las operaciones de paso de mensajes no-bloqueantes:
                \begin{enumerate}[label=(\alph*)]
                    \item Siempre (incluso son soporte hardware) es necesario programar operaciones de comprobación que indiquen si es seguro acceder a los datos en transmisión antes de que la ejecución de la operación \verb|receive()| devuelva el control al proceso receptor.
                    \item Si el proceso receptor está preparado para recibir los datos en transmisión, la ejecución de la operación \verb|receive()| \textit{vuelve} inmediatamente siempre.
                    \item El proceso emisor siempre supone que la ejecución de la operación \verb|send()| accederá a datos en un estado inseguro.
                    \item Existe un caso en el cual la ejecución de la operación \verb|receive()| no detiene al proceso receptor aunque no se hayan terminado de transmitir los datos que han de recibirse.
                \end{enumerate}
        \end{enumerate}
    \end{ejercicio}

    \subsubsection*{Cuestiones y ejercicios: 40\%}
    \begin{ejercicio}\label{ej:2}
        Sobre la diferencia conceptual existente entre las denominadas \textit{propiedades de seguridad} y \textit{vivacidad} respecto de su validez temporal durante la ejecución de un programa concurrente:
        \begin{itemize}
            \item Clasificar las propiedades de la tabla según el tipo de propiedad al que pertenecen (aparte, justificarlo brevemente).
            \item ¿En qué instante(s) de la ejecución de los programas se ha de cumplir cada uno de los siguientes tipos de propiedades? Elegir una de las posibilidades de validez temporal para cada una de las propiedades de la Tabla~\ref{tab:ej_2}.
                \begin{enumerate}[label=(\alph*)]
                    \item Siempre.
                    \item Alguna vez.
                    \item Intermitentemente.
                    \item Alguna vez en el futuro y, desde entonces, para siempre.
                \end{enumerate}
        \end{itemize}
        \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{nombre propiedad} & \textbf{tipo propiedad} (\textit{seguridad}$|$\textit{vivacidad}) & (\textbf{a}$|$\textbf{b}$|$\textbf{c}$|$\textbf{d}) \\
            \hline
            Exclusión mutua & & \\
            \hline
            Ausencia de interbloqueo & & \\
            \hline
            Alcanzabilidad de la SC & & \\
            \hline
            Productor-consumidor & & \\
            \hline
            No inanición procesos & & \\
            \hline
            Equidad procesoss & & \\
            \hline
            Finalización de los cálculos & & \\
            \hline
            Acceso individual a SC & & \\
            \hline
        \end{tabular}
        \label{tab:ej_2}
        \caption{Tabla para el ejercicio~\ref{ej:2}.}
        \end{table}
    \end{ejercicio}

    \begin{ejercicio}
        Considerando el siguiente programa concurrente:
        \begin{minted}[escapeinside=\#\#]{pascal}
            cobegin S::<x = x+2> #||# <x = x+3> #||# <x = x+4> coend
        \end{minted}
        Aplicando las reglas de demostración concurrentes estudiadas, demostrar que el siguiente triple de Hoare es un aserto demostrablemente cierto de la Lógica de Programas:
        \begin{equation*}
            \{x=0\}\ S\ \{x=9\}
        \end{equation*}
    \end{ejercicio}

    \begin{ejercicio}
        Si los procedimientos de un monitor solo pueden ser ejecutados por un proceso de un programa concurrente a la vez, ¿cómo se justifica decir que durante la ejecución de un programa concurrente con un monitor se producirá entrelazamiento de sus instrucciones?
    \end{ejercicio}
    \subsubsection*{Resolución de problemas: 25\%}
    \begin{description}
        \item [Ejercicios para los alumnos de GIADE.]~\\
            \begin{ejercicio}
                Una cuenta de ahorros es compartida por varias personas. Cada persona puede depositar o retirar fondos de la cuenta. El saldo actual de la cuenta es la suma de todos los depósitos menos la suma de todos los reintegros. El saldo nunca puede ser negativo. Queremos usar un monitor para resolver el problema. El monitor debe tener 2 procedimientos: \verb|depositar(c)| y \verb|retirar(c)|. Suponer que los argumentos de las 2 operaciones son siempre positivos, e indican las cantidades a depositar o retirar. El monitor usará la semántica señalar y espera urgente (SU).

                \noindent
                El reintegro de fondos a los clientes se hace únicamente según el orden de llegada, es decir, si hay más de un cliente esperando, sólo el primero que llegó puede optar a retirar la cantidad que desea, mientras esto no sea posible, esperarán todos los demás clientes, independientemente de cuanto quiera retirar cada uno. Por ejemplo, suponer que el saldo es 200 unidades y un cliente está ya esperando un reintegro de 300 unidades; si llega después otro cliente que quiere retirar las 200 unidades, debe esperarse. Para resolverlo se pueden utilizar variables condición prioritarias.
            \end{ejercicio}

            \begin{ejercicio}
                Supongamos que tenemos $N$ procesos concurrentes semejantes. Cada proceso produce $N-1$ caracteres (con $N-1$ llamadas a la función \verb|ProduceCaracter()|) y envía cada carácter a los otros $N-1$ procesos. Además, cada proceso debe imprimir todos los caracteres recibidos de los otros procesos. En la solución al problema anterior se ha de garantizar que el orden en el que se imprimen los caracteres es el mismo orden en el que se iniciaron los envíos de dichos caracteres (pista: usa un \verb|select| para recibir).
            \end{ejercicio}

        \item [Ejercicios para los alumnos de GIM.]~\\
            \begin{ejercicio}
                Suponer un sistema básico de asignación de páginas de memoria de un sistema operativo que proporciona 2 operaciones: \verb|adquirir(positive n)| y \verb|liberar(positive n)| para que los procesos de usuario puedan obtener las páginas que necesiten y, posteriormente, dejarlas libres para ser utilizadas por otros procesos del sistema. Cuando los procesos llaman a la operación \verb|adquirir(positive n)|, si no hay memoria disponible para atenderla, la petición quedaría pendiente hasta que exista un número de páginas libres suficiente en memoria. Llamando a la operación \verb|liberar(positive n)|, un proceso convierte en disponibles "n" páginas de la memoria del sistema. Suponemos que los procesos adquieren y devuelven páginas del mismo tamaño a un área de memoria con estructura de cola y en la que suponemos que no existe el problema conocido como fragmentación de páginas de la memoria.

                \noindent
                Se pide definir el invariante y programar un monitor –de acuerdo con él– con las operaciones anteriores suponiendo semántica de señales SU. Resolverlo para los dos casos siguientes: (a) suponiendo orden FIFO estricto para atender las llamadas a la operación de \textit{adquirir} páginas por parte de los procesos del sistema; (b) relajando la condición anterior, resolverlo ahora atendiendo las llamadas según el siguiente orden prioritario: petición pendiente con “menor número de páginas primero” (SJF) y utilizando \underline{variables condición prioritarias} en este segundo caso.
            \end{ejercicio}

            \begin{ejercicio}
                Se tienen N procesos cliente que interactúan con el proceso servidor de 1 cajero automático.
                \begin{itemize}
                    \item Los procesos cliente obtienen dinero del cajero realizando lo siguiente: informan de su identidad al proceso servidor del cajero y solicitan una cantidad de dinero.
                    \item El proceso cajero responde con la cantidad solicitada si el cliente tiene suficiente saldo y dispone de suficiente efectivo; si no, el cajero responde denegando la petición al cliente.
                    \item Para ingresar dinero en el cajero los procesos sólo tienen que identificarse e indicar la cantidad que van a ingresar.
                    \item Suponer que cada cliente tiene inicialmente 10 unidades de saldo y que el cajero posee 100 unidades de efectivo (hasta que las agote y no se incrementan con los ingresos) para servir las peticiones de los clientes.
                    \item Cuando el cajero agota completamente las 100 unidades de efectivo, no podrá servir peticiones de ningún tipo hasta pasada 1 hora, transcurrido ese tiempo se vuelven a reponer las 100 unidades
                \end{itemize}
                Se pide: utilizar la orden de selección no determinista para programar el proceso servidor del cajero. Programar, además, un cliente generico que realice ingresos y reintegros aleatorios y repetitivamente para completar la simulación.
            \end{ejercicio}
    \end{description}

    % \setcounter{ejercicio}{0}

\end{document}
