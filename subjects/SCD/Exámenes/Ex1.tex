\documentclass[12pt]{article}

\input{../../_assets/preambulo.tex}

\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    
    \input{../../_assets/portada}
    \portadaExamen{etsiitA4.jpg}{Sistemas\\ Concurrentes y\\ Distribuidos\\Examen I}{SCD\@. Examen I}{MidnightBlue}{-8}{28}{2024}{José Juan Urrutia Milán}

    \begin{description}
        \item[Asignatura] Sistemas Concurrentes y Distribuidos.
        \item[Curso Académico] 2020-21.
        \item[Grupo] Único.
        \item[Descripción] Examen parcial de los Temas 1, 2 y 3 de SCD.
        \item[Fecha] 13-01-2021.
    \end{description}
    \newpage


    % ------------------------------------
    
    \subsubsection*{Preguntas de respuesta alternativa: 35\%}
    \begin{ejercicio}
        Seleccione la única respuesta correcta de cada una de las cuestiones siguientes; cada una bien contestada tiene una puntuación de \textbf{0.5}.
        \begin{enumerate}
            \item Un programa concurrente que cumpla la propiedad de \textit{seguridad} para todas sus ejecuciones se considerará correcto si además cumple que:
                \begin{enumerate}[label=(\alph*)]
                    \item Los procesos del programa nunca pueden llegar a una situación de \textit{interbloqueo}.
                    \item Se puede demostrar que sus procesos no sufren \textit{inanición} en ninguna posible ejecución del programa.
                    \item Sus procesos siempre consiguen ejecutar sus instrucciones de forma equitativa o justa.
                    \item Habrá que demostrar la no \textit{inanición} de los procesos y, además, la \textit{vivacidad} (o ``liveness'').
                \end{enumerate}
            \item La \textit{hipótesis de progreso finito} asegura que durante la ejecución de cualquier programa concurrente se cumplirá:
                \begin{enumerate}[label=(\alph*)]
                    \item La velocidad de ejecución individual de los procesos está limitada por las características del procesador que ejecute el código generado por el compilador.
                    \item Siempre ha de existir algún proceso activo (ejecutándose) durante la ejecución del programa.
                    \item La propiedad de \textit{ausencia de inanición} de los procesos en todo momento.
                    \item Cualquier proceso del programa, que comienza la ejecución de una instrucción, ha de completar alguna vez la ejecución de esta.
                \end{enumerate}
            \item Aplicando la propiedad \textit{como máximo una vez} a la evaluación de sentencias como $x=expresion$, que son evaluadas por los siguientes procesos concurrentes ¿cuál de las siguientes evaluaciones se puede considerar que se realiza \textit{atómicamente} (\verb|<x = expresion>|)? (suponer que los valores iniciales de las variables == 0 y que \verb|a| y \verb|b| son constantes):
                \begin{enumerate}[label=(\alph*)]
                    \item $P_1$: \verb|cobegin x = y + a| \verb+||+ \verb|y = x + b coend|.
                    \item $P_2$: \verb|cobegin x = y + a| \verb+||+ \verb|y = f(x) + b coend|.
                    \item $P_3$: \verb|cobegin x = y + a| \verb+||+ \verb|y = a + b coend|.
                    \item $P_4$: \verb|cobegin x = x / y| \verb+||+ \verb|y = a + x coend|.
                \end{enumerate}
            \item Respecto de la orden de espera selectiva (\verb|select|) utilizadas por sistemas con paso de mensajes bloqueante, se poducirá inmediatamente la elección y ejecución si:
                \begin{enumerate}[label=(\alph*)]
                    \item En ese momento solo exista 1 proceso del programa que haya iniciado el envío de mensaje.
                    \item Sea la única orden \textit{potencialmente ejecutable} de dicha instrucción \verb|select|.
                    \item Sea \textit{potencialmente ejecutable} y se nombre en la guarda un proceso que ya inició su envío.
                    \item Nombre a uno de los procesos del programa que ya iniciaron su envío de mensaje.
                \end{enumerate}
            \item En relación al problema de la sección crítica para N procesos y su relación con las propiedades de corrección de los programas concurrentes se puede afirmar que:
                \begin{enumerate}[label=(\alph*)]
                    \item Si un algoritmo cumple las 4 \textit{condiciones de Dijkstra}, entonces se puede decir que es una solución \textit{totalmente correcta} a tal problema.
                    \item En el algoritmo de Dijkstra se puede afirmar que ningún grupo de procesos puede ser adelantado indefinidamente por otros procesos que consiguen acceder a la sección crítica repetidamente, impidiéndoles a entrar a esta.
                    \item Con el algoritmo de Knuth el mayor retraso que podría sufrir un proceso \textit{solicitante}, sujeto al peor escenario posible de planificación para él, sería esperar como máximo un número de turnos igual al número de procesos anteriores a dicho proceso en el denominado turno cíclico de acceso a la sección crítica.
                    \item Con el algoritmo de Peterson nunca podría ocurrir que existieran etapas vacías (sin ningún proceso esperando) y anteriores a una etapa a la que se acaba de unir un segundo proceso.
                \end{enumerate}
            \item Respecto de la demostración de las propiedades de los monitores:
                \begin{enumerate}[label=(\alph*)]
                    \item El invariante de los monitores –para señales de semántica desplazante (SS,SE,SU)– necesariamente ha de cumplirse después de ejecutar la operación de sincronización \verb|c.wait()| en la programación de los procedimientos de un monitor.
                    \item Con semántica de \textit{señales urgentes} (SU) la ejecución de una operación \verb|c.wait()| nunca puede provocar la entrada al monitor de un proceso suspendido en una cola distinta a la cola de entrada al monitor.
                    \item Para programar correctamente los monitores que usan variables condición del tipo \textit{señalar y salir} (SS) hay que programar siempre la operación de sincronización \verb|c.signal()| como la última instrucción de los procedimientos.
                    \item Si las señales que usa un monitor tienen semántica \textit{señalar y continuar} (SC), el proceso señalador –tras provocar la ejecución de \verb|c.signal()|– sigue su ejecución dentro del monitor pero el proceso notificado solo sale de cola en la que estuviera suspendido.
                \end{enumerate}
            \item Respecto de las operaciones de paso de mensajes no-bloqueantes:
                \begin{enumerate}[label=(\alph*)]
                    \item Siempre (incluso son soporte hardware) es necesario programar operaciones de comprobación que indiquen si es seguro acceder a los datos en transmisión antes de que la ejecución de la operación \verb|receive()| devuelva el control al proceso receptor.
                    \item Si el proceso receptor está preparado para recibir los datos en transmisión, la ejecución de la operación \verb|receive()| \textit{vuelve} inmediatamente siempre.
                    \item El proceso emisor siempre supone que la ejecución de la operación \verb|send()| accederá a datos en un estado inseguro.
                    \item Existe un caso en el cual la ejecución de la operación \verb|receive()| no detiene al proceso receptor aunque no se hayan terminado de transmitir los datos que han de recibirse.
                \end{enumerate}
        \end{enumerate}
    \end{ejercicio}

    \subsubsection*{Cuestiones y ejercicios: 40\%}
    \begin{ejercicio}\label{ej:2}
        Sobre la diferencia conceptual existente entre las denominadas \textit{propiedades de seguridad} y \textit{vivacidad} respecto de su validez temporal durante la ejecución de un programa concurrente:
        \begin{itemize}
            \item Clasificar las propiedades de la tabla según el tipo de propiedad al que pertenecen (aparte, justificarlo brevemente).
            \item ¿En qué instante(s) de la ejecución de los programas se ha de cumplir cada uno de los siguientes tipos de propiedades? Elegir una de las posibilidades de validez temporal para cada una de las propiedades de la siguiente tabla:
                \begin{enumerate}[label=(\alph*)]
                    \item Siempre.
                    \item Alguna vez.
                    \item Intermitentemente.
                    \item Alguna vez en el futuro y, desde entonces, para siempre.
                \end{enumerate}
        \end{itemize}
        \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{nombre propiedad} & \textbf{tipo propiedad} (\textit{seguridad}$|$\textit{vivacidad}) & (\textbf{a}$|$\textbf{b}$|$\textbf{c}$|$\textbf{d}) \\
            \hline
            Exclusión mutua & & \\
            \hline
            Ausencia de interbloqueo & & \\
            \hline
            Alcanzabilidad de la SC & & \\
            \hline
            Productor-consumidor & & \\
            \hline
            No inanición procesos & & \\
            \hline
            Equidad procesoss & & \\
            \hline
            Finalización de los cálculos & & \\
            \hline
            Acceso individual a SC & & \\
            \hline
        \end{tabular}
        \caption{Tabla para el ejercicio~\ref{ej:2}.}
        \end{table}
    \end{ejercicio}

    \begin{ejercicio}
        Considerando el siguiente programa concurrente:
        \begin{minted}[escapeinside=\#\#]{pascal}
            S :: cobegin <x = x+2> #||# <x = x+3> #||# <x = x+4> coend
        \end{minted}
        Aplicando las reglas de demostración concurrentes estudiadas, demostrar que el siguiente triple de Hoare es un aserto demostrablemente cierto de la Lógica de Programas:
        \begin{equation*}
            \{x=0\}\ S\ \{x=9\}
        \end{equation*}
    \end{ejercicio}

    \begin{ejercicio}
        Si los procedimientos de un monitor solo pueden ser ejecutados por un proceso de un programa concurrente a la vez, ¿cómo se justifica decir que durante la ejecución de un programa concurrente con un monitor se producirá entrelazamiento de sus instrucciones?
    \end{ejercicio}
    \subsubsection*{Resolución de problemas: 25\%}
    \begin{description}
        \item [Ejercicios para los alumnos de GIADE.]~\\
            \begin{ejercicio}
                Una cuenta de ahorros es compartida por varias personas. Cada persona puede depositar o retirar fondos de la cuenta. El saldo actual de la cuenta es la suma de todos los depósitos menos la suma de todos los reintegros. El saldo nunca puede ser negativo. Queremos usar un monitor para resolver el problema. El monitor debe tener 2 procedimientos: \verb|depositar(c)| y \verb|retirar(c)|. Suponer que los argumentos de las 2 operaciones son siempre positivos, e indican las cantidades a depositar o retirar. El monitor usará la semántica señalar y espera urgente (SU).

                \noindent
                El reintegro de fondos a los clientes se hace únicamente según el orden de llegada, es decir, si hay más de un cliente esperando, sólo el primero que llegó puede optar a retirar la cantidad que desea, mientras esto no sea posible, esperarán todos los demás clientes, independientemente de cuanto quiera retirar cada uno. Por ejemplo, suponer que el saldo es 200 unidades y un cliente está ya esperando un reintegro de 300 unidades; si llega después otro cliente que quiere retirar las 200 unidades, debe esperarse. Para resolverlo se pueden utilizar variables condición prioritarias.
            \end{ejercicio}

            \begin{ejercicio}
                Supongamos que tenemos $N$ procesos concurrentes semejantes. Cada proceso produce $N-1$ caracteres (con $N-1$ llamadas a la función \verb|ProduceCaracter()|) y envía cada carácter a los otros $N-1$ procesos. Además, cada proceso debe imprimir todos los caracteres recibidos de los otros procesos. En la solución al problema anterior se ha de garantizar que el orden en el que se imprimen los caracteres es el mismo orden en el que se iniciaron los envíos de dichos caracteres (pista: usa un \verb|select| para recibir).
            \end{ejercicio}

        \item [Ejercicios para los alumnos de GIM.]~\\
            \begin{ejercicio}
                Suponer un sistema básico de asignación de páginas de memoria de un sistema operativo que proporciona 2 operaciones: \verb|adquirir(positive n)| y \verb|liberar(positive n)| para que los procesos de usuario puedan obtener las páginas que necesiten y, posteriormente, dejarlas libres para ser utilizadas por otros procesos del sistema. Cuando los procesos llaman a la operación \verb|adquirir(positive n)|, si no hay memoria disponible para atenderla, la petición quedaría pendiente hasta que exista un número de páginas libres suficiente en memoria. Llamando a la operación \verb|liberar(positive n)|, un proceso convierte en disponibles \verb|n| páginas de la memoria del sistema. Suponemos que los procesos adquieren y devuelven páginas del mismo tamaño a un área de memoria con estructura de cola y en la que suponemos que no existe el problema conocido como fragmentación de páginas de la memoria.

                \noindent
                Se pide definir el invariante y programar un monitor –de acuerdo con él– con las operaciones anteriores suponiendo semántica de señales SU\@. Resolverlo para los dos casos siguientes: (a) suponiendo orden FIFO estricto para atender las llamadas a la operación de \textit{adquirir} páginas por parte de los procesos del sistema; (b) relajando la condición anterior, resolverlo ahora atendiendo las llamadas según el siguiente orden prioritario: petición pendiente con ``menor número de páginas primero'' (SJF) y utilizando \underline{variables condición prioritarias} en este segundo caso.
            \end{ejercicio}

            \begin{ejercicio}
                Se tienen N procesos cliente que interactúan con el proceso servidor de 1 cajero automático.
                \begin{itemize}
                    \item Los procesos cliente obtienen dinero del cajero realizando lo siguiente: informan de su identidad al proceso servidor del cajero y solicitan una cantidad de dinero.
                    \item El proceso cajero responde con la cantidad solicitada si el cliente tiene suficiente saldo y dispone de suficiente efectivo; si no, el cajero responde denegando la petición al cliente.
                    \item Para ingresar dinero en el cajero los procesos sólo tienen que identificarse e indicar la cantidad que van a ingresar.
                    \item Suponer que cada cliente tiene inicialmente 10 unidades de saldo y que el cajero posee 100 unidades de efectivo (hasta que las agote y no se incrementan con los ingresos) para servir las peticiones de los clientes.
                    \item Cuando el cajero agota completamente las 100 unidades de efectivo, no podrá servir peticiones de ningún tipo hasta pasada 1 hora, transcurrido ese tiempo se vuelven a reponer las 100 unidades
                \end{itemize}
                Se pide: utilizar la orden de selección no determinista para programar el proceso servidor del cajero. Programar, además, un cliente generico que realice ingresos y reintegros aleatorios y repetitivamente para completar la simulación.
            \end{ejercicio}
    \end{description}

    \newpage
    \setcounter{ejercicio}{0}
    \subsection*{Soluciones}

    \begin{ejercicio}
        Aunque en el examen original no era necesario justificar las respuestas\footnote{Salvo para aclarar algunas elecciones.}:
        \begin{enumerate}
            \item (b): (a) no es porque situación de interbloqueo es una propiedad de seguridad, (c) tampoco porque la equidad no es necesaria para que el programa se considere correcto y (d) tampoco porque la no inanición y la vivacidad son lo mismo.
            \item (d): la ausencia de inanición en (c) es una propiedad de vivacidad y (a) y (b) no tienen nada que ver con progreso finito.
            \item (c): ya que en todas se modifican las variables \verb|x| e \verb|y|, pero (c) es el único bloque que utiliza \textit{como máximo una vez} una variable modificada, \verb|y| (el resto utilizan tanto \verb|y| como \verb|x|).
            \item (c): ya que en (a) la condición de la guarda puede ser falsa, en (b) el programa se bloqueará y en (d) puede que la sentencia \verb|select| seleccione a otra instruccion con guarda para ejecución.
            \item (d): (a) no es porque faltaría probar la vivacidad de la solución (tendríamos solo ausencia de interbloqueo y exclusión mutua), (b) no es porque no comple la propiedad de vivacidad, (c) tampoco porque el mayor retraso es de $f(n) = 2f(n-1)+1$ y (d) sí que es por el Lema 3 que vimos en teoría (si en alguna etapa existen al menos dos procesos, entonces el resto de etapas anteriores contienen como mínimo un proceso, por lo que no pueden existir etapas vacías anteriores a la misma).
            \item (d): (a) es falsa porque después de \verb|c.wait()| ha de cumplirse la \textit{condición de sincronización} de la variable \verb|c|, (b) es falsa porque contamos además con la cola de procesos urgentes cuando trabajamos con SU y (c) es falsa porque la tras \verb|c.signal()| podríamos colocar un \verb|wait| sobre otra (o la misma) variable condición. Además, (d) es cierta porque describe el comportamiento de SC\@.
            \item (d).
        \end{enumerate}
    \end{ejercicio}

    \begin{ejercicio}
        Rellenamos la tabla, teniendo en cuenta que (a) y (c) hacen referencia a propiedades de seguridad y (b) y (d) a propiedades de vivacidad.
        \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{nombre propiedad} & \textbf{tipo propiedad} (\textit{seguridad}$|$\textit{vivacidad}) & (\textbf{a}$|$\textbf{b}$|$\textbf{c}$|$\textbf{d}) \\
            \hline
            Exclusión mutua & seguridad & a \\
            \hline
            Ausencia de interbloqueo & seguridad & a \\
            \hline
            Alcanzabilidad de la SC & seguridad & a \\
            \hline
            Productor-consumidor & seguridad & a \\
            \hline
            No inanición procesos & vivacidad & b \\
            \hline
            Equidad procesos & vivacidad & b \\
            \hline
            Finalización de los cálculos & vivacidad & d \\
            \hline
            Acceso individual a SC & seguridad & c \\
            \hline
        \end{tabular}
        \end{table}
    \end{ejercicio}

    \begin{ejercicio}
        Hemos de demostrar $\{s=0\}\ S\ \{x=9\}$ siendo $S$:
        \begin{minted}[escapeinside=\#\#]{pascal}
            cobegin <x = x+2> #||# <x = x+3> #||# <x = x+4> coend
        \end{minted}
        Para ello, primero consideramos los triples:
        \begin{gather*}
            \{x=0 \lor x=3 \lor x=4 \lor x=7\}\ \texttt{<x = x+2>;}\ \{x=2 \lor x=5 \lor x=6 \lor x=9\} \\
            \{x=0 \lor x=2 \lor x=4 \lor x=6\}\ \texttt{<x = x+3>;}\ \{x=3 \lor x=5 \lor x=7 \lor x=9\} \\
            \{x=0 \lor x=2 \lor x=3 \lor x=5\}\ \texttt{<x = x+4>;}\ \{x=4 \lor x=6 \lor x=7 \lor x=9\}
        \end{gather*}
        Todos ellos ciertos por el axioma de asignación:
        \begin{multline*}
            \{x=2 \lor x=5 \lor x=6 \lor x=9\}^x_{x+2} \equiv \\  \{x+2=2 \lor x+2=5 \lor x+2=6 \lor x+2=9\} \equiv \\
             \{x=0 \lor x=3 \lor x=4 \lor x=7\} 
        \end{multline*}
        \begin{multline*}
            \{x=3 \lor x=5 \lor x=7 \lor x=9\}^x_{x+3} \equiv \\  \{x+3=3 \lor x+3=5 \lor x+3=7 \lor x+3=9\} \equiv \\
             \{x=0 \lor x=2 \lor x=4 \lor x=6\} 
        \end{multline*}
        \begin{multline*}
            \{x=4 \lor x=6 \lor x=7 \lor x=9\}^x_{x+4} \equiv \\  \{x+4=4 \lor x+4=6 \lor x+4=7 \lor x+4=9\} \equiv \\
             \{x=0 \lor x=2 \lor x=3 \lor x=5\} 
        \end{multline*}
        Renombrando a los triples anteriores de forma:
        \begin{equation*}
            \{P_1\}\ S_1\ \{Q_1\} \qquad \{P_2\}\ S_2\ \{Q_2\} \qquad \{P_3\}\ S_3\ \{Q_3\}
        \end{equation*}
        repectivamente. Hemos de probar la no interferencia de cada triple con el resto, por lo que hemos de probar 12 triples de no interferencia:
        \begin{align*}
            &NI(P_2, S_1) \qquad NI(Q_2, S_1) \qquad NI(P_3, S_1) \qquad NI(Q_3, S_1) \\
            &NI(P_1, S_2) \qquad NI(Q_1, S_2) \qquad NI(P_3, S_2) \qquad NI(Q_3, S_2) \\
            &NI(P_2, S_3) \qquad NI(Q_2, S_3) \qquad NI(P_1, S_3) \qquad NI(Q_1, S_3) 
        \end{align*}
        Probaremos uno de ellos y notaremos que la por la forma en la que hemos definido los tres triples anteriores, hemos ya tenido en cuenta las precondiciones y poscondiciones apropiadas para la no interferencia entre cada uno de ellos:
        \begin{multline*}
            NI(P_2, S_1) \equiv \{P_2 \land P_1\}\ S_1\ \{P_2\} \equiv \\
            \{x=0 \lor x=4\}\ \texttt{<x = x+2>;}\ \{x=0 \lor x=2 \lor x=4 \lor x=6\} 
        \end{multline*}
        Como $\{x=0 \lor x=4\}\ \texttt{<x = x+2>;}\ \{x=2 \lor x=6\}$ es cierto por el axioma de asignación y se verifica que $\{x=2 \lor x=6\}\rightarrow P_2$, tenemos que $NI(P_2, S_1)$ es cierto por la primera regla de la consecuencia.\\

        Probando todos los triples de no interferencia, llegamos a que los tres triples anteriores están libres de interferencia, por lo que podemos aplicar la regla de la composición concurrente, llegando a que el triple:
        \begin{equation*}
        \{P_1 \land P_2 \land P_3\}\ S\ \{Q_1 \land Q_2 \land Q_3\} \equiv 
            \{x=0\}\ S\ \{x=9\}
        \end{equation*}
        es cierto.
    \end{ejercicio}

    \begin{ejercicio}
        Durante la ejecución de un programa concurrente con un monitor se producirá entrelazamiento de sus instrucciones si dentro del monitor hemos usado variables tipo condición y operaciones \verb|wait| y \verb|signal| sobre las mismas, de forma que troozos de código de procedimientos se puedan ejecutar entre el código de un procedimiento distinto, como consecuencia del bloqueo del proceso que ejecutaba dicho procedimiento.
    \end{ejercicio}

    \begin{description}
        \item [Ejercicios para GIADE.]~\\
            \begin{ejercicio}\label{ej:5}
                Para resolver el ejercicio, hemos hecho uso de una variable permanente auxiliar \verb|contador|, para asignar los turnos a los clientes que quieran extrar de su cuenta.
                \begin{minted}{pascal}
                    monitor Cuenta;
                       var saldo, contador : integer;
                           cola : condition;

                       begin
                          saldo := 0;
                          contador := 0;
                       end

                       procedure depositar(c : integer);
                       begin
                          {deposito c y dejo pasar al siguiente}
                          saldo := saldo + c;
                          cola.signal();
                       end

                       procedure retirar(c : integer);
                       var ticket : integer;
                       begin
                          {coge su ticket}
                          ticket := contador;
                          contador := contador + 1;

                          {si hay alguien delante, espera}
                          if cola.queue() then
                             cola.wait(ticket);

                          {si soy el primero, espero hasta que el saldo incremente}
                          while saldo < c do begin
                             cola.wait(ticket);
                          end

                          {me llevo lo que quiero y dejo pasar al siguiente}
                          saldo := saldo - c;
                          cola.signal();
                       end
                    end
                \end{minted}
            \end{ejercicio}

            \begin{ejercicio}
                Se trata de un ejercicio de programación distribuida.
            \end{ejercicio}
        \item [Ejercicios para GIM.]~\\
            \begin{ejercicio}
                Resolvemos los dos apartados:
                \begin{enumerate}[label=(\alph*)]
                    \item Presentamos la solución a la primera opción, la asignación FIFO, definiendo antes el invariante:
                        \begin{multline*}
                            \{IM\} \equiv \{0 \leq paginas_{ocupadas} \leq libres\_iniciales\ \land \\ (libres = 0 \Longleftrightarrow paginas_{ocupadas} = libres\_iniciales)\}
                        \end{multline*}
                        La solución es similar que para el Ejercicio~\ref{ej:5}:
                        \begin{minted}{pascal}
                            monitor AsignacionFIFO(libres_iniciales : positive);
                               var libres : integer;
                                   cola, ventanilla : condition;

                               begin
                                  libres := libres_iniciales;
                               end

                               procedure liberar(n : positive);
                               begin
                                  {Se liberan las páginas}
                                  libres := libres + n;
                                  ventanilla.signal();
                               end

                               procedure adquirir(n : positive);
                               var ticket : integer;
                               begin
                                  {Si hay otro antes, espera}
                                  if ventanilla.queue() then
                                     cola.wait();

                                  {Espera mientras no haya páginas libres}
                                  while libres < n do begin
                                     ventanilla.wait();
                                  end

                                  {Reserva sus páginas}
                                  libres := libres - n;
                                  cola.signal();
                               end
                            end
                        \end{minted}
                    \item Si ahora realizamos la asignación según SJF (\textit{Shortest Job First}), usando variables condición prioritarias:
                        \begin{minted}{pascal}
                            monitor AsignacionSJF(libres_iniciales : positive);
                               var libres : integer;
                                   cola : condition;

                               begin
                                  libres := libres_iniciales;
                               end

                               procedure liberar(n : positive);
                               begin
                                  {Se liberan las páginas}
                                  libres := libres + n;
                                  cola.signal();
                               end

                               procedure adquirir(n : positive);
                               begin
                                  {Espera mientras no haya páginas libres}
                                  while libres < n do begin
                                     cola.wait(n);
                                  end

                                  {Reserva sus páginas}
                                  libres := libres - n;
                                  cola.signal();
                               end
                            end
                        \end{minted}
                \end{enumerate}
            \end{ejercicio}

            \begin{ejercicio}
                Se trata de un ejercicio de programación distribuida.
            \end{ejercicio}
    \end{description}
\end{document}
