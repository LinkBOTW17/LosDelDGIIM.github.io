El siguiente documento pdf no es sino el mero resultado proveniente de la amalgación proficiente de un cúmulo de notas, todas ellas tomadas tras el transcurso de consecutivas clases magistrales, primordialmente —empero, no exclusivamente— de teoría, en simbiosis junto con una síntesis de los apuntes originales provenientes de la asignatura en la que se basan los mismos.

Como motivación para la asignatura, introducimos a continuación un par de problemas que sabremos resolver tras la finalización de esta:

\begin{ejercicio*}[Parque de atracciones]
Disponemos de un conjunto de atracciones 
\[
A_1, A_2, \ldots, A_n
\]
Para cada atracción, conocemos la hora de inicio y la hora de fin. Podemos proponer varios retos de programación acerca de este parque de atracciones:
\begin{enumerate}
    \item Seleccionar el mayor número de atracciones que un individuo puede visitar.
    \item Seleccionar las atraciones que permitan que un visitante esté ocioso el menor tiempo posible.
    \item Conocidas las valoraciones de los usuarios, $val(A_i)$, seleccionar aquellas que garanticen la máxima valoración conjunta en la estancia.
\end{enumerate}
\end{ejercicio*}

\begin{ejercicio*}
Una empresa decide comprar un robot que deberá soldar varios puntos ($n$) en un plano. El software del robot está casi terminado pero falta diseñar el algoritmo que se encarga de decidir en qué orden el robot soldará los $n$ puntos. Se pide diseñar dicho algoritmo, minimizando el tiempo de ejecución del robot (este depende del tiempo de soldadura que es constante más el tiempo de cada desplazamiento entre puntos, que depende de la distancia entre ellos). Por tanto, deberemos ordenar el conjunto de puntos minimizando la distancia total de recorrido.
\end{ejercicio*}

\subsubsection{Nociones de conceptos}
A lo largo de la asignatura, será común ver los siguientes conceptos, los cuales aclararemos antes de empezar la misma:
\begin{itemize}
    \item Instancia: Ejemplo particular de un problema.
    \item Caso: Instancia de un problema con una cierta dificultad.
\end{itemize}

Generalmente, tendremos tres casos:
\begin{itemize}
    \item El mejor caso: Instancia con menor número de operaciones y/o comparaciones.
    \item El peor caso: Instancia con mayor número de operaciones y/o comparaciones.
    \item Caso promedio. Normalmente, será igual al peor caso.
\end{itemize}
Para notar la eficiencia del peor caso usaremos $O(\cdot)$, mientras que para el mejor caso, $\Omega(\cdot)$.

Diremos que un algoritmo es \ŧextit{estable} en ordenación si, dado un criterio de ordenación que hace que dos elementos sean iguales en cuanto a orden, el orden de stos vendrá dado por el primero se que introdujo en la entrada. 
\begin{ejemplo}
    Dado el criterio de que un número es menor que otro si es par, ante la instancia del problema: $1, 2, 3, 4$. La salida de un algoritmo de ordenación estable según este criterio será:
\[
2, 4, 1, 3
\]
Sin embargo, un ejemplo de salida que podría dar un algoritmo no estable sería:
\[
4, 2, 3, 1
\]

Los datos se encuentra ordenados pero no en el orden de la entrada.
\end{ejemplo}

\subsubsection{Algoritmos de ordenación}
A continuación, un breve reapso de algoritmos de ordenación:

\begin{itemize}
    \item Burbuja es el peor algoritmo de ordenación.
    \item Si tenemos pocos elementos, suele ser más rápido un algoritmos simple como selección o inserción. Entre estos, selección hace muchas comparaciones y pocos intercambios, mientras que inserción hace menos comparaciones y más intercambios. Por tanto, ante datos pesados con varios registros, selección será mejor que insercción.
    \item Cuando se tienen muchos elementos, es mejor emplear un algoritmo de ordenación del orden $n\log(n)$.
\end{itemize}


