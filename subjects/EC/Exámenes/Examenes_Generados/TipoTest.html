<!DOCTYPE html>
<html>
<head>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans-serif;
        }
        code, pre {
            font-family: monospace;
        }
        h1 code,
        h2 code,
        h3 code,
        h4 code,
        h5 code,
        h6 code {
            font-size: inherit;
        }
        ul li {
            list-style-type: none;
        }
        table {
        @extend .table;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>EC. Preguntas Tipo Test de Teoría.</h1>
<p><strong>Autor:</strong> Jose Juan Urrutia Milán 'JJ'.<br>
<strong>Autor:</strong> Lucas Hidalgo Herrera.<br>
<strong>Autor:</strong> Arturo Olivares Martos.</p>
<hr>
<ul>
<li><strong>Asignatura:</strong> Estructura de Computadores.</li>
<li><strong>Curso Académico:</strong> 2023-24.</li>
<li><strong>Grado:</strong> Doble Grado en Ingeniería Informática y Matemáticas.</li>
<li><strong>Grupo:</strong> A.</li>
<li><strong>Profesor:</strong> Ignacio Rojas Ruiz.</li>
<li><strong>Descripción:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Estructura de Computadores. En él, se pueden encontrar una gran variedad de preguntas de EC de los últimos años.</li>
</ul>
<p>Las preguntas se encuentran en esta web.</p>
<p>Las explicaciones de cada pregunta se pueden encontrar en el archivo Markdown correspondiente, que se encuentra pinchando aquí.</p>
<hr>
<ol>
<li>
<p>Respecto a direccionamiento a memoria en ensamblador IA32 (sintaxis AT&amp;T), de la forma <code>D(Rb, Ri, S)</code>, sólo una de las siguientes afirmaciones es FALSA. ¿Cuál?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  El desplazamiento D puede ser una constante lineal (1, 2 ó 4 bytes).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>EBP</code> no se puede usar como registro base.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>ESP</code> no se puede usar como registro índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  El factor de escala S pued</label></li>
</ul>
</li>
<li>
<p>La extensión de signo a m bits de un número original N de n bits, con m &gt; n, consiste en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N}\)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N-1}\)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Incrementar la cantidad de bits a m preservando el signo y el valor del número.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Incrementar la cantidad de bits a m rellenando con unos por la izquierda.</label></li>
</ul>
</li>
<li>
<p>En IA32, ¿cuál de los siguientes fragmentos de programa tiene un efecto sobre los flags distinto al resto?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>sub %edi,%edi</code> <br> <code>adc $0xFFFFFFFF, %edi</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov $-1, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov$-1,%edi</code> <br> <code>add $0, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov $0, %edi</code> <br> <code>sub $1, %edi</code></label></li>
</ul>
</li>
<li>
<p>Si <code>%rsp</code> vale <code>0xdeadbeefdeadd0d0</code>, ¿cuál será su nuevo valor después de que se ejecute <code>pushq %rbx?</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0cc</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xdeadbeefdeadd0c8</code></label></li>
</ul>
</li>
<li>
<p>¿Cómo se devuelve en ensamblador x86-64 Linux gcc el valor de retorno de una función long int al terminar esta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La instrucción <code>RET</code> lo almacena en un registro especial de retorno.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Por convención se guarda en <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Se almacena en pila justo encima de los argumentos de la función.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de esas formas es correcta.</label></li>
</ul>
</li>
<li>
<p>Comparando las convenciones de llamada de gcc Linux IA32 con x86-64 respecto a registros.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebx</code> es salva-invocante, pero en x86-64 <code>%rbx</code> es salva-invocado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En IA32 <code>%ecs</code> es salva-invocante, y en x86-64 <code>%rcd</code> es salva-invocante también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%esi</code> es salva-invocado, y en x86-64 <code>%rsi</code> es salva-invocado también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebp</code> es especial (marco de pila1), y en x86-64 <code>%rbp</code> también.</label></li>
</ul>
</li>
<li>
<p>Son funciones de la unidad de control:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La codificación de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  La lectura de memoria principal de la instrucción apuntada por el PC.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El secuenciamiento de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Todas las respuestas son ciertas.</label></li>
</ul>
</li>
<li>
<p>Respecto a <code>MBR</code> y <code>MAR</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos son accesibles por el programador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>MAR</code> contiene el dato/instrucción que se leerá o escribirá en memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>MAR</code> requiere menos señales de control que <code>MBR</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos permiten guardar información sobre el marco de pila.</label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina puede desglosarse en las siguientes operaciones elementales:<br>
<code>sp := ps-1; m[sp] := pc; pc:= x</code><br>
Probablemente se trate de una instrucción de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Apilamiento.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Llamada a subrutina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Carga total.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Almacenamiento local.</label></li>
</ul>
</li>
<li>
<p>En una unidad de control microprogramada con formato de microinstrucciones vertical, un subcampo que debe especificar 16 señales de control codificadas de tal forma que pueda activarse sólo una o ninguna harbá de tener una anchura mínima de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  4 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 5 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  16 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  17 bits.</label></li>
</ul>
</li>
<li>
<p>Dado un camino de datos concreto, un posible formato de microprogramación se caracteriza como horizontal o vertical según tenga más o menos (señalar la respuesta falsa)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> codificación</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> solapamiento</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> micro bifurcaciones</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> longitud relativa de microinstrucción</label></li>
</ul>
</li>
<li>
<p>El control residual se utiliza para:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> reducir el tiempo de ejecución de las instrucciones máquina</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> eliminarlos bits residuales de la ejecución de las microinstrucciones</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> reducir el tamaño de la memoria de control</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ninguna de las anteriores es cierta</label></li>
</ul>
</li>
<li>
<p>Un procesador está segmentado en las etapas F, D, E, M y W. Cada una de  ellas consume un tiempo t. La aceleración ideal (si no hay riesgos) al ejecutar n instrucciones respecto a un procesador no segmentado será:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 5n/(4+n)_</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (4+n)/5t</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4n/(5+n)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (5+n)/4t</label></li>
</ul>
</li>
<li>
<p>En un procesador con segmentación de cauce, aumentar el número de etapas (p.ej. de 2 a 4, o de 4 a 8), tiene en general como consecuencia:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un Incremendo De Las Prestaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Un mayor retraso en la ejecución de los programas debido al incremento del número de etapas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución en la posible dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución de la máxima frecuencia de reloj a la que puede operar el cauce.</label></li>
</ul>
</li>
<li>
<p>En la secuencia de instrucciones siguiente, siendo el primer registro el destino, ¿cuántos riesgos se dan?<br>
<code>sub r2,r1,r3 or r8,r6,r2</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un riesgo estructural.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un riesgo por dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un Riesgo Estructural Dos Po dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos riesgos por dependencia de datos y uno de control.</label></li>
</ul>
</li>
<li>
<p>La precaptación(cola de instrucciones) está relacionada con...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Los riesgos estructurales(intenta evitar el efecto de un fallo de cache)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de (dependencia de) datos (intenta que el dato esté disponible anticipadamente)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos control(intenta determinar de antemano el flujo de control)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de transferencia(intenta agrupar las posibles transferencias de un conjunto de instrucciones).</label></li>
</ul>
</li>
<li>
<p>Respecto a la segmentación, ¿cuál de las siguientes afirmaciones es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La técnica de register forwarding habilita una serie de cambios(buses) que se añaden al cauce para permitir que los resultados de una etapa pasen como entradas a la etapa donde son necesarias.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La reorganizacion del código y la introducción de instrucciones no permite evitar dependencias de datos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retrasar la fase de decisión saltar/no saltar de las instrucciones de salto condicional contribuye a mejorar el rendimiento del procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantas más etapas tenga un cauce, más instrucciones se estarán ejecutando en distintas fases y más posibilidades se presentan de que existan riesgos entre ellas.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes modos de direccionamento es menos preferible para un procesador de 32 bits y con tamaño de instrucción de 32 bits?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> registro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indexado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indirecto a través de registro.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> directo (o absoluto)</label></li>
</ul>
</li>
<li>
<p>La conexión entre un dispositivo de E/S y el procesador mediante bus:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es difícil de expandir.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Permite conectar en paralelo varios dispositivos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere mucha circuitería.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere multiplexores y demultiplexores para las señales de datos.</label></li>
</ul>
</li>
<li>
<p>El fragmento de código ensamblador de un microprocesador de 8 bits:<br><code>lds IOBuf  ; Apuntar puntero pila a ...área mem.intermedia<br>ldx Count    ; Inicializar x-contador<br>poll lda a Status; Leer estado en A<br>bpl poll ; Signo (A) != 1 =&gt; repetir<br>lda a Data   ; Leer dato en A<br>psh a       ; transferir dato a pila<br>dex         ; decrementar contador x<br>bne poll    ; Seguir leyendo si x!=0<br></code><br> Corresponde a:<br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Entrada programada con consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada sin consulta de estado. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Entrada programada sin consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada con consulta de estado.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.addClass('text-warning');
            } else {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>