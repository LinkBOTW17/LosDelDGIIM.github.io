<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test EC</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>EC. Preguntas Tipo Test de Teoría + Prácticas.</h1>
<p><strong>Autor:</strong> Jose Juan Urrutia Milán 'JJ'.<br>
<strong>Autor:</strong> Lucas Hidalgo Herrera.<br>
<strong>Autor:</strong> Lucas Hidalgo Herrera.<br>
<strong>Autor:</strong> Roberto González Lugo.<br>
<strong>Autor:</strong> Elías Monge Sánchez.<br>
<strong>Autor:</strong> Jesús Muñoz Velasco.<br>
<strong>Autor:</strong> Arturo Olivares Martos.</p>
<hr>
<ul>
<li><strong>Asignatura:</strong> Estructura de Computadores.</li>
<li><strong>Curso Académico:</strong> 2023-24.</li>
<li><strong>Grado:</strong> Doble Grado en Ingeniería Informática y Matemáticas.</li>
<li><strong>Grupo:</strong> A.</li>
<li><strong>Profesor:</strong> Ignacio Rojas Ruiz.</li>
<li><strong>Descripción:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Estructura de Computadores. En él, se pueden encontrar una gran variedad de preguntas de EC de los últimos años.</li>
</ul>
<p>Es importante destacar que hay preguntas de todos los temas de la asignatura. Además, algunas preguntas podrán ser sobre IA32, que actualmente ya no entra prácticamente en la asignatura.
Por último, puede ser que haya preguntas repetidas. En tal caso, se ruega nos lo comuniquen.</p>
<p>Las preguntas se encuentran en <a href=https://losdeldgiim.github.io/subjects/EC/Ex%C3%A1menes/Examenes_Generados/TipoTest.html>esta web</a>.</p>
<p>Las explicaciones de cada pregunta se pueden encontrar en el archivo Markdown correspondiente, que se encuentra pinchando <a href=https://github.com/LosDelDGIIM/LosDelDGIIM.github.io/blob/main/subjects/EC/Ex%C3%A1menes/TipoTest.md>aquí</a>.</p>
<hr>
<ol>
<li>
<p>Respecto a direccionamiento a memoria en ensamblador x86-64, de la forma <code>D(Rb, Ri, S)</code>, sólo una de las siguientes afirmaciones es FALSA. ¿Cuál?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  El desplazamiento D puede ser una constante lineal (1, 2 ó 4 bytes).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  <code>EBP</code> no se puede usar como registro base.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>ESP</code> no se puede usar como registro índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  El factor de escala <code>S</code> puede ser 1, 2, 4, 8.</label></li>
</ul>
</li>
<li>
<p>La extensión de signo a m bits de un número original N de n bits, con m &gt; n, consiste en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N}\)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N-1}\)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  Incrementar la cantidad de bits a m preservando el signo y el valor del número.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Incrementar la cantidad de bits a m rellenando con unos por la izquierda.</label></li>
</ul>
</li>
<li>
<p>En x86-64, ¿cuál de los siguientes fragmentos de programa tiene un efecto sobre los flags distinto al resto?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>sub %edi,%edi</code> <br> <code>adc $0xFFFFFFFF, %edi</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  <code>mov $-1, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov$-1,%edi</code> <br> <code>add $0, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov $0, %edi</code> <br> <code>sub $1, %edi</code></label></li>
</ul>
</li>
<li>
<p>Si <code>%rsp</code> vale <code>0xdeadbeefdeadd0d0</code>, ¿cuál será su nuevo valor después de que se ejecute <code>pushq %rbx?</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0cc</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  <code>0xdeadbeefdeadd0c8</code></label></li>
</ul>
</li>
<li>
<p>¿Cómo se devuelve en ensamblador x86-64 Linux <code>gcc</code> el valor de retorno de una función <code>long int</code> al terminar esta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La instrucción <code>RET</code> lo almacena en un registro especial de retorno.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Por convención se guarda en <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Se almacena en pila justo encima de los argumentos de la función.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  Ninguna de esas formas es correcta.</label></li>
</ul>
</li>
<li>
<p>Comparando las convenciones de llamada de gcc Linux IA32 con x86-64 respecto a registros <strong>(IA32 ya no entra)</strong>.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebx</code> es salva-invocante, pero en x86-64 <code>%rbx</code> es salva-invocado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En IA32 <code>%ecx</code> es salva-invocante, y en x86-64 <code>%rcx</code> es salva-invocante también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%esi</code> es salva-invocado, y en x86-64 <code>%rsi</code> es salva-invocado también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebp</code> es especial (marco de pila), y en x86-64 <code>%rbp</code> también.</label></li>
</ul>
</li>
<li>
<p>Son funciones de la unidad de control:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La codificación de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  La lectura de memoria principal de la instrucción apuntada por el PC.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  El secuenciamiento de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Todas las respuestas son ciertas.</label></li>
</ul>
</li>
<li>
<p>Respecto a <code>MBR</code> y <code>MAR</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos son accesibles por el programador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>MAR</code> contiene el dato/instrucción que se leerá o escribirá en memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>MAR</code> requiere menos señales de control que <code>MBR</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos permiten guardar información sobre el marco de pila.</label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina puede desglosarse en las siguientes operaciones elementales:<br>
<code>sp := sp-1; m[sp] := pc; pc:= x</code><br>
Probablemente se trate de una instrucción de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Apilamiento.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  Llamada a subrutina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Carga total.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Almacenamiento local.</label></li>
</ul>
</li>
<li>
<p>En una unidad de control microprogramada con formato de microinstrucciones vertical, un subcampo que debe especificar 16 señales de control codificadas de tal forma que pueda activarse sólo una o ninguna harbá de tener una anchura mínima de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  4 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" />  5 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  16 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  17 bits.</label></li>
</ul>
</li>
<li>
<p>Dado un camino de datos concreto, un posible formato de microprogramación se caracteriza como horizontal o vertical según tenga más o menos (señalar la respuesta falsa)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> codificación</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> solapamiento</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> micro bifurcaciones</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> longitud relativa de microinstrucción.</label></li>
</ul>
</li>
<li>
<p>El control residual se utiliza para:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> reducir el tiempo de ejecución de las instrucciones máquina</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> eliminarlos bits residuales de la ejecución de las microinstrucciones</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> reducir el tamaño de la memoria de control</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ninguna de las anteriores es cierta.</label></li>
</ul>
</li>
<li>
<p>Un procesador está segmentado en las etapas F, D, E, M y W. Cada una de  ellas consume un tiempo t. La aceleración ideal (si no hay riesgos) al ejecutar n instrucciones respecto a un procesador no segmentado será:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 5n/(4+n)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (4+n)/5t</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4n/(5+n)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (5+n)/4t</label></li>
</ul>
</li>
<li>
<p>En un procesador con segmentación de cauce, aumentar el número de etapas (p.ej. de 2 a 4, o de 4 a 8), tiene en general como consecuencia:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un Incremendo De Las Prestaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un mayor retraso en la ejecución de los programas debido al incremento del número de etapas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución en la posible dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución de la máxima frecuencia de reloj a la que puede operar el cauce.</label></li>
</ul>
</li>
<li>
<p>En la secuencia de instrucciones siguiente, siendo el primer registro el destino, ¿cuántos riesgos se dan?<br>
<code>sub r2,r1,r3<br>or r8,r6,r2</code><br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un riesgo estructural.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un riesgo por dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un Riesgo Estructural Dos Por dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos riesgos por dependencia de datos y uno de control.</label></li>
</ul>
</li>
<li>
<p>La precaptación (cola de instrucciones) está relacionada con...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Los riesgos estructurales (intenta evitar el efecto de un fallo de cache)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de (dependencia de) datos (intenta que el dato esté disponible anticipadamente)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos control (intenta determinar de antemano el flujo de control)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de transferencia (intenta agrupar las posibles transferencias de un conjunto de instrucciones).</label></li>
</ul>
</li>
<li>
<p>Respecto a la segmentación, ¿cuál de las siguientes afirmaciones es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La técnica de register forwarding habilita una serie de cambios(buses) que se añaden al cauce para permitir que los resultados de una etapa pasen como entradas a la etapa donde son necesarias.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La reorganizacion del código y la introducción de instrucciones no permite evitar dependencias de datos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retrasar la fase de decisión saltar/no saltar de las instrucciones de salto condicional contribuye a mejorar el rendimiento del procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantas más etapas tenga un cauce, más instrucciones se estarán ejecutando en distintas fases y más posibilidades se presentan de que existan riesgos entre ellas.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes modos de direccionamento es menos preferible para un procesador de 32 bits y con tamaño de instrucción de 32 bits?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> registro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indexado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indirecto a través de registro.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> directo (o absoluto)</label></li>
</ul>
</li>
<li>
<p>La conexión entre un dispositivo de E/S y el procesador mediante bus:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es difícil de expandir.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Permite conectar en paralelo varios dispositivos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere mucha circuitería.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere multiplexores y demultiplexores para las señales de datos.</label></li>
</ul>
</li>
<li>
<p>El fragmento de código ensamblador de un microprocesador de 8 bits:<br><code>lds IOBuf  ; Apuntar puntero pila a ...área mem.intermedia<br>ldx Count    ; Inicializar x-contador<br>poll lda a Status; Leer estado en A<br>bpl poll ; Signo (A) != 1 =&gt; repetir<br>lda a Data   ; Leer dato en A<br>psh a       ; transferir dato a pila<br>dex         ; decrementar contador x<br>bne poll    ; Seguir leyendo si x!=0<br></code><br> Corresponde a:<br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Entrada programada con consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada sin consulta de estado. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Entrada programada sin consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada con consulta de estado.</label></li>
</ul>
</li>
<li>
<p>En la E/S controlada por interrupciones:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Entrada programada con consulta de estado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada sin consulta de estado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Entrada programada sin consulta de estado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada con consulta de estado</label></li>
</ul>
</li>
<li>
<p>La instrucción máquina DI (Disable Interrupts), conocida como CLI (Clear Interrupt Flag) en x86, se utiliza para desactivar:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Todas Las Interrupciones Enmascarables</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las interrupciones de inferior o igual prioridad a una dada</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Determinados niveles de interrupción de forma selectiva</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las interrupciones software</label></li>
</ul>
</li>
<li>
<p>Con nueve controladores de interrupciones 8259 se pueden manejar
exactamente:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 8 niveles de prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 niveles de prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 24 niveles de prioridad</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las anteriores es cierta</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes es un registro de un controlador de DMA?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>IR</code> (Instruction Register)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>PC</code> (Program Counter)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>SP</code> (StackPointer)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>WC</code> (Word Count)</label></li>
</ul>
</li>
<li>
<p>Respecto al refresco de memorias DRAM, ¿cuál de las siguientes afirmaciones es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Una operación de refresco consiste en dar un impulso /CAS junto con una dirección de columna.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los chips DRAM refrescan automáticamente la fila accedida en cualquier ciclo de lectura o escritura.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se precisa una circuitería auxiliar, externa al chip DRAM o integrada en él, que produzca ciclos de refresco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los ciclos de refresco deben producirse cada pocos ms (milisegundos).</label></li>
</ul>
</li>
<li>
<p>La tasa de aciertos \(A_i\) del nivel i de una jerarquía de memoria no depende de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La capacidad (tamaño) ni del nivel i.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La estrategia de administración de memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La unidad de la transferencia de información \(x_i\) entre el nivel i y el  \(i+1\).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El ancho de banda  \(b_i\) del nivel i.</label></li>
</ul>
</li>
<li>
<p>La política de correspondencia de una memoria cache con 1 único conjunto es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Directa</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Totalmente asociativa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asociativa por conjuntos con una única línea</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asociativa por conjuntos de una única vía</label></li>
</ul>
</li>
<li>
<p>La política de correspondencia de una memoria cache con la mitad de conjuntos que líneas es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Asociativa por conjuntos de 2 vías</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Totalmente asociativa de media vía</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asociativa por conjuntos con 2 líneas</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Directa con 2 líneas</label></li>
</ul>
</li>
<li>
<p>Para construir una DRAM de 4GB con pastillas de 512Mx4bit hacen falta</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 8 pastillas</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 16 pastillas</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32 pastillas</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 pastillas</label></li>
</ul>
</li>
<li>
<p>Para diseñar una memoria con ancho de palabra  \(k\times m\) (y mismo no palabras que los módulos) a partir de módulos con ancho de palabra m, se utilizan k módulos</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> repartiendo las líneas de datos entre los k módulos: el primero se conecta a D0...Dk-1, el segundo a Dk...D2k-1, etc</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> repartiendo las líneas de dirección: el 1o se conecta a A0...Ak-1, el 2o a Ak...A2k-1, etc</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> repartiendo líneas datos:el 1o se conecta a D0...Dm-1, el 2o a Dm...D2m-1, etc</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> repartiendo líneas dirección: el 1o se conecta a A0...Am-1, el 2o a Am...A2m-1, etc</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre el benchmark SPEC CPU es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La última versión es SPEC CPU2006 V1.2 de 2011.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se cronometran unos 12 tests de enteros (CINT2006) y unos 17 tests de punto flotante (CFP2006).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se usa como referencia un computador UltraSPARC II 300MHz, y para cada test se calcula el cociente entre el tiempo de ejecución en el computador a testear y en el de referencia.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El resultado final es la media aritmética de las (12 ó 17) velocidades, bien sea de enteros ó de punto flotante (SPECint2006 ó SPECfp2006).</label></li>
</ul>
</li>
<li>
<p>¿En qué generación, dentro de la historia de los computadores digitales, aparecieron la microprogramación, la segmentación de cauce, la memoria cache, los S.O. multiusuario y la memoria virtual?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 2a generación (1955-65).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 3a generación (1965-75).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4a generación (1975-85).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Esas innovaciones se repartieron a lo largo de varias generaciones, no sólo una.</label></li>
</ul>
</li>
<li>
<p>Respecto a tamaños de tipos integrales en x86 y x86-64, la excepción es que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>int</code> pasa de 4 B (x86) a 8 B (x86-64).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>long int</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>long long</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>Con el repertorio x86-64, para sumar <code>%eax</code> y <code>%ebx</code> dejando el resultado en <code>%ecx</code> se podría hacer lo siguiente:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %eax, %ebx, %ecx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>lea (%eax, %ebx, 1), %ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %ecx, [%eax, %ebx]</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %ecx, %ebx, %eax</code></label></li>
</ul>
</li>
<li>
<p>Cuál de las instrucciones máquina siguientes es incorrecta en x86-64:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>testl %edx, %edx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>movl %r8, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (%rdi, %rcx, 4), %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>addq $1, %rcx</code></label></li>
</ul>
</li>
<li>
<p>Si la variable <code>val</code> está almacenada en <code>ebx</code> y la variable <code>x</code> está almacenada en <code>eax</code>, la sentencia <code>val ^= x;</code> se puede traducir a ensamblador como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>xorl %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>xorl %eax, %ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>andl %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>testl %eax, %ebx</code></label></li>
</ul>
</li>
<li>
<p>Para poner a 1 el bit 5 del registro <code>%edx</code> sin cambiar el resto de bits podemos usar la instrucción máquina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>and $32, %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>and $0x5, %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>or $0b101, %edx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>or $0x20, %edx</code></label></li>
</ul>
</li>
<li>
<p>Si tenemos un número <code>n</code>, de 64 bits, almacenado en la pareja de registros <code>EDX:EAX</code> (<code>EDX</code> contiene los 32 bits más significativos y <code>EAX</code> los 32 bits menos significativos) y queremos realizar la división \(n/2^{32}\) entonces:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos quedarnos con <code>EDX</code>, pero sólo en el caso de que <code>n</code> sea un número sin signo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Podemos quedarnos con <code>EDX</code> tanto si <code>n</code> es un número con signo como sin signo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos usar las instrucciones siguientes, pero sólo en el caso de que <code>n</code> sea un número con signo: <br><code>mov $0x100000000, %ecx<br>div %ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos usar las instrucciones siguientes, tanto si <code>n</code> es un número con signo como sin signo: <br><code>mov $0x100000000, %ecx<br>div %ecx</code></label></li>
</ul>
</li>
<li>
<p>¿Dónde está ubicado el séptimo argumento a una función (suponer código ensamblador generado por gcc para x86-64) inmediatamente después de ejecutar la instrucción <code>call</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%rbp + 0x8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%rbp - 0x8</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>%rsp + 0x8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%rsp - 0x8</code></label></li>
</ul>
</li>
<li>
<p>Dado el código C siguiente:<br><code>struct data {<br> char str[16];<br>};<br>char <em>f(struct data </em>ptr) {<br> return &amp;(ptr-&gt;str[2]);<br>}</code><br>La función se traducirá a ensamblador de x86-64 como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>leaq 2(%rdi), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movq (,%rdi,2), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movq 2(%rdi), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leaq (,%rdi,2), %rax</code> <br><code>ret</code></label></li>
</ul>
</li>
<li>
<p>Respecto a requisitos de alineamiento de structs en gcc/IA32 x86 y x86-64, alguna de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> En x86 Linux alinea <code>double</code> a 4x (Windows no).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86 Linux alinea <code>long double</code> a 4x (Windows también).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86-64 Linux alinea <code>double</code> a 8x (Windows también).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86-64 Linux alinea <code>float</code> a 8x (Windows también).</label></li>
</ul>
</li>
<li>
<p>Si la estructura struct <code>a</code> ocupa un espacio de 28 bytes en memoria, ¿cuántos bytes ocupa la siguiente estructura struct <code>b</code> cuando se compila en 64 bits? <br><code>struct b {<br> struct a a1;<br> int i;<br> struct a a2;<br>};</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 24 bytes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 60 bytes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 bytes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 84 bytes.</label></li>
</ul>
</li>
<li>
<p>Respecto a los términos microinstrucción y microcódigo:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Son equivalentes, llamamos microcódigo o microinstrucción a una palabra de la memoria de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una microinstrucción está programada en microcódigo, que es un lenguaje para programar señales de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un microcódigo controla una serie de señales de control relacionadas (por ejemplo, el código <code>000</code> para que la ALU realice la suma), y varios microcódigos juntos forman una microinstrucción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Microcódigo es el contenido de la memoria de control, y una microinstrucción es una palabra de dicha memoria.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es verdadera?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La unidad de control necesita como entrada el registro de estado para poder controlar la ejecución de las instrucciones de salto condicional.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro de instrucción es un registro de propósito específico que contiene la dirección de la siguiente instrucción a ejecutar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las únicas instrucciones en las que algunas de sus fases de ejecución conllevan un acceso a memoria son las instrucciones load y store.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro puntero de pila es un registro de propósito general que suele contener tanto direcciones como datos.</label></li>
</ul>
</li>
<li>
<p>Un procesador con una unidad de control microprogramada tiene una memoria de control de 300 palabras de 100 bits, de las que 200 son diferentes. Si se rediseñara como unidad de control nanoprogramada, ¿qué tamaño ocuparía la nanomemoria que contiene las microinstrucciones completas sin repeticiones?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 20000 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 21600 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 22400 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 30000 bits.</label></li>
</ul>
</li>
<li>
<p>En el pseudocódigo usado para representar las microinstrucciones, la expresión <code>goto f(IR)</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se utiliza para realizar un microsalto condicional en función del registro de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Realiza una llamada a una microsubrutina.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Salta a una dirección de memoria de control que depende de la instrucción máquina actual.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite saltar a la dirección de memoria de control del principio de un microbucle.</label></li>
</ul>
</li>
<li>
<p>Respecto a la predicción de saltos, alguna de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Si se toma la misma decisión para cada tipo de instrucción, se trata de "predicción estática".</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si la predicción cambia según la historia de ejecución del programa, se trata de "predicción dinámica".</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Para predicción estática, es conveniente decidir que los saltos hacia adelante siempre se cumplen, y hacia atrás no.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Para predicción dinámica, existen, entre otros, algoritmos de dos o cuatro estados, que requieren 1 o 2 bits por instrucción.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de procesamiento segmentado y superescalar, una de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Idealmente, con el segmentado se intenta ejecutar una instrucción por ciclo, y con el superescalar más de una por ciclo (al combinarlo con segmentado).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En cualquier procesador resulta ventajoso usar una cola de instrucciones, pero es más importante para uno segmentado (fundamental) que para uno superescalar (conveniente).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Por definición, un procesador superescalar debe tener varias unidades funcionales (más de una).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Implícitamente, se presupone que un procesador superescalar emitirá más de una instrucción por ciclo.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de interfaz de dispositivo, controlador(a), puerto de E/S:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La controladora o interfaz contiene los puertos necesarios para utilizar el dispositivo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada puerto o interfaz es una línea de comunicación con el procesador. El conjunto de ellos forma el controlador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El puerto, o interfaz, contiene los controladores necesarios para comunicar el dispositivo con el procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El interfaz contiene las controladoras necesarias para conectar los puertos con el procesador.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de procesador de E/S, canal de E/S, dispositivos de E/S:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un procesador o canal tiene un repertorio de instrucciones específico para manejar los dispositivos de E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada canal es una línea de comunicación entre el procesador y un dispositivo de E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Al conjunto de conexiones entre el procesador y los dispositivos se le denomina canal de E/S (de ese ordenador).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La pregunta es capciosa, el procesador no es E/S, son otros dos componentes von Neumann distintos (ALU+UC).</label></li>
</ul>
</li>
<li>
<p>La E/S programada:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Mejora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU tiene el control de toda la operación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Mejora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU es más rápida que el controlador de interrupciones y la interfaz del periférico.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Empeora las prestaciones globales del sistema respecto a la E/S por interrupciones porque una .instrucción de transferencia individual de datos con la interfaz del periférico (por ej. IN, OUT) es más lenta en E/S programada que en E/S por interrupciones.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Empeora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU debe encargarse de la sincronización con la interfaz del periférico haciendo una espera activa.</label></li>
</ul>
</li>
<li>
<p>Una puerta <code>AND</code> con 16 entradas conectada a un bus de direcciones de 16 bits, con todos los bits negados excepto <code>A10</code> y <code>A6</code>, permite seleccionar un dispositivo (con <code>CS</code> activa en alta) en la dirección:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xFDDF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xFBBF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x0220</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x0440</code></label></li>
</ul>
</li>
<li>
<p>Un computador con 15 líneas de direcciones tiene 3 módulos de memoria de \(2^{13}\) palabras y utiliza E/S mapeada en memoria. ¿Cuál es el número máximo de periféricos que pueden conectarse, si cada uno de ellos utiliza 8 direcciones?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> \(2^{10}\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{12}\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{11}\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{13}\).</label></li>
</ul>
</li>
<li>
<p>Un procesador accede en el instante de tiempo <code>t</code> a una posición de memoria <code>d(t)</code>. Poco tiempo después (en el instante de tiempo <code>t+k</code>) accede a la posición anterior <code>d(t)-1</code>. Esos dos accesos son un ejemplo de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Localidad espacial.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Localidad temporal.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No tiene nombre, ese tipo de localidad con incremento negativo (<code>d(t)-1</code>) no se ha estudiado en clase.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es una localidad, esa condición no guarda relación con el concepto de localidad.</label></li>
</ul>
</li>
<li>
<p>Una jerarquía de memoria consta de una cache de con una tasa de aciertos del 92% y 4 ns de tiempo de acceso y una memoria principal con una tasa de aciertos del 100% y 100 ns de tiempo de acceso. ¿Cuál es el tiempo promedio estimado de acceso a memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 6 ns.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8 ns.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 10 ns.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 12 ns.</label></li>
</ul>
</li>
<li>
<p>Una SRAM de <code>1Mx4bit</code> (4Mbit) puede venir organizada en 2048 filas, dedicando por tanto al decodificador de columnas:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 6 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 7 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 9 bits.</label></li>
</ul>
</li>
<li>
<p>Un sistema basado en un microprocesador con un bus de datos de <code>n</code> bits y un bus de direcciones de 16 bits direcciona la memoria por palabras de <code>n</code> bits y dispone de una memoria SRAM formada por dos módulos de <code>16 K x n</code> cada uno. ¿Qué porcentaje del mapa de memoria está ocupado por la SRAM?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 12.5%</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 25%</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 50%</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 100%</label></li>
</ul>
</li>
<li>
<p>Un módulo de memoria de 16 GB está formado por varios chips DRAM de <code>1024Mx4</code>. ¿Cuántos chips DRAM necesita el módulo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 32.</label></li>
</ul>
</li>
<li>
<p>Una cache de 256 B asociativa por conjuntos de 4-vías con líneas de 16 B tendría:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 4 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ningún conjunto.</label></li>
</ul>
</li>
<li>
<p>En un sistema con memoria de bytes, ¿cuál sería el tamaño de una línea de cache, si la cache del procesador fuera de 4MB, asociativa por conjuntos de 16-vías, y contuviera 4096 conjuntos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32 B.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 64 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 128 B.</label></li>
</ul>
</li>
<li>
<p>El conjunto de todos los atributos de un sistema que son visibles para el programador y son necesarios para programar en lenguaje máquina se denomina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Arquitectura del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Conjunto de componentes físicos del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Organización del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Repertorio de instrucciones máquina.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es cierta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La arquitectura Von Neumann de los computadores tradicionales consiste en tener almacenados los datos separados de las instrucciones en memorias distintas.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El registro de estado (flags) es un registro de propósito específico cuyo contenido puede ser visto directa o indirectamente por el usuario mediante el uso de ciertas instrucciones específicas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La unidad de control necesita como entrada el registro contador de programa para saber cuál es la instrucción que debe ejecutar a continuación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro de direcciones de memoria es un registro de propósito general que puede contener tanto direcciones como datos.</label></li>
</ul>
</li>
<li>
<p>En una máquina little-endian con memoria de bytes y representación en complemento a dos que permite accesos a memoria de tamaño byte (1 B), media palabra (2 B) y palabra (4 B), se almacenan a partir de la posición <code>0xCAFEBAB0</code> cuatro palabras con valores -1, -2, -3, -4. ¿Qué se obtendría al consultar la media palabra de la posición <code>0xCAFEBABE</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> -1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> -4.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede saber, faltan datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>Se pretende almacenar una palabra de 4 B en una memoria de bytes a partir de una dirección determinada. ¿Cuál de las siguientes es válida, si la palabra debe quedar alineada?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xFACEB00C</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xDEADBEEF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xCAFEBABE</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xABADF00D</code></label></li>
</ul>
</li>
<li>
<p>En una arquitectura de acumulador, la instrucción <code>LOAD X</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Transfiere el contenido del registro <code>X</code> a la memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Suma <code>M(x)</code> al acumulador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Transfiere el contenido del acumulador a la posición de memoria <code>X</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Transfiere el contenido de la posición de memoria <code>X</code> al acumulador.</label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina del tipo <code>Add M,R</code> podría formar parte del repertorio de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina de acumulador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina con arquitectura R/R.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una máquina con arquitectura M/M.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes no es un modo de direccionamiento IA-32?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Registro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cache.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inmediato.</label></li>
</ul>
</li>
<li>
<p>Un bus se compone de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de datos y líneas de dirección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de alimentación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de estado y líneas de control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Líneas de control/estado, líneas de dirección y líneas de datos.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes no es un tipo de bus?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Secuencial.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Paralelo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sistema.</label></li>
</ul>
</li>
<li>
<p>Si en un bus de direcciones de 32 bits se decodifica parcialmente la dirección de un dispositivo de 32 posiciones usando 22 bits, ¿cuántas veces aparecerá repetido en el mapa de memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 10.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 32.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1024.</label></li>
</ul>
</li>
<li>
<p>Para obtener una única velocidad comparativa final, el benchmark SPEC CPU combina las velocidades de ejecución de una serie de tests, respecto a un ordenador de referencia, usando la media:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Aritmética.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Geométrica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Armónica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ponderada.</label></li>
</ul>
</li>
<li>
<p>El primer computador electrónico basaba su funcionamiento en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Tubos de vacío.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Circuitos integrados LSI.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Amplificadores operacionales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Núcleos de ferrita.</label></li>
</ul>
</li>
<li>
<p>En Linux IA-32, si gcc usa la instrucción <code>leave</code> se puede asegurar que en ese punto del programa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Correspondería emitir la secuencia de salida <code>pop/ret</code>, pero <code>leave</code> hace lo mismo y ocupa menos espacio</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ya no hay registros salva-invocado que recuperar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ya no hay variables locales que destruir.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ya no se hacen llamadas anidadas y por tanto no hay parámetros que ocupen espacio en pila.</label></li>
</ul>
</li>
<li>
<p>Usando el repertorio IA-32, para intercambiar el valor de 2 variables (por ejemplo <code>A: .int 1</code> y <code>B: .int 2</code>) se pueden usar:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Dos instrucciones <code>mov</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una instrucción <code>mov</code> y una instrucción <code>lea</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 3 <code>mov</code>, no menos (se le llama "intercambio circular").</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 4 <code>mov</code>, no menos (debido a la arquitectura R/M).</label></li>
</ul>
</li>
<li>
<p>Respecto a registros base e índice en IA-32, la excepción es que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>RBP</code> no puede ser registro base.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>RBP</code> no puede ser registro índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>RSP</code> no puede ser registro base.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>RSP</code> no puede ser registro índice.</label></li>
</ul>
</li>
<li>
<p>El registro <code>SP / ESP / RSP</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro transparente al usuario y contiene la instrucción que se está ejecutando.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es un registro de propósito específico y contiene la dirección de la cima de la pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro transparente al usuario y contiene la dirección de memoria a la que se está accediendo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro de propósito específico y contiene la dirección de la siguiente instrucción a ejecutar.</label></li>
</ul>
</li>
<li>
<p>Diferencias gcc Linux IA-32/x86-64: marcar la respuesta falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los enteros largos (<code>long</code>) pasan de 32 a 64 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los punteros (<code>void*</code>) pasan de 32 a 64 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El tipo <code>double</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>long double</code> pasa de 10/12 B a 16 B.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes fragmentos de código deja en <code>%eax</code> un resultado distinto a los otros tres fragmentos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov $-1, %edx</code><br><code>sub %eax, %edx</code><br><code>mov %edx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>not %eax</code><br><code>add $1, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>xor %edx, %edx</code><br><code>sub %eax, %edx</code><br><code>mov %edx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>neg %eax</code></label></li>
</ul>
</li>
<li>
<p>Si <code>A</code> y <code>B</code> son dos enteros almacenados respectivamente en <code>%eax</code> y <code>%ebx</code>, ¿cuál de las siguientes implementaciones de:<br><code>if(!A &amp;&amp; !B){... then part ...}</code> es incorrecta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>or %ebx, %eax</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true:</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>cmp $0, %eax</code><br><code>jne not_true</code><br><code>cmp $0, %ebx</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>test %ebx, %eax</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>test %eax, %eax</code><br><code>jne not_true</code><br><code>test %ebx, %ebx</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
</ul>
</li>
<li>
<p>Dada la siguiente declaración en lenguaje C, una estructura de este tipo podría ocupar en un sistema Linux IA-32 o bien en uno x86- 64 un total de:<br><code>struct a {<br> int i;<br> double d;<br> char c;<br> short s;<br>};</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 18 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 20 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 22 B.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 24 B.</label></li>
</ul>
</li>
<li>
<p>En un sistema Linux x86-64, ¿cuál de las siguientes expresiones es equivalente a la expresión C <code>(x[2] + 4)[3]</code>? Suponer que previamente se ha declarado <code>int **x</code>.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>*((*(x + 16)) + 28)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>*(((*x) + 2) + 7)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>(*(*(x + 2) + 4) + 3)</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>*((*(x + 2) + 4) + 3)</code></label></li>
</ul>
</li>
<li>
<p>Una unidad de control microprogramada se denomina "con secuenciamiento de microinstrucciones explícito" según tenga o no tenga:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> ROM/PLA para traducir el codop en dirección de inicio de microprograma (<code>goto f(IR)</code>).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un multiplexor para seleccionar la fuente de la dirección de la memoria de control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un micro-contador de programa atacando a las líneas de dirección de la memoria de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Microcódigo de decodificación que analice el codop bit a bit de izquierda a derecha.</label></li>
</ul>
</li>
<li>
<p>Dado un camino de datos concreto, un posible formato de microprogramación se caracteriza como horizontal o vertical según tenga más o menos (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Codificación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solapamiento.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Microbifurcaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Longitud relativa de microinstrucción.</label></li>
</ul>
</li>
<li>
<p>Motivos que impiden que la ganancia (aceleración) de un cauce
    segmentado sea ideal (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Registros de acoplo (coste de la segmentación).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fragmentación desigual (duración desigual de etapas).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Riegos (hazards)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cola de instrucciones (precaptación).</label></li>
</ul>
</li>
<li>
<p>La técnica de "adelanto de registros" (register forwarding) en un cauce segmentado se usa para limitar el impacto de los riesgos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Estructurales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Organizativos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> De control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> (Por dependencias) de datos.</label></li>
</ul>
</li>
<li>
<p>Las técnicas principales de E/S son (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> DMA (por acceso directo).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S programada.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> E/S cableada (hardwired).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> IRQ (por interrupciones).</label></li>
</ul>
</li>
<li>
<p>Para determinar la causa de una interrupción se pueden usar las siguientes técnicas: (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Múltiples líneas de interrupción: <code>INT1#, INT2#, ...</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Línea de reconocimiento <code>INTA#</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Consulta de estado, o polling.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Interreupciones vectorizadas.</label></li>
</ul>
</li>
<li>
<p>Utilizar una cache en el mismo chip del procesador:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Aumenta el tamaño de los bloques enviados entre cache y procesador.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Reduce los tiempos de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reduce el tamaño del bus.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Aumenta la tasa de aciertos.</label></li>
</ul>
</li>
<li>
<p>En un sistema Linux IA-32, ¿cuántos enteros se podrían almacenar en una línea de cache, si la cache del procesador fuera de 4 KB, asociativa por conjuntos de 4-vías, y contuviera 4 conjuntos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 64.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 128.</label></li>
</ul>
</li>
<li>
<p>La cache con correspondencia directa se puede considerar como un caso límite de la asociativa por conjuntos, en donde:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Sólo hay 1 línea por conjunto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo hay 1 palabra por bloque.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo hay 1 conjunto por cache.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>Si almacenamos según el criterio little-endian la palabra de 32 bits <code>0xFACEB00C</code> a partir de la dirección <code>0xCAFEBABE</code>, el byte <code>0xCE</code> quedará almacenado en la dirección:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xCAFEBAC1</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xCAFEBAC0</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xCAFEBABF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xCAFEBABE</code></label></li>
</ul>
</li>
<li>
<p>¿Qué novedad se desarrolló en la tercera generación de computadores?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Los circuitos integrados.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los primeros lenguajes de programación de alto nivel.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los microprocesadores CISC.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los microprocesadores RISC.</label></li>
</ul>
</li>
<li>
<p>En x86-64, el registro contrador de programa se denomina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>RIP</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EIP</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>IP</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>R15</code></label></li>
</ul>
</li>
<li>
<p>La primera letra (<code>l</code>) de la instruccion <code>lea</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Indica que la instrucción usa ordenación de bytes little-endian.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Indica que la instrucción trabaja con un operando destino de 32 bits (<code>long word</code>).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Indica indica que la instrucción afecta a los 16 bits menos significativos del operando destino (<code>long word</code>).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Forma parte del nemotécnico de la instrucción.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la diferencia entre las instrucciones <code>mov</code> y <code>lea</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea</code> accede a la posición indicada, mientras que <code>mov</code> no lo hace.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov</code> accede a la posición indicada, mientras que <code>lea</code> no lo hace.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea</code> puede usarse para copiar un registro a otro, mientras que <code>mov</code> no.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>mov</code> puede usarse para copiar un registro a otro, mientras que <code>lea</code> no.</label></li>
</ul>
</li>
<li>
<p>La instrucción <code>not</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Realiza el complemento a dos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Realiza el complemento a uno (cambiar unos por ceros y ceros por unos).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Realiza la operación <code>no-or</code> (or negada).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Realiza un salto condicional si negativo.</label></li>
</ul>
</li>
<li>
<p>La instrucción <code>JGE / JNL</code> provoca un salto si:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>SF = 1</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>CF = 1</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>SF = 0</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>OF = SF</code></label></li>
</ul>
</li>
<li>
<p>Un overflow nunca puede ocurrir cuando:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se suman dos números positivos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se suman dos números negativos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se suma un número positivo a un número negativo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se resta un número positivo de un número negativo.</label></li>
</ul>
</li>
<li>
<p>Después de ejecutar una instrucción de suma sobre dos números con signo de la que sabemos que no provocará overflow (los dos números son pequeños en valor absoluto), queremos comprobar si el resultado de la suma es menor que 0. ¿Qué flag necesita comprobar la instrucción de salto condicional equivalente a <code>if (resultado&lt;0) then goto label</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>CF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>OF</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>SF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ZF</code></label></li>
</ul>
</li>
<li>
<p>La instrucción <code>cmovb %edx, %eax</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Copia en <code>%eax</code> el contenido de <code>%edx</code> si el indicador de acarreo es 1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Copia el byte bajo de <code>%edx</code> en el byte bajo de <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Copia en <code>%eax</code> el byte de memoria apuntado por la dirección contenida en <code>%edx</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Copia en <code>%eax</code> el contenido de <code>%edx</code> si <code>%eax</code> es menor que <code>%edx</code>.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre la instrucción <code>leave</code> es cierta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se ejecuta justo después de retornar de un procedimiento.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Equivale a <code>pop %rbp</code> seguida de <code>mov %rbp, %rsp</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Equivale a <code>mov %rsp, %rbp</code> seguida de <code>pop %rbp</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> No es obligatorio usarla. En su lugar puede realizarse una secuencia explícita de operaciones <code>mov</code> y <code>pop</code>.</label></li>
</ul>
</li>
<li>
<p>Para crear espacio en la pila para variables locales sin inicializar suele realizarse la siguiente operación:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Restar una cantidad positiva a <code>EBP</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sumar una cantidad positiva a <code>EBP</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Restar una cantidad positiva a <code>ESP</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sumar una cantidad positiva a <code>ESP</code>.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes lenguajes no permite el paso de parámetros por referencia?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Pascal.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> C.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> C++.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> FORTRAN.</label></li>
</ul>
</li>
<li>
<p>En la secuencia de programa siguiente:<br><code>804854e:e8 3d 06 00 00 call 8048b90 (main)<br>8048553:50 pushl %eax</code><br>¿Cuál es el valor que introduce en la pila la instrucción call?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>804854e</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>804854f</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>8048b90</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>8048553</code></label></li>
</ul>
</li>
<li>
<p>En el fragmento de código:<br><code>804854e:e8 3d 06 00 00 call 8048b90 (main)<br>8048553:50 pushl %eax</code><br>La instrucción <code>call</code> suma al contador de programa la cantidad:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0000063d</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>08048553</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0804854e</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>50</code></label></li>
</ul>
</li>
<li>
<p>Es responsabilidad del procedimiento llamado salvaguardar los registros:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>%ebx, %esi, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%eax, %edx, %ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%eax, %ebx, %ecx, %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%esi, %edi</code></label></li>
</ul>
</li>
<li>
<p>Al llamar a una función de 2 argumentos <code>foo(arg1, arg2)</code>, ¿cuál es el orden correcto en el que se ejecutan las instrucciones? (suponiendo convención de llamada x86 cdecl, y que <code>foo</code> requiere ajustar marco de pila, esto es, salvar <code>%ebp</code>).</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>push arg1, push arg2, call foo, push %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>push arg1, push arg2, push %ebp, call foo</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>push arg2, push arg1, call foo, push %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>push arg2, push arg1, push %ebp, call foo</code></label></li>
</ul>
</li>
<li>
<p>Cuando se ejecuta la instrucción <code>ret</code> al final de una subrutina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La dirección de comienzo de la pila se transfiere al puntero de pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La dirección de memoria de la instrucción <code>ret</code> se transfiere al contador de programa.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La dirección almacenada en la cima de la pila se transfiere al contador de programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La direción almacenada en la cima de la pila se transfiere al puntero de pila.</label></li>
</ul>
</li>
<li>
<p>En IA-32 la pila es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro de 16 bits en el microprocesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro de 32 bits en el microprocesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una dirección de memoria de 32 bits almaenada en el contador de programa.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un conjunto de posiciones de memoria usadas para almacenar información temporal durante la ejecución del programa.</label></li>
</ul>
</li>
<li>
<p>En IA-32 el puntero de pila es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro de 16 bits en el microprocesador.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un registro de 32 bits en el microprocesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una dirección de memoria de 32 bits almacenada en el contador de programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un conjunto de posiciones de memoria usadas para almacenar información temporal durante la ejecución del programa.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones <em>NO</em> es cierta? (entender que x86=IA-32)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> x86-64 proporciona un espacio de memoria virtual mayor que x68.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las disciplinas pilas para x86 y x86-64 son diferentes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> x86 usa <code>%ebp</code> como puntero base para el marco de pila.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> x86-64 usa <code>%rbp</code> como puntero base para el marco de pila.</label></li>
</ul>
</li>
<li>
<p>Alguna de las siguientes <em>NO</em> es una operación básica de la unidad de control:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Transferir un registro a otro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (Leer/escribir) un registro (de/a) memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> (Guardar/recuperar) registro (en/de) la pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Realizar una operación de la ALU y guardar el resultado en un registro.</label></li>
</ul>
</li>
<li>
<p>Un computador tiene una memoria de control de 16000 palabras de 250 bits, de las que 447 son diferentes. ¿Cuántos bits ahorramos usando nanoprogramación en lugar de microprogramación?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 3744250</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 259206</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 287935</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguno de los resultados anteriores es exacto.</label></li>
</ul>
</li>
<li>
<p>Un sistema no segmentado tarda 20 ns en procesar una tarea. La misma tarea puede ser procesada en un cauce (pipeline) de 4 segmentos con un ciclo de reloj de 5 ns. Cuando se procesan muchas tareas, la ganancia máxima de velocidad que se obtiene se aproxima a:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 5.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 4.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0.25.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 20.</label></li>
</ul>
</li>
<li>
<p>En la técnica de salto retardado:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El compilador puede reorganizar el código para rellenar los huecos de retardo con instrucciones útiles.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El compilador no puede insertar operaciones <code>NOP</code> en los huecos de retardo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El slto se realiza varios ciclos antes de la instrucción de salto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las instrucciones en los huecos de retardo se ejecutan unas veces y otras no.</label></li>
</ul>
</li>
<li>
<p>Al método de interacción con los periféricos, en los que el procesador vigila periódicamente el estado de los dispositivos mediante una encuesta activa se le denomina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> daisy-chain.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> interrupción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> polling.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> DMA.</label></li>
</ul>
</li>
<li>
<p>¿Cuántas señales de control se necesitan como mínimo para implementar un sistema de gestión de interrupciones?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 1.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 3.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4.</label></li>
</ul>
</li>
<li>
<p>Se dispone de un procesador con una frecuencia de reloj de 1 GHz. Se le conecta un dispositivo que genera 100.000 interrupciones por segundo. La rutina de servicio de interrupción ejecuta 500 instrucciones. El número medio de ciclos por instrucción es 2. ¿Qué porcentaje del tiempo dedica el procesador al dispositivo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 1%.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 10%.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 50%.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 90%.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones acerca de las memorias es <em>FALSA</em>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La memoria dinámica usa señales de control <code>RAS#</code> y <code>CAS#</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las celdas de memoria dinámica están constituidas por un transistor y un condensador.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las celdas de memoria estática tienen que ser constantemente refrescadas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La memoria estática se emplea en las cachés L1 y L2.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones acerca de la jerarquía de memoria es <em>FALSA</em>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Acceder a los discos es órdenes de magnitud más lento que acceder a la RAM.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una memoria principal constituida por la tecnología más rápida es órdenes de magnitud más cara que la DRAM.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La velocidad de acceso Lamemoria principal ha crecido proporcionalmente a la velocidad del procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un computador puede tener una pequeña cantidad de memoria rápida además de una gran cantidad de memoria más lenta.</label></li>
</ul>
</li>
<li>
<p>En una máquina little-endian con memoria de bytes y representación en complemento a dos que permite accesos a memoria de tamaño byte (1B), media palabra (2B) y palabra (4B), si se almacena en la posición <code>0xBABC</code> una palabra de valor -2, ¿qué se obtendría al consultar la media palabra en la posición <code>0xBABE</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 0.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> -1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 2.</label></li>
</ul>
</li>
<li>
<p>Según la clasificación <code>m/n</code>, las máquinas de acumulador son de tipo:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0/0</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>1/1</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>1/2</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>2/2</code> ó <code>2/3</code>.</label></li>
</ul>
</li>
<li>
<p>Según la clasificación <code>m/n</code> las máquinas con arquitectura <code>R/R</code> son de tipo:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0/0</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0/x</code> con <code>x=2,3</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>x/0</code> con <code>x=2,3</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>x/x</code> con <code>x=2,3</code>.</label></li>
</ul>
</li>
<li>
<p>El bus del sistema es </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> el que conecta las distintas partes del sistema:UC,ALU,E/S,M</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> en un sistema con bus único, todo el bus salvo la parte relacionada con E/S (SATA, GPU, USB, Ethernet, etc) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> en un sistema con buses separados,el que conecta el sistema E/S con el resto </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> el que conecta CPU-M, ya sea un sistema con bus único o con múltiples buses </label></li>
</ul>
</li>
<li>
<p>Un sistema con direcciones de 8 bits utiliza una puerta NAND conectada a las líneas A7...A5 para atacar la entrada <code>CS#</code> (activa baja) de un módulo de memoria. En el mapa de memoria las siguientes posiciones corresponderán a dicho módulo </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 0x00 a 0x0f y 0x80 a 0x8f </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0x00a0x1f </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0x70 a 0x7f y 0xf0 a 0xff </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 0xe0a0xff </label></li>
</ul>
</li>
<li>
<p>La ecuación básica de rendimiento calcula </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> cuánto tiempo tarda en ejecutarse un programa concreto conociendo su número de instrucciones y el número de etapas (promedio) y la frecuencia del procesado </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> cómo de mejor es un procesador frente a otro, conociendo las prestaciones de las respectivas UC, ALU, E/S y M </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> el promedio de las ganancias obtenidas con una serie de programas de punto entero </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> la media geométrica de los cocientes entre los tiempos de ejecución de una serie de programas predeterminados </label></li>
</ul>
</li>
<li>
<p>Por x86-64 se entiende la misma arquitectura de repertorio (ISA) que  </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> x86 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> IA-32 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> IA-64 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> AMD64</label></li>
</ul>
</li>
<li>
<p>¿Qué combinación de flags aritmético- lógicos corresponde al código de condición b (below)? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> CF </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> OF </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> CFxorOF </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> OFxorSF </label></li>
</ul>
</li>
<li>
<p>En los modos de direccionamiento del tipo Desplazamiento(Base,Indice,Factor Escala), puede usarse como </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> desplazamiento,cualquierconstantede1, 2 o 4 bytes (incluso el nombre de una variable,porsudirección) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> base, cualquiera de los 8 registros enteros salvo %esp </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> índice,tambiéncualquierasalvo%ebp </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> factor de escala, cualquier constante de 1, 2, 4 u 8 bytes </label></li>
</ul>
</li>
<li>
<p>La diferencia entre las instrucciones test y cmp consiste en que </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> test realiza una operación and lógico, mientras que cmp realiza una resta</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> test modifica sólo los flags lógicos (ZF,SF) mientras que cmp modifica los aritmético-lógicos (ZF,SF,CF,OF) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> ambas respuestas son correctas </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ambas respuestas son incorrectas </label></li>
</ul>
</li>
<li>
<p>Para traducir una construcción if-then- else de lenguaje C a lenguaje ensamblador, gcc utiliza generalmente </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> un salto condicional,según la condición expresada en el código C </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> un salto condicional, según la condición opuesta a la del código C, y otro salto incondicional </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> dos saltos condicionales (uno para la parte if y otro para la parte else)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> dos saltos condicionales y dos saltos incondicionales </label></li>
</ul>
</li>
<li>
<p>Para traducir una construcción do-while de lenguaje C a lenguaje ensamblador, gcc utiliza generalmente</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> un salto condicional hacia adelante, según la misma condición que en lenguaje C  </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> un salto condicional hacia atrás, según la misma condición que en lenguaje </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> un salto condicional hacia adelante, según la condición opuesta a la de lenguaje C </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> un salto condicional hacia atrás, según la condición opuesta a la de lenguaje C </label></li>
</ul>
</li>
<li>
<p>Alguna de las siguientes señales no sirve de entrada a la unidad de control. ¿Cuál? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> señal de reloj(CLK) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> estado de la unidad de proceso (flags Z, S, C, O...) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> instrucción actual(bitsdelregistroIR) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> contador de programa (bits del registro PC) </label></li>
</ul>
</li>
<li>
<p>Alguna de las siguientes señales no es salida de la unidad de control. ¿Cuál?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> señales decarga,habilitacióny/o desplazamiento de registros ( Load, Enable, ShiftL, ShiftR) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> códigos de selección en multiplexores, decodificadores, ALU, etc (00, 01, 10, 11...) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> señales de lectura y escritura en memoria (RD, WR) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> dirección de la siguiente microinstrucción (bits del campo DIR o Memoria B de Wilkes) </label></li>
</ul>
</li>
<li>
<p>Alguna de las siguientes no es una operación básica de la unidad de control </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> transferir un registro a otro </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (leer o escribir) un registro (de / a) memoria </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> (guardar recuperar)un registro(en/de) la pila </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> realizar operación ALU y guardar resultado en registro</label></li>
</ul>
</li>
<li>
<p>Tipos de riesgos que hemos estudiado en cauces segmentados (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> riesgos estructurales </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> riesgos de (dependencia de) datos </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> riesgos control </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> riesgos de transferencia </label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes modos de direccionamiento es menos preferible para un procesador con segmentación de cauce? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> registro </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> directo </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indirectoatravésderegistro </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indexado (o relativo a base, o base+índice) </label></li>
</ul>
</li>
<li>
<p>La ganancia en velocidad ideal de un cauce de K etapas de igual duración T ejecutando un programa de N instrucciones es </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> S=KN/(K-N+1) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> S = NKT/(N-K+1)T </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> S=KN/(K+N-1) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> S = NT/(N+K-1)T </label></li>
</ul>
</li>
<li>
<p>Respecto al salto retardado y al salto anulante, ¿cuál permite que se ejecute la siguiente instrucción, y cuál no? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> el retardado ejecuta la siguiente instrucción (con el correspondiente retraso), el anulante no la ejecuta (de hecho la anula) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> el retardado la ejecuta sólo si se cumple la condición de salto, el anulante sólo si no se cumple </label></li>
<li><label><input type="radio" data-question="1" data-content="0" />el retardado la ejecuta sólo si no se cumple la condición de salto, el anulante no la ejecuta nunca </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> el retardado la ejecuta siempre, el anulante la ejecuta sólo si se cumple la condición de salto </label></li>
</ul>
</li>
<li>
<p>Respecto a las técnicas de direccionamiento por selección lineal, decodificación centralizada y distribuida</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> todas ellas impiden que haya cortocircuito en el bus de datos  </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> todas ellas impiden que haya cortocircuito en el bus de direcciones  </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> la selección lineal permitiría escribir un mismo dato a varios puertos E/S </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> usando decodificación centralizada es más fácil realizar expansiones al sistema de E/S </label></li>
</ul>
</li>
<li>
<p>Ventajas de la E/S independiente (separada, aislada) (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> diseño del procesador más sencillo(E/S mapeada añade complejidad al diseño) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> protección de E/S más fácil (E/S mapeada añade dificultad a la protección de E/S) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> mayor aprovechamiento del espacio de memoria (E/S mapeada resta espacio a la memoria) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> decodificación de memoria más elegante, limpia, sencilla (E/S mapeada añade complejidad a la decodificación) </label></li>
</ul>
</li>
<li>
<p>Parecidos y diferencias entre los métodos de E/S (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> la consulta del estado del dispositivo por parte de la CPU se suele/puede hacer con E/S programada y con E/S por IRQ </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se suele avisar a la CPU (con una IRQ) de que debe realizar alguna tarea, tanto en E/S por IRQ como en E/S por DMA </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> sólo E/S por DMA libera a la CPU de realizar la consulta de estado del dispositivo </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo E/S por DMA libera a la CPU de realizar la transferencia de los datos de E/S </label></li>
</ul>
</li>
<li>
<p>Tipos de interrupción que suelen contemplar las CPUs comerciales actuales (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> internas (excepciones o traps): generadas internamente por la CPU para indicar una condición que requiere atención (división por cero, codop inválido, etc)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> externas (IRQs hardware): generadas por un dispositivo externo a la CPU, activan la línea INTR# (o equivalente) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> software:generadas al ejecutar la instrucción INT (o equivalente) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> firmware (faults): generadas por el microcódigo de la CPU ( segmentation fault, page fault, etc) </label></li>
</ul>
</li>
<li>
<p>Técnicas que se pueden usar para determinar la causa de una interrupción (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> múltiples líneas de interrupción INT1#, INT2#... </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> línea de reconocimiento INTA# </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> consulta de estado,o polling </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> interrupciones vectorizadas </label></li>
</ul>
</li>
<li>
<p>Respecto a salvaguardar los registros de la CPU al inicio de una rutina de servicio de interrupción (ISR) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> no es necesario salvar ninguno más,si el contador de programa y los flags de estado ya los salva la propia CPU como parte del mecanismo de interrupción </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> se deben guardar los registros que se modifiquen en la propia ISR. Eso es posible hacerlo porque el propio programador de la ISR conoce qué registros va a modificar </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se deben guardar los registros salva- invocado (p.ej. EBX, ESI, EDI en el caso de una CPU IA-32), los registros salva- invocante ya los guarda el programa interrumpido </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se deben guardar todos los registros, para restaurarlos a la salida y así garantizar que el programa interrumpido no sufre ninguna modificación (salvo el inevitable retraso temporal) debido a la interrupción </label></li>
</ul>
</li>
<li>
<p>En EC podemos usar la palabra directo para referirnos a... (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> dispositivo de almacenamiento secuencial directo (DASD) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> cache con correspondencia directa </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> acceso directo a memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> modo de direccionamiento directo</label></li>
</ul>
</li>
<li>
<p>Variación de los parámetros de los distintos niveles en una jerarquía de memoria (señalar la opción incorrecta) </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> unidad de transferencia: xi xi+1 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ancho de banda: bi bi+1 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> tamaño del nivel: si si+1 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> tiempo de acceso: ti ti+1 </label></li>
</ul>
</li>
<li>
<p>Las técnicas write-through y write-back están relacionadas con </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> coherencia cache </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> métodos de E/S </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> arbitraje de buses </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> etapas de la unidad de control </label></li>
</ul>
</li>
<li>
<p>Para diseñar una memoria con ancho de palabra k·m (y mismo no palabras que los módulos) a partir de módulos con ancho de palabra m, se utilizan k módulos </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> repartiendo las líneas de datos entre los k módulos: el primero se conecta a D0...Dk-1, el segundo a Dk...D2k-1, etc </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> repartiendo las líneas de dirección: el 1o se conecta a A0...Ak-1, el 2o a Ak...A2k-1, etc </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> repartiendolíneasdatos:el1oseconecta a D0...Dm-1, el 2o a Dm...D2m-1, etc </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> d.repartiendo líneas dirección: el 1o a A0...Am-1, el 2o a Am...A2m-1, etc </label></li>
</ul>
</li>
<li>
<p>En un sistema con direcciones de 32bits, memoria de bytes, cache de 1MB asociativa por conjuntos de 4 vías y líneas de 64B, el campo etiqueta en el formato de dirección cache es de </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16bits </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 15bits </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 12bits</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 10bits </label></li>
</ul>
</li>
<li>
<p>¿Por qué se impusieron las arquitecturas de registros de propósito general a las arquitecturas basadas en pila? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Porque no se puede programar una arquitectura de pila en un lenguaje de alto nivel. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Porque las basadas en registros son capaces de lograr un mejor rendimiento cuando se asignan variables a registros. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque la memoria es más cara que los registros. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque las basadas en registros permiten reducir el tamaño del programa </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es incorrecta? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El direccionamiento indexado es útil para manejo de vectores. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El direccionamiento indirecto indica la dirección del operando. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En el direccionamiento implícito no se indica la ubicación del operando </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En el direccionamiento inmediato el dato se encuentra en la propia instrucción </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre el direccionamiento absoluto es falsa? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La instrucción contiene la dirección de memoria en la que se encuentra el objeto. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El objeto está en una posición de la memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El rango de posiciones direccionables queda limitado por el tamaño del campo de direccionamiento. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El tamaño del operando direccionado queda limitado por el no de bits del campo de direccionamiento. </label></li>
</ul>
</li>
<li>
<p>¿Cuál es la diferencia entre los desplazamientos a la derecha lógico y aritmético? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El lógico inserta siempre ceros en el bit más a la derecha </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El aritmético inserta en el bit más a la derecha una copia del bit de signo </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Insertan de forma distinta el bit más a la izquierda</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna, la diferencia es entre los desplazamientos a la izquierda </label></li>
</ul>
</li>
<li>
<p>La instrucción seta %al (seta significa set if above): </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Pone AL a 1 si CF=0 y ZF=0 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Pone AL a 1 si CF=0 o ZF=0 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Pone AL a 1 si CF=1 y ZF=0 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Pone AL a 1 si CF=1 o ZF=1 </label></li>
</ul>
</li>
<li>
<p>Los arrays bidimensionales en lenguaje C se almacenan en orden... </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> "mayor-de-columna" (column-major) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> "mayor-de-fila" (row-major) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> "de mayor a menor" (major-to-minor) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> "de fila a columna" (file-to-column) </label></li>
</ul>
</li>
<li>
<p>¿Cuál sería el "equivalente x86-64" del "pseudo-código C" rcx = ((int*)rax)[rcx]? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> mov (%rax,%rcx,4),%rcx </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> lea (%rax,%rcx,4),%rcx </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> lea (%rax,4,%rcx),%rcx </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> mov (%rax,4,%rcx),%rcx </label></li>
</ul>
</li>
<li>
<p>El direccionamiento directo a memoria utiliza </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> un registro. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> dos desplazamientos contenidos en la propia instrucción. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> un registro y un desplazamiento contenidos en la propia instrucción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> un desplazamiento. </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es falsa? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los programas necesitan una forma de pasar parámetros a las subrutinas y de recibir las salidas de vuelta.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las subrutinas necesitan ser capaces de reservar espacio en memoria para las variables locales sin sobrescribir ningún dato usado por el programa que hace la llamada </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las subrutinas necesitan recibir parámetros desde el programa que hace la llamada que indiquen qué registros pueden alterar y cuáles no. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las subrutinas necesitan algún modo de saber desde dónde han sido llamadas para poder volver al programa que realizó la llamada cuando se completa la subrutina </label></li>
</ul>
</li>
<li>
<p>Respecto a la segmentación: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cuanto más parecidos sean el tiempo de ejecución de una instrucción sin segmentar y el tiempo de una etapa en el procesador segmentado, mayor será la ganancia máxima que se puede obtener. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando el número de instrucciones ejecutadas tiende al número de etapas de un procesador segmentado, la ganancia máxima que se puede obtener tiende a infinito. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cuanto mayor sea la relación entre el tiempo de ejecución de una instrucción sin segmentar y el tiempo de una etapa en el procesador segmentado, mayor será la ganancia máxima que se puede obtener </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando el número de instrucciones ejecutadas en un procesador segmentado crece, la ganancia máxima que se puede obtener tiende a 1 </label></li>
</ul>
</li>
<li>
<p>Respecto a la segmentación, ¿cuál de las siguientes afirmaciones es falsa? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La técnica de register forwarding habilita una serie de caminos (buses) que se añaden al cauce para permitir que los resultados de una etapa pasen como entradas a la etapa donde son necesarias. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La reorganización del código y la introducción de instrucciones nop permite evitar dependencias de datos. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retrasar la fase de decisión saltar/no saltar de las instrucciones de salto condicional contribuye a mejorar el rendimiento del procesador. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantas más etapas tenga un cauce, más instrucciones se estarán ejecutando en distintas fases y más posibilidades se presentan de que existan riesgos entre ellas.</label></li>
</ul>
</li>
<li>
<p>La predicción de saltos está relacionada con... </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos estructurales (intenta evitar el efecto de un fallo de cache) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de (dependencia de) datos (intenta que el dato esté disponible anticipadamente) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los riesgos de control (intenta determinar de antemano el flujo de control) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de transferencia (intenta agrupar las posibles transferencias de un conjunto de instrucciones) </label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes modos de direccionamiento es <em>menos</em> preferible para un procesador con segmentación de cauce? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Registro </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Indirecto a través de memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Indirecto a través de registro </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Indexado (o relativo a base, o base+índice) </label></li>
</ul>
</li>
<li>
<p>Si se dice que en un sistema computador cada dirección especifica uno o dos puertos de E/S, se refiere a que: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La misma dirección (por ejemplo 0x0210) puede ser una posición de memoria o un puerto de E/S, según IO/M# </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La misma dirección puede usarse para transferir un byte o una palabra de mayor tamaño (ese byte y el siguiente) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un puerto será de sólo lectura, otro de sólo escritura, y ambos se decodifican en la misma dirección </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La pregunta es capciosa, una dirección puede especificar un puerto, no dos </label></li>
</ul>
</li>
<li>
<p>Respecto a si un computador dispone de E/S independiente (separada) o usa E/S mapeada a memoria:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Si el encapsulado (chip) del procesador tiene patilla (pin) IO/M# (o patillas equivalentes), eso evidencia que el computador usa E/S mapeada a memoria </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Si el repertorio del procesador tiene instrucciones del tipo IN y OUT, es que el computador dispone de E/S separada </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el encapsulado del procesador no dispone de patilla IO/M# (ni equivalentes), el computador sólo dispone de E/S separada </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el repertorio del procesador tiene instrucciones del tipo LOAD y STORE, el computador sólo dispone de E/S mapeada a memoria </label></li>
</ul>
</li>
<li>
<p>Supongamos dos procesadores con bus de direcciones con idéntico número de líneas. Si uno de ellos emplea E/S mapeada en memoria y el otro E/S independiente, ¿cuál podrá acceder a una mayor cantidad de memoria? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> El que tiene E/S independiente. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El que tiene E/S mapeada en memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Depende del tamaño del bus de direcciones. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ambos podrán acceder a la misma cantidad de memoria.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es incorrecta? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La consulta del estado del dispositivo por parte de la CPU se suele hacer con E/S programada (salvo con dispositivos que siempre están listos para transferir) y con E/S por IRQ (cuando se usa polling para determinar el origen de la IRQ) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se suele avisar a la CPU (mediante una IRQ) de que debe realizar alguna tarea, tanto en E/S por IRQ (obligatoriamente, la tarea es la transferencia) como en E/S por DMA (optativamente, el controlador DMA puede avisar de que acabó) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Sólo E/S por DMA libera a la CPU de realizar la consulta de estado del dispositivo de E/S </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo E/S por DMA libera a la CPU de realizar la transferencia de los datos de E/S </label></li>
</ul>
</li>
<li>
<p>El fragmento de código:<br>
<code>poll: in a, 0x20 <br>cmp a, $0 <br>jnz poll <br>load a, 0x11 <br>out 0x21, a <br></code> corresponde a: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> E/S programada sin consulta de estado </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> E/S programada con consulta de estado </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S por interrupciones </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S por DMA </label></li>
</ul>
</li>
<li>
<p>Un procesador con E/S en el mapa de memoria tiene un bus de direcciones de 10 líneas y uno de datos de 8. El mapa de memoria tiene 512 posiciones para instrucciones, 256 para datos y 256 para E/S, en ese orden. Los rangos de direcciones para esas tres zonas serán: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 000a1FF,200a2FFy300a3FF. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 000a5FF,600a7FFy800a9FF. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 000 a 7FF, 800 a BFF y C00 a FFF. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 000a9FF,A00aCFFyD00aFFF. </label></li>
</ul>
</li>
<li>
<p>El instrumento GIADA de la sonda espacial ROSETTA (diseñado en Granada) está basado en un microprocesador 8086 y el siguiente mapa de memoria: 
RAM volátil: 00000 - 0FFFF 
RAM no volátil: 10000 - 1FFFF 
ROM: F0000 - FFFFF 
¿Cuál es el tamaño total de la memoria? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 48KB </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 192KB </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 2MB</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 3MB </label></li>
</ul>
</li>
<li>
<p>Una memoria que está estructurada en palabras de 8 bits tiene una capacidad de 64 Kbits. ¿Cuántas líneas de dirección tiene dicha memoria? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 8 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 12 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 13 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 24 </label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes es el ejemplo más acertado de localidad espacial? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Referenciar elementos de un array sucesivamente </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Iterar repetidamente el cuerpo de un bucle </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reservar dinámicamente (malloc) espacio para una estructura o union </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Referenciar continuamente la misma variable local </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes es una idea fundamental de la jerarquía de memoria? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Crear una gran cantidad de almacenamiento que sea caro y rápido</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Crear una pequeña cantidad de almacenamiento que sea caro y lento </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Que dispositivos más pequeños y rápidos sirvan de cache para dispositivos más grandes y lentos </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Que dispositivos más grandes y lentos sirvan de cache para dispositivos más pequeños y rápidos </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones acerca de las memorias SRAM es falsa? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los datos almacenados se mantienen por un tiempo indefinido mientras se mantenga la alimentación. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El número de transistores necesario para implementar cada celda es mayor que en las memorias RAM dinámicas </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las operaciones de lectura son destructivas </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Son más veloces que las memorias RAM dinámicas</label></li>
</ul>
</li>
<li>
<p>Se dispone de un circuito integrado que actúa como módulo básico de memoria de 8K × 4. ¿Qué circuitos necesitamos para construir una memoria de 17K × 8? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 2 módulos de memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 2 módulos de memoria y un decodificador. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4 módulos de memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 4 módulos de memoria y un inversor. </label></li>
</ul>
</li>
<li>
<p>En la cache L1 de instrucciones, la tasa de fallos: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre tiende a crecer si el tamaño total de L1 crece. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Siempre tiende a disminuir si el tamaño total de L1 crece. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre tiende a crecer si el número de vías crece. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre tiende a disminuir si el número de vías disminuye. </label></li>
</ul>
</li>
<li>
<p>Supongamos que una memoria cache de tamaño 512B con política LRU está inicialmente vacía. Si para la siguiente secuencia de direcciones enviadas a la cache: 0, 2, 4, 8, 16, 32, la tasa de acierto es 0.33, ¿cuál es entonces el tamaño de bloque de la cache? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4B </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 8B </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16B </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguno de los anteriores </label></li>
</ul>
</li>
<li>
<p>Un sistema tiene una cache asociativa por conjuntos de 2-vias con 16 conjuntos y líneas de 64. ¿A qué conjunto le corresponde el byte con dirección 0xdeadbeef? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 7 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 11 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 13 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 14</label></li>
</ul>
</li>
<li>
<p>¿Cuál es el tamaño de la etiqueta de caché en un ordenador capaz de direccionar por bytes 1 MB de memoria principal y 32 KB de memoria caché y correspondencia asociativa por conjuntos con 32 bytes por línea y 16 líneas por conjunto? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 6 bits </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 7 bits </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8 bits </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 9 bits </label></li>
</ul>
</li>
<li>
<p>En el direccionamiento inmediato el operando reside en: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> en un registro del procesador </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> en la instrucción tras el código de operación </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> en memoria, en la dirección indicada </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> en la pila </label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina del tipo "Add M,R" podría formar parte del repertorio de </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> una máquina pila </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> una máquina de acumulador </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> una máquina con arquitectura R/R </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> una máquina con arquitectura M/M</label></li>
</ul>
</li>
<li>
<p>La traducción a ASM de una función C con prototipo <code>void fun(&lt;tipo&gt; arg1, &lt;tipo&gt; arg2)</code>; por parte de gcc empieza con el siguiente texto:<br>
<code>fun: <br>movl (%rdi), %eax <br>movl (%rsi), %edx ... </code>
¿Cuál es el posible <tipo> mencionado en el prototipo? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>long *</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>unsigned int *</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>short *</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>unsigned char *</code> </label></li>
</ul>
</li>
<li>
<p>Se puede describir paso a paso la ejecución de la instrucción add (%rbx, %rdx,4), %eax; de la siguiente manera (marcar la opción FALSA): </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> primero: se calcula la dirección efectiva EA=RBX+RDX*4a </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> segundo: se leen ocho bytes a partir de dicha dirección de memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> tercero: se yuxtaponen los bytes leídos de forma que el de dirección más baja ("el primero leído") sea el menos significativo y el de dirección más alta ("el último leído") sea el más significativo </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> cuarto: se suma el valor obtenido con el registro EAX </label></li>
</ul>
</li>
<li>¿Qué valor contendrá el registro rdx tras ejecutar las dos instrucciones siguientes? 
movq $-1, %rdx 
movl $1, %edx <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 0xFFFF FFFF FFFF 0001 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0xFFFF FFFF 0000 0001 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0xFFFF 0000 0000 0001 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 0x0000 0000 0000 0001</label></li>
</ul>
</li>
<li>
<p>En el fragmento de código <br><code>400544:e807000000 callq 400550 f <br> 400549:488903 mov %rax,(%rbx) </code><br> la instrucción <code>call</code> suma al contador de programa la cantidad: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 0x00000007 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0x00400549 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0x400544 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 0x48 </label></li>
</ul>
</li>
<li>
<p>Una función C declarada como <code>int get_var_digit(size_t index, size_t digit)</code> genera como código ensamblador <br><code> movq var(,%rdi,8), %rax <br> movl (%rax,%rsi,4), %eax <br> ret </code><br>
Se puede adivinar que: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> var es un array multi-nivel (punteros a enteros) de cuatro filas  </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> var es un array multi-nivel pero no se pueden adivinar las dimensiones  </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> var es un array bidimensional de enteros, con ocho columnas  </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> var es un array bidimensional de enteros, con cinco columnas </label></li>
</ul>
</li>
<li>
<p>En el contexto de microprogramación, el control residual... </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> intenta disminuir la cantidad de "bits residuales", usando las técnicas de codificación y/o solapamiento de campos, como opuestas a la microprogramación directa o "inmediata". </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se refiere a que cuanto más codificación y/o solapamiento se use, menos capacidad para expresar paralelismo se tiene, siendo ese menor control un "residuo" o consecuencia no deseada de dichas técnicas no "inmediatas" </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> clasifica las microinstrucciones del microcódigo según formen parte de microprogramas ("microinstr. inmediatas") o no ("microinstr. residuales") </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> consiste en almacenar señales de control en un "registro de control residual" para usarlas en ciclos posteriores, a diferencia del "control inmediato", en donde los bits se utilizan inmediatamente </label></li>
</ul>
</li>
<li>Suponer que un procesador ideal que ejecuta cada instrucción en <code>T</code> segundos se segmenta en cuatro etapas ideales de duración <code>T/4</code>. ¿Cuál razonamiento es correcto? <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se espera una reducción de prestaciones porque además de ejecutar las instrucciones hay que segmentarlas (coste de la segmentación) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se espera una reducción de prestaciones porque la duración del ciclo de reloj vendrá impuesta por la etapa más lenta </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se espera un aumento de prestaciones debido al efecto de los riesgos (hazards) sobre el avance de las instrucciones en el cauce </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se espera un aumento de prestaciones debido a que las cuatro etapas solapan su funcionamiento, con una aceleración ideal de 4x </label></li>
</ul>
</li>
<li>Un salto condicional del tipo "delayed branch", o salto retardado, ejecuta la(s) instrucción(es) siguiente(s)... <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> sólo si el salto se produce (las ignora si NO se produce), de manera que instrucción(es) en el destino del salto podrían adelantarse tras la propia instrucción de salto </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo si el salto NO se produce (las ignora si se produce), de manera que instrucción(es) en el destino del salto podrían adelantarse tras la propia instrucción de salto </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> siempre, de manera que instrucción(es) anterior(es) al salto podrían colocarse tras la propia instrucción de salto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> nunca, de manera que instrucción(es) anterior(es) al salto no podrían colocarse tras la propia instrucción de salto </label></li>
</ul>
</li>
<li>Un computador con 20 líneas de dirección y memoria de bytes tiene 640KB de RAM, 128KB de ROM, y utiliza E/S mapeada en memoria. ¿Cuál es el número máximo de periféricos que pueden conectarse, si cada uno de ellos utiliza 32 direcciones? <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{10}\)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{11}\)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(2^{12}\) </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> \(2^{13}\) </label></li>
</ul>
</li>
<li>La consulta de estado que se puede llevar a cabo en una operación de salida mediante E/S programada sirve para… <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> consultar si el dispositivo tiene algún dato de salida disponible </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> consultar si el dispositivo está aún ocupado, por ejemplo con alguna operación de salida  anterior </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> consultar si el dispositivo funciona correctamente </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ninguna de las respuestas anteriores es correcta </label></li>
</ul>
</li>
<li>¿Qué conjunto de componentes permite construir una memoria 256Mx32? (sin que sobren componentes) <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16 chips 64Mx4 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 32 chips 64Mx4 (256<em>32==64</em>4*32) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 chips 64Mx16 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores </label></li>
</ul>
</li>
<li>¿Cuántas líneas de dirección (patillas) son necesarias para direccionar un chip de memoria DRAM de 256K x 4? <ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 9 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 13 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 19</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 22 </label></li>
</ul>
</li>
<li>¿Qué arquitectura es típica en procesadores RISC? <ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> registro-registro </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> registro-memoria </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> memoria-registro </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> memoria-memoria </label></li>
</ul>
</li>
<li>¿Cuál de las siguientes características es posterior a la segunda generación de computadores? <ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Memoria de núcleos de ferrita </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Compilador </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Memoria cache </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Lenguaje ensamblador </label></li>
</ul>
</li>
<li>Si el registro rax contiene x, la sentencia en C x &amp;= 0x1; se traducirá a ensamblador como: <ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> andq $1, %rax </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> orq $0x1, %rax </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> shrq %rax </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sarq %rax </label></li>
</ul>
</li>
<li>
<p>Para crear espacio en la pila para variables locales sin inicializar suele realizarse la siguiente operación </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Restar una cantidad positiva a <code>rbp</code>. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sumar una cantidad positiva a <code>rbp</code>. </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Restar una cantidad positiva a <code>rsp</code>. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sumar una cantidad positiva a <code>rsp</code>.</label></li>
</ul>
</li>
<li>
<p>Si la estructura struct a ocupa un espacio de 26 bytes en memoria, ¿cuántos bytes ocupa la siguiente estructura struct b cuando se compila en 64 bits? <br><code>struct b{<br> struct a a1; <br> int i; <br> struct a a2; <br> }; </code><br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 24 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 58 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 60 (entero ocupa 8) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 </label></li>
</ul>
</li>
<li>
<p>En la secuencia de programa siguiente:<br>
<code> 628: e8 cd ff ff ff  callq   5fa suma   <br> 62d: 48 83 c4 20    add     $0x20, %rsp </code> <br>
¿Cuál es el valor que introduce en la pila la instrucción <code>callq</code>? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xffffffcd</code> </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x5fa</code> </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x628</code> </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x62d</code> </label></li>
</ul>
</li>
<li>
<p>Un archivo <code>.o</code> que contiene código objeto reubicable: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Contiene instrucciones máquina binarias. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Contiene instrucciones máquina y directivas en ensamblador.  </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Puede ejecutarse directamente. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Contiene las direcciones definitivas de las variables globales. </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes sentencias sobre la unidad de control es FALSA? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cuanto más horizontal es la microprogramación, más largas son las microinstrucciones </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Debido al pequeño número de operaciones simples, la sección de control de un procesador RISC puede ser cableada en lugar de microprogramada</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El programador de lenguaje ensamblador necesita conocer la microarquitectura del ordenador </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es posible realizar el diseño físico de una unidad de control cableada de manera semiautomática </label></li>
</ul>
</li>
<li>
<p>En una unidad de control microprogramada con formato de microinstrucciones vertical, un subcampo que deba especificar 16 señales de control, codificadas de tal forma que pueda activarse sólo una o ninguna señal de control, habrá de tener una anchura mínima de: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4 bits </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 5 bits (2^4+1bit de control) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 bits </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 17 bits </label></li>
</ul>
</li>
<li>
<p>La técnica de "adelanto de registros" (register forwarding) en un cauce segmentado se usa para limitar el impacto de los riesgos... </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> estructurales </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> organizativos </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> de control </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> de datos </label></li>
</ul>
</li>
<li>
<p>Un sistema no segmentado tarda 10 ns en procesar una tarea. La misma tarea puede ser procesada en un cauce (pipeline) de 4 segmentos con un ciclo de reloj de 4 ns. Cuando se procesan muchas tareas, la ganancia máxima de velocidad que se obtiene se acerca a: </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 10 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 40 </label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 2,5(10/4) </label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es cierta? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La E/S en memoria emplea la patilla IO/M#.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En E/S independiente, las instrucciones de acceso a memoria suelen ser más largas que las de E/S. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La E/S en memoria facilita la protección. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En la E/S en memoria las instrucciones de E/S son fácilmente reconocibles.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre la jerarquía de memoria es cierta?  </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Para aumentar la eficiencia se transfieren bloques completos.  </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Toda la información que el procesador necesita está en el nivel 1. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si una palabra no se encuentra en el tercer nivel entonces se busca en el segundo nivel. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> A medida que nos alejamos del procesador, el tamaño de memoria disminuye. </label></li>
</ul>
</li>
<li>
<p>¿Cuántas líneas de dirección (patillas) son necesarias para direccionar un chip de memoria DRAM de 4096 x 4? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 6 \(2^{12}\) </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 10 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 11 </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 12</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes instrucciones máquina copia en <code>EAX</code> la dirección efectiva resultante de la operación EDX*4 + EBX?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leal 4(%edx, %edx), %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>leal (%ebx, %edx, 4), %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl 4(%edx, %edx), %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (%ebx, %edx, 4), %eax</code></label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes instrucciones máquina copia en <code>EAX</code> el entero almacenado en la posición de memoria cuya dirección efectiva es el resultado de la operación <code>EDX*4 + EBX</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leal 4(%edx, %edx), %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leal (%ebx, %edx, 4), %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl 4(%edx, %edx), %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>movl (%ebx, %edx, 4), %eax</code></label></li>
</ul>
</li>
<li>
<p>Los switches <code>–m elf_i386</code> y <code>–m elf_x86_64</code> para trabajar en 32 bits / 64 bits corresponden a la herramienta...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>gcc</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>as</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>ld</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>nm</code></label></li>
</ul>
</li>
<li>
<p>Si <code>ECX</code> vale 0, la instrucción <code>adc $0,%ecx</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Pone <code>CF=1</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Pone <code>CF=0</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cambia <code>CF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No cambia <code>CF</code></label></li>
</ul>
</li>
<li>
<p>Dada la siguiente definición de datos:<br>
     <code>
     lista: .int    0x10000000, 0x50000000, <br>
             0x10000000, 0x20000000  <br>
     longlista: .int    (.-lista)/4         <br>
     resultado: .quad   0x123456789ABCDEF   <br>
     formato:   .ascii  "suma=%llu=%llx hex\n\0"    <br>
     </code><br>
    La instrucción para copiar la dirección de memoria donde comienza lista en el registro EBX es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl lista, %ebx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>movl $lista, %ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (lista), %ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl $lista, (%ebx)</code>.</label></li>
</ul>
</li>
<li>
<p>Dada la siguiente definición de datos:<br>
     <code>
     lista: .int    0x10000000, 0x50000000, <br>
             0x10000000, 0x20000000  <br>
     longlista: .int    (.-lista)/4         <br>
     resultado: .quad   0x123456789ABCDEF   <br>
     formato:   .ascii  "suma=%llu=%llx hex\n\0"    <br>
     </code><br> La instrucción <code>movl longlista, %ecx</code> copia el siguiente valor:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 4</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32    </label></li>
</ul>
</li>
<li>
<p>Dada la siguiente definición de datos:<br>
     <code>
     lista: .int    0x10000000, 0x50000000, <br>
             0x10000000, 0x20000000  <br>
     longlista: .int    (.-lista)/4         <br>
     resultado: .quad   0x123456789ABCDEF   <br>
     formato:   .ascii  "suma=%llu=%llx hex\n\0"    <br>
     </code><br> 
     y suponiendo que hemos llamado a una función <em>suma</em> que devuelve un número de 64 bits en la pareja 
     <code>EDX:EAX</code>, las instrucciones que copian ese número en <em>resultado</em>
     son:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code> movl %eax, resultado <br> movl %edx, resultado+4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (%eax), resultado <br>movl (%edx), resultado+4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl %eax, resultado+4 <br>movl %edx, resultado</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (%eax), resultado+4</code></label></li>
</ul>
</li>
<li>
<p>Dada la siguiente definición de datos:<br>
     <code>
     lista: .int    0x10000000, 0x50000000, <br>
             0x10000000, 0x20000000  <br>
     longlista: .int    (.-lista)/4         <br>
     resultado: .quad   0x123456789ABCDEF   <br>
     formato:   .ascii  "suma=%llu=%llx hex\n\0"    <br>
     </code><br>
     La llamada correcta a <code>printf</code> será:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code> push resultado+4    <br>               push resultado      <br>               push $formato       <br>               call printf         <br>               add $12, %esp       <br> </code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code> push resultado+4    <br>                 push resultado      <br>                 push resultado+4    <br>                 push resultado      <br>                 push $formato       <br>                 call printf         <br>                 add $20, %esp       <br> </code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code> push resultado      <br>                 push resultado+4    <br>                 push $formato       <br>                 call printf <br>add $12, %esp <br> </code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code> push resultado       <br>                 push resultado+4     <br>                  push resultado       <br>                 push resultado+4     <br>                 push $formato        <br>                 call printf          <br>                 add $20,%esp           <br> </code></label></li>
</ul>
</li>
<li>
<p>En la práctica "media" se pide sumar una lista de enteros <strong>con</strong> signo de 32 bits en una plataforma de 32 bits sin perder precisión, esto es, evitando overflow. ¿Cuál es el menor valor positivo que repetido en los <strong>dos</strong> primeros elementos de la lista causaría overflow con 32 bits al realizar la suma de <strong>esos dos</strong> primeros elementos de la lista? (Entendemos que la lista contiene 4 números, y se va a realizar la suma de la lista 4 veces).</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x0400 0000</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x0800 0000</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x4000 0000</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x8000 0000</code></label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es cierta respecto al lenguaje C?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> En lenguaje C, al llamar a una subrutina o función se introducen los parámetros en la pila y después se realiza una llamada a la subrutina</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los parámetros se introducen en la pila en el orden en el que aparecen en la llamada de C, es decir, empezando por el primero y acabando por el último</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Antes de volver de la rutina llamada, el programa en C se encarga de quitar de la pila los parámetros de llamada realizando varios pop</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Pasar a una función un puntero a una variable se traduce en introducir en la pila el valor de la variable</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes registros tiene que ser salvaguardado (si va a
    modificarse) dentro de una subrutina según la convención cdecl para IA32?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>edx</code>    </label></li>
</ul>
</li>
<li>
<p>¿En qué registro se pasa el primer argumento a una función en Linux gcc
    x86-64?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>esi</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>edi</code></label></li>
</ul>
</li>
<li>
<p>La práctica "popcount" debía calcular la suma de bits (peso Hamming) de
    los elementos de un array. Un estudiante entrega la siguiente versión de
    popcount3:
    <code>                                        <br>
    int popconut3 (unsigned* array, int len) {      <br>
        int , res = 0;                              <br>
        unsigned x;                                 <br>
        for ( i=0; i &lt; len; i++ ) {                   <br>
            x = array[i];                           <br>
            asm("ini3:        \n"                   <br>
            "shr %[x]         \n"                   <br>
            "adc $0, %[r]     \n"                   <br>
            "add $0, %[x]     \n"                   <br>
            "jne ini3         \n"                   <br>
                                                    <br>
            : [r] "+r" (res)                        <br>
            : [x] "r" (x) );                        <br>
        }                                           <br>
        return res;                                 <br>
    }                                               <br>
    </code></p>
<p>Esta función produce siempre el resultado correcto, a pesar de que una instrucción
 máquina en la sección asm() es distinta a la que se esperaba después de haber
 estudiado pcount_r en teoría. La instrucción distinta también se podría haber
 cambiado por...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>sar %[x]</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>adc $0, %[x]</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>test %[x], %[x]</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>cmp %[x], %[r]</code></label></li>
</ul>
</li>
<li>
<p>En la práctica de la bomba necesitamos estudiar el código máquina de la
    bomba del compañero. A veces dicho código no se visualiza directamente en
    el depurador ddd, y algunas de las técnicas que se pueden probar para
    conseguir visualizarlo son... (marcar la opción <strong>falsa</strong>)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> comprobar que está activado el panel <br> <em>View → Machine Code Window</em></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> escribir info line main en el panel de línea de comandos gdb</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> recompilar con información de depuración, por si se nos había olvidado, ya que sin <code>–g</code> el ejecutable no contiene información de depuración</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> asegurarse de que se ha escrito correctamente el nombre del ejecutable</label></li>
</ul>
</li>
<li>
<p>En la práctica de la bomba, el primer ejercicio consistía en "saltarse" las
    "explosiones", para lo cual se puede utilizar...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> objdump o gdb</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> gdb o ddd</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ddd o hexedit</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> hexedit u objdump</label></li>
</ul>
</li>
<li>
<p>En la práctica de la bomba, el segundo ejercicio consistía en crear un
    ejecutable sin "explosiones", para lo cual se puede utilizar...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> objdump o gdb</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> gdb o ddd</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ddd o hexedit</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> hexedit u objdump</label></li>
</ul>
</li>
<li>
<p>En la práctica de la bomba, el tercer ejercicio consistía en usar un editor
    hexadecimal para crear un ejecutable sin "explosiones". Para saber qué
    contenidos del fichero hay que modificar, se puede utilizar... (marcar la opción
    falsa)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> objdump</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> gdb</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ddd</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> hexedit</label></li>
</ul>
</li>
<li>
<p>Suponer una memoria cache con las siguientes propiedades: Tamaño: 512
    bytes. Política de reemplazo: LRU. Estado inicial: vacía (todas las líneas
    inválidas). Suponer que para la siguiente secuencia de direcciones enviadas a
    la cache: 0, 2, 4, 8, 16, 32, la tasa de acierto es 0,33. ¿Cuál es el tamaño de
    bloque de la cache?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4 bytes</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 8 bytes</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 bytes</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguno de los anteriores    </label></li>
</ul>
</li>
<li>
<p>Abajo se ofrece el listado de una función para multiplicar matrices C = A x
    B.<br>
    <code>
    void mult_matr(float A[N][N]   <br>
    float B[N][N], float C[N][N]) { <br>
    /*Assume val.ini. C=(0,0...)*/ <br>
    int i,j,k; <br>
    for (i=0; i<N; i++) <br>
        for (j=0; j<N; i++) <br>
            for (k=0; k<N; i++) <br>
                C[i][j] += A[i][k]*B[k][j]; <br>
    }
    </code> <br>
    Suponer que:<br>
    <ul>
        <li> El computador tiene una cache de datos de 8 MB, 16-vías, líneas de 64 bytes.</li>
        <li> N es grande, una fila o columna no cabe completa en cache.</li>
        <li> El tamaño de los tipos de datos es como en IA32.</li>
        <li> El compilador optimiza el acceso a C[i][j] en un registro.</li>
    </ul>
    Aproximadamente, ¿qué tasa de fallos se podría esperar de esta función para
    valores grandes de N?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 1/2</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/4</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/8</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/16</label></li>
</ul>
</li>
<li>
<p>Sea un computador de 32 bits con una memoria cache L1 para datos de 32
     KB y líneas de 64 bytes asociativa por conjuntos de 2 vías. Dado el siguiente
     fragmento de código:<br>
     <code>
     int v[262144];<br>
     for (i=0; i&lt;262144; i+=8) <br>
         v[i]=9; <br>
     </code><br> 
     ¿Cuál será la tasa de fallos aproximada que se obtiene en la ejecución del bucle
     anterior?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 0 (ningún fallo)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 1/2 (mitad aciertos, mitad fallos)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/8 (un fallo por cada 8 accesos)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1 (todo son fallos)  </label></li>
</ul>
</li>
<li>
<p>¿Qué hace <code>gcc -O0</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Compilar sin optimización</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Compilar .c -&gt; .o (fuente C a objeto)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Compilar .s -&gt; .o (fuente ASM a objeto)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Compilar .c -&gt; .s (C→ASM sin generar objeto)</label></li>
</ul>
</li>
<li>
<p>¿Qué modificador (switch) de gcc hace falta para compilar una aplicación de
    32 bits en un sistema de 64 bits?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>-m32</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-m64</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-march32</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-march64</code></label></li>
</ul>
</li>
<li>
<p>La etiqueta del punto de entrada a un programa ensamblador en el entorno
   de las prácticas 1 a 4 (GNU/as Linux x86) es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>_main</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>L0</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>_start</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>_init</code></label></li>
</ul>
</li>
<li>
<p>La siguiente línea en la sección de datos de un programa en ensamblador de
IA32<br>
    <code>result: .int 0,0</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Reserva espacio para un único entero, inicializado a 0,0</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reserva espacio para un entero, inicializado a 0, seguido de un dato de tamaño indefinido, también inicializado a 0</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Reserva espacio para dos enteros, inicializados ambos a 0</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reserva espacio para un único entero, inicializado a 0, en la posición de memoria 0</label></li>
</ul>
</li>
<li>
<p>El volcado mostrado abajo se ha obtenido con el comando...<br> <code>
    00000000 main: <br>
     0: 55             push %ebp <br>
     1: 89 e5          mov %esp, %ebp   <br>
     3: 83 e4 f0       and $-16, %esp<br>
     6: 83 ec 10       sub  $0x10, %esp<br>
     9: c7 44 24 04 03 movl $3, 4(%esp)<br>
     e: 00 00 00<br>
    11: c7 04 24 01 00 movl $0x1, (%esp)<br>
    16: 00 00<br>
    18: e8 fc ff ff ff call \<main+0x19><br>
    1d: c9             leave<br>
    1e: c3             ret<br>
    </code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>objdump -h p</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>objdump -d p</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>objdump -d p2.o</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>objdump -t p2.olibC</code></label></li>
</ul>
</li>
<li>
<p>En la práctica "media" se desea invocar desde lenguaje ensamblador la
     función printf() de libC. Eso implica que este programa, como todo programa
     que use libC,</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> es obligatorio que contenga <code>main</code> (y entonces es más cómodo usar gcc para enlazar)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> es obligatorio enlazarlo usando gcc (y entonces es más cómodo que contenga <code>main</code>)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> es ventajoso para ensamblarlo que contenga <code>main</code>, y entonces es conveniente enlazarlo usando gcc (aunque ambas cosas son opcionales)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> es ventajoso para enlazarlo usar gcc, y entonces es conveniente que contenga <code>main</code> (aunque ambas cosas son opcionales)</label></li>
</ul>
</li>
<li>
<p>En la práctica "media" se pide sumar una lista de 32 enteros SIN signo de 32
     bits en una plataforma de 32 bits sin perder precisión, esto es, evitando perder
     acarreos. Un estudiante entrega la siguiente versión <br>
    <code>
    # $lista en EBX, longlista en ECX <br>
    suma:<br>
        mov $0, %eax<br>
        mov $0, %edx<br>
        mov $0, %esi<br>
    bucle:<br>
        add (%ebx, %edx, 4), %eax<br>
        jnc seguir<br>
        inc %edx<br>
    seguir:<br>
        inc %esi<br>
        cmp %esi, %ecx<br>
        jne bucle<br>
        ret
    </code><br>
    Esta función presenta una única diferencia frente a la solución recomendada en
    clase, relativa al indexado en el array.
    Esta función suma:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Produce siempre el resultado correcto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> allaría con <code>lista: .int 1,1,1,1, 1,1,1,1, ...</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Fallaría con <code>lista: .int 1,2,3,4, 1,2,3,4, ...</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos</label></li>
</ul>
</li>
<li>
<p>En la práctica "media" se pide sumar una lista de 32 enteros SIN signo de 32
   bits en una plataforma de 32 bits sin perder precisión, esto es, evitando perder
   acarreos. De entre los siguientes, ¿cuál es el mínimo valor entero que repetido
   en toda la lista causaría acarreo con 32 bits (sin signo)? Se usa notación
   decimal y espacios como separadores de millares/millones/etc.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 10 000 000</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 100 000 000</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 1 000 000 000</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 10 000 000 000</label></li>
</ul>
</li>
<li>
<p>En la práctica "media" se pide sumar una lista de 32 enteros CON signo de
    32 bits en una plataforma de 32 bits sin perder precisión, esto es, evitando
    desbordamiento. De entre los siguientes, ¿cuál es el valor negativo más pequeño (en valor absoluto) que
    repetido en toda la lista causaría desbordamiento con 32 bits (en
    complemento a 2)? Se usa notación decimal y espacios como separadores de
    millares/millones/etc.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> -10 000 000</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> -100 000 000</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> -1 000 000 000</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> -10 000 000 000</label></li>
</ul>
</li>
<li>
<p>¿Cuál es el popcount (peso Hamming, número de bits activados) del número 19?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 2</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 3</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 5</label></li>
</ul>
</li>
<li>
<p>La práctica "popcount" debía calcular la suma de bits (peso Hamming) de
    los elementos de un array. Un estudiante entrega la siguiente versión de
    popcount3:<br>
     <code>                                        <br>
     int popconut3 (unsigned* array, int len) {      <br>
         int , res = 0;                              <br>
         unsigned x;                                 <br>
         for ( i=0; i &amp;lt len; i++ ) {               <br>
             x = array[i];                           <br>
             asm("ini3:        \n"                   <br>
             "shr %[x]         \n"                   <br>
             "adc $0, %[r]     \n"                   <br>
             "add $0, %[x]     \n"                   <br>
             "jne ini3         \n"                   <br>
                                                    <br>
             : [r] "+r" (res)                        <br>
             : [x] "r" (x) );                        <br>
         }                                           <br>
         return res;                                 <br>
     }                                               <br>
     </code><br>
     Esta función solo tiene una diferencia con la versión "oficial" recomendada en clase. En concreto, una instrucción máquina en la sección <strong>asm()</strong> es distinta. Esta función <code>popcount3</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> produce siempre el resultado correcto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={0,1,2,3}</strong></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={1,2,4,8}</strong></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> no es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos</label></li>
</ul>
</li>
<li>
<p>La práctica "popcount" debía calcular la suma de bits (peso Hamming) de
    los elementos de un array. Un estudiante entrega la siguiente versión de
    popcount3:<br>
     <code>                                        <br>
     int popconut3 (unsigned* array, int len) {      <br>
         long val = 0;                               <br>
         int , res = 0;                              <br>
         unsigned x;                                 <br>
         for ( i=0; i &amp;lt len; i++ ) {               <br>
             x = array[i];                           <br>
                                                     <br>
             do {                                    <br>
                val = x &amp; 0x1;                       <br>
                x &gt;&gt;= 1;                             <br>
             } while (x);                            <br>
             val += (val &gt;&gt; 16);                     <br>
             val += (val &gt;&gt; 8);                      <br>
         }                                           <br>
                                                     <br>
         return val &amp; 0xFF;                          <br>
     }                                               <br>
     </code> <br>
     Esta función es una mezcla inexplicada de las versiones "oficiales" de <strong>popcount2</strong> y <strong>popcount4</strong>, incluyendo diferencias en 2 tipos de datos, la ausencia de la variable <strong>res</strong> y la diferente posición de la máscara <strong>0xFF</strong>.<br> Esta función popcount3:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> produce siempre el resultado correcto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={0,1,2,3}</strong></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={1,2,4,8}</strong></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> no es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>La práctica "popcount" debía calcular la suma de bits (peso Hamming) de
    los elementos de un array. Un estudiante entrega la siguiente versión de
    popcount4:<br>
     <code>                                        <br>
     int popconut3 (unsigned* array, int len) {      <br>
         int , res = 0;                              <br>
         unsigned x;                                 <br>
         for ( i=0; i &amp;lt len; i++ ) {               <br>
             x = array[i];                           <br>
             asm("ini3:        \n"                   <br>
             "shr %[x]         \n"                   <br>
             "adc $0, %[r]     \n"                   <br>
             "add $0, %[x]     \n"                   <br>
             "jne ini3         \n"                   <br>
                                                    <br>
             : [r] "+r" (res)                        <br>
             : [x] "r" (x) );                        <br>
         }                                           <br>
         return res;                                 <br>
     }                                               <br>
     </code><br>Esta función presenta varias diferencias con la versión "oficial" recomendada en clase, incluyendo la ausencia de una variable auxiliar <strong>val</strong> y la diferente posición de los desplazamientos <strong>&gt;&gt;</strong> y máscara <strong>0xFF</strong>. Esta función popcount4:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> produce siempre el resultado correcto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={0,1,2,3}</strong></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> fallaría con <strong>array={1,2,4,8}</strong></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> no es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos</label></li>
</ul>
</li>
<li>
<p>La práctica "parity" debía calcular la suma de paridades impar (XOR de
    todos los bits) de los elementos de un array. Un estudiante entrega la
    siguiente versión de <code>parity5</code>:<br>
     <code>
     int parity5 (unsigned * array, int len) { <br>
         int i, j, result=0;<br>
         unsigned x;<br>
         for (i=0; i &lt; len; i++) {<br>
             x ^= x &gt;&gt; j;<br>
             result += x &amp; 0x1;<br>
         }<br>
         return result;<br>
     }<br>
     </code><br>Esta función solo se diferencia de la versión "oficial" recomendada en clase, en las condiciones del bucle <strong>for</strong> interno. Esta función <code>parity5</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Produce siempre el resultado correcto</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con array={0,1,2,3}</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Fallaría con array={1,2,4,8}</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos</label></li>
</ul>
</li>
<li>
<p>La función <code>gettimeofday()</code> en la práctica de la "bomba digital" se utiliza para</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Para comparar las duraciones de las distintas soluciones del programa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Para imprimir la fecha y hora</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Para cifrar la contraseña en función de la hora actual</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Para cronometrar lo que tarda el usuario en introducir la contraseña</label></li>
</ul>
</li>
<li>
<p>Un fragmento de una "bomba" desensamblada es:<br>
     <code>
     0x0804873f: call 0x8048504 &lt;scanf&gt; <br>
     0x08048744: mov 0x24 (%esp), %edx <br>
     0x08048748: mov 0x804a044, %eax <br>
     0x0804874d: cmp %eax, %edx <br> 
     0x0804874f: je 0x8048756 &lt;main+230&gt; <br>
     0x08048751: call 0x8048604 &lt;boom&gt; <br>
     0x08048756: ... <br>
     </code><br>La contraseña/clave en este caso es...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> el string almacenado a partir de la posición de memoria <code>0x804a044</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> el string almacenado a partir de la posición de memoria <code>0x24(%esp)</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> el entero almacenado a partir de la posición de memoria <code>0x804a044</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> el entero <code>0x804a044</code></label></li>
</ul>
</li>
<li>
<p>Una de las "bombas" utiliza el siguiente bucle para cifrar la cadena con la
    contraseña introducida por el usuario:<br>
     <code>
     80485bb: rolb $0x4, (eax) <br>
     80485be: add $0x1, %eax <br>
     80485c1: cmp %edx, %eax <br>
     80485c3: jne 80485bb &lt; encrypt+0x20&gt;  <br>
     </code><br>
     La intrucción <strong>rolb</strong> rota el byte destino hacia la izquierda tantos bits como indica el operando fuente. Si inicialmente <code>eax</code> apunta a la cadena del usuario, que se compara con otra cadena <code>\x16\x26\x27\x16\x36\x16\x46\x16\x26\x27\x16</code>, almacenada en el código, la contraseña es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>\x61\x62\x72\x61\x63\x61\x64\x61\x62\x72\x61</code> (<code>abracadabra</code>)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>\x61\x72\x62\x61\x64\x61\x63\x61\x72\x62\x61</code> (<code>arbadacarba</code>)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>\x63\x61\x64\x61\x62\x72\x61\x61\x62\x72\x61</code> (<code>cadabraabra</code>)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>\x61\x62\x72\x61\x61\x62\x72\x61\x63\x61\x64</code> (<code>abraabracad</code>)</label></li>
</ul>
</li>
<li>
<p>Una de las "bombas" utiliza el siguiente código para cifrar la clave
    numérica introducida por el usuario y ahora almacenada en <code>eax</code>:<br>
     <code>
     804870d: xor $0xfff, %eax <br>
     8048712: mov $0x2, %ecx <br>
     8048717: cltd <br>
     8048718: idiv %ecx <br>
     804871a: cmp %eax, 0x804a034 <br>
     </code> <br>Si el entero almacenado a partir de 0x804a034 es 0x7ff, la clave numérica puede ser:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x10094F97 (269045655)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xfff (4095)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x7ff (2047)</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>1</code></label></li>
</ul>
</li>
<li>
<p>En el programa line.cc de la práctica 5, si para cada tamaño de línea (line)
    recorremos una única vez el vector, la gráfica resultante es decreciente
    porque:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cada vez que line aumenta al doble, el número de aciertos por localidad temporal aumenta, porque ya habíamos accedido a cada posición i del vector cuando lo recorrimos en el punto anterior del eje X.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada vez que line aumenta al doble, el número de aciertos por localidad espacial aumenta, porque ya habíamos accedido a cada posición i-1 del vector cuando lo recorrimos en el punto anterior del eje X.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada vez que line aumenta al doble, se accede con éxito a más posiciones del vector en niveles de la jerarquía de memoria más rápidos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cada vez que line aumenta al doble, realizamos la mitad de accesos al vector que para el valor anterior.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre el programa size.cc de la
    práctica 5 es cierta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La diferencia de velocidades entre L2 y L3 es mayor que la diferencia de velocidades entre L1 y L2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si continuáramos multiplicando por 2 el tamaño del vector en el eje X obteniendo más puntos de la gráfica, esta continuaría horizontal para cualquier valor más allá de 64 MB.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La gráfica tiene escalones hacia arriba porque en cada punto del eje X accedemos al mismo número de elementos del vector y el número de aciertos por localidad temporal disminuye bruscamente en ciertos puntos al aumentar el tamaño del vector.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La gráfica tiene tramos horizontales porque el hecho de realizar la mitad de accesos al vector en cada punto de un tramo horizontal respecto al anterior punto de ese mismo tramo horizontal es compensado por el número de fallos creciente en ese mismo tramo horizontal.</label></li>
</ul>
</li>
<li>
<p>El switch de gcc para que únicamente compile de lenguaje C a ensamblador, y no realice ningún paso adicional (ensamblar, enlazar, etc), es...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-c</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>-S</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-o</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>-g</code></label></li>
</ul>
</li>
<li>
<p>Los switches <code>--32</code> y <code>--64</code> para trabajar en 32bit/64bit corresponden a la herramienta...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> gcc</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> as</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ld</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> nm</label></li>
</ul>
</li>
<li>
<p>El switch <code>-l</code> para indicar librerías <strong>NO</strong> funciona con la herramienta...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> gcc</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> as</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ld</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede marcar una y sólo una de las anteriores.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes no es una sección de un fichero <em>ELF</em>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>.text</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>.static</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>.data</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>.bss</code></label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes contenidos no está incluido en un fichero <em>ELF</em> ejecutable?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Código máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Variables globales.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Pila del usuario.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Tabla de símbolos.</label></li>
</ul>
</li>
<li>
<p>En la práctica <em>media</em> se programa la suma de una lista de 32 enteros de 4 B para producir un resultado de 8 B, primero sin signo y luego con signo. Si la lista se rellena con el valor que se indica a continuación, ¿en qué caso ambos programas producen el mismo resultado?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x1111 1111</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x9999 9999</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xAAAA AAAA</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xFFFF FFFF</code></label></li>
</ul>
</li>
<li>
<p>En la práctica <em>media</em> se programa la suma de una lista de 32 enteros de 4 B para producir un resultado de 8 B, primero sin signo y luego con signo. Si la lista se rellena con el valor <code>0x0400 0000</code>, ¿en qué se diferencian los resultados de ambos programas?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Se diferencian.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En uno ocupa 32 bits, en otro 64 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En uno interpreta como negativo, en otro como positivo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En uno los 32 bits superiores son <code>0xFFFF FFFF</code>, en el otro no.</label></li>
</ul>
</li>
<li>
<p>En la práctica <em>media</em> se suma una lista de 32 enteros de 4 B con signo para producir una media y un resto usando la instrucción <code>IDIV</code>. ¿Cuál de las siguientes afirmaciones es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>IDIV</code> produce el mismo cociente que el operador <code>/</code> en lenguaje C.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>IDIV</code> produce el mismo resto que el operador <code>%</code> en lenguaje C.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La media se redonde al entero más próximo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El resto siempre tiene el mismo signo que la suma.</label></li>
</ul>
</li>
<li>
<p>En la práctica <em>media</em> un estudiante usa el siguiente bucle para acumular la suma en <code>EBP:EDI</code> antes de calcular la media y el resto:<br><code>bucle:<br> mov (%ebx,%esi,4), %eax<br> cltd<br> add %eax, %edi<br> adc %edx, %ebp<br> jnc nocarry<br> inc %edx<br>nocarry:<br> inc %esi<br> cmp %esi, %ecx<br> jne bucle</code><br>Estando bien programa todo lo además, este código.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con lista: <code>.int 0,1,2,3</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con lista: <code>.int -1,-2,-4,-8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No siempre produce el resultado correcto, pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>Alguno de los siguientes no es un nombre de registro en una máquina IA32 en modo 32 bits.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>dh</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>sil</code></label></li>
</ul>
</li>
<li>
<p>Alguno de los siguientes no es un nombre de registro en una máquina x86-64 en modo 64 bits.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>r8d</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>r12w</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>sih</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>spl</code></label></li>
</ul>
</li>
<li>
<p>Para comprobar si el entero almacenado en <code>EAX</code> es cero (y posiblemente saltar a continuación usando <code>JZ/JNZ</code>), gcc genera el código:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>cmp %eax, $0</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>test %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>cmp %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>test %eax, %eax</code></label></li>
</ul>
</li>
<li>
<p>La práctica <em>paridad</em> debía calcular la suma de paridades impar (<code>XOR</code> de todos los bits) de los elementos de un array. Un estudiante entrega la siguiente versión de <em>parity3</em>:<br><code>int parity3(unsigned<em> array, int len){<br> int i, res=0, val;<br> unsigned x;<br> for(int i=0; i<len; i++){<br> x=array[i];<br> val=0;<br> do{<br> val += x;<br> x &gt;&gt;= 1;<br> } while (x);<br> val &amp;= 0x1;<br> res += val;<br> }<br> return res;<br>}</code><br>Esta función </em>parity3*:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No siempre produce el resultado correcto.</label></li>
</ul>
</li>
<li>
<p>Un estudiante entrega la sigueinte versión de <em>parity4</em>:<br><code>int parity4(unsigned<em> array, int len){<br> int val, i, res=0;<br> unsigned x;<br> for(int i=0; i<len; i++){<br> x=array[i];<br> val = 0;<br> asm("\n")<br>"ini3: \n\t"<br> "xor %[x], %[v] \n\t"<br> "shr %[x] \n\t"<br> "test %[x], %[x] \n\t"<br> "jne ini3 \n\t"<br> :[v] "+r" (val)<br> :[x] "r" (x)<br> );<br> val = val &amp; 0x1;<br> res += val;<br> }<br> return res;<br>}</code><br>Esta función </em>parity4*:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No siempre produce el resultado correcto, pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>La sentencia <code>asm()</code> del listado anterior tiene las siguientes restricciones:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Arquitectura de 32 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Dos entradas y una salida.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro y dos sobrescritos (clobber).</label></li>
</ul>
</li>
<li>
<p>Un estudiante entrega la siguiente versión de <em>parity5</em>:<br><code>int parity5(unsigned<em> array, int len){<br> int i,j,res=0;<br> unsigned x;<br> for(i=0; i<len; i++){<br> x=array[i];<br> for(j=sizeof(unsigned)</em>4; j&gt;0; j=j/2){<br> x^=x&gt;&gt;j;<br> }<br> x = x &amp; 0x1;<br> res += x;<br> }<br> return res;<br>}</code><br>Esta función <em>parity5</em>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No siempre produce el resultado correcto, pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>Un estudiante entrega la siguiente versión de <em>parity6</em>:<br><code>int parity6(unsigned<em> array, int len){<br> int i,j,res = 0;<br> unsigned x;<br> for(int i = 0; i<len; i++){<br> x=array[i];<br> asm("\n"<br> "mov %[x], %%edx \n\t"<br> "shr $16, %%edx \n\t"<br> "xor %%edx, %[x] \n\t"<br> "mov %[x], %%edx \n\t"<br> "mov %%dh, %%dl \n\t"<br> "xor %%edx, %[x] \n\t"<br> "setpo %%cl \n\t"<br> "movzx %%cl, %[x]"<br> :[x] "+r" (x)<br> :<br> : "edx", "ecx"<br> );<br> res += x;<br> }<br> return res;<br>}</code><br>Esta función </em>parity6*:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No siempre produce el resultado correcto, pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>La sentencia <code>asm()</code> del listado anterior tiene las siguientes restricciones:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Arquitectura de 32 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos entrada y una salida.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un registro y dos sobrescritos (clobber).</label></li>
</ul>
</li>
<li>
<p>En el programa <em>size</em> de la práctica de la cache, si el primer escalón pasa de <code>tiempo = 1</code> para todos los tamaños de vector menores o iguales que 32 KB a <code>tiempo = 3</code> para los tamaños 64 KB y 128 KB, podemos asegurar que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La cache L1 es al menos tres veces más rápida que la cache L2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La cache L1 es como mucho tres veces más rápida que la cache L2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La cache L2 es al menos el doble de rápida que la memoria principal.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La cache L2 es como mucho el doble de rápida que la memoria principal.</label></li>
</ul>
</li>
<li>
<p>El código del programa <em>size</em> de la práctica de la cache accede al vector saltando...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> De byte en byte.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> De 64 en 64 bytes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> De 1KB en 1KB.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> De 64KB en 64KB.</label></li>
</ul>
</li>
<li>
<p>1.La dirección efectiva del primer parámetro de llamada a una función en pila suele calcularse desde el código de la función como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>EBP+8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EBP-8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EBP+4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EBP-4</code></label></li>
</ul>
</li>
<li>
<p>El comienzo e un procedimiento que siga la conveción cdecl es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>mov %ebp, %esp; push %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>mov %esp, %ebp; push %ebp; push %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>mov %ebp, %esp push %ebp</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov %esp, %ebp</code></label></li>
</ul>
</li>
<li>
<p>Considere una función C declarada así:<br>
     <code>void fun4arg(int a, int b, int c, int d)</code><br>
    Suponiendo que <code>fun4arg</code> se ha compilado para una máquina x86 IA-32 con enteros de 4 bytes, ¿cuál sería la dirección del argumento <code>b</code> relativa a <code>%ebp</code>, en el marco de la pila de <code>fun4arg</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%ebp + 8</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>%ebp + 12</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%ebp + 16</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%ebp + 20</code></label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre las caches es <em>FALSA</em>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Casi ningún procesador actual tiene memoria cache L2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las direcciones a las que accede un programa no son completamente aleatorias, sino que se rigen por ciertos patrones de localidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un procesador actual tiene varias cachés de nivel 1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La caché de nivel 3 no contiene toda la memoria que maneja el programa.</label></li>
</ul>
</li>
<li>
<p>En un sistema Linux x86-64, ¿cuál de las siguientes variables ocupa más bytes en memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>char a[7]</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>short b[3]</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>int* c</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>float d</code></label></li>
</ul>
</li>
<li>
<p>En la práctica <em>suma</em> se pide sumar una lista de 32 enteros SIN signo de 32bits en una plataforma de 32bits sin perder precisión, esto es, evitando acarreos. ¿Cuál es el mínimo valor entero que repetido en toda la lista causaría acarreo con 32bits (sin signo)?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xfc00 0000</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xfbff ffff</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x0800 0000</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x07ff ffff</code></label></li>
</ul>
</li>
<li>
<p>En la práctica <em>suma</em> se pide sumar una lista de 32 enteros CON signo de 32bits en una plataforma de 32bits sin perder precisión, esto es, evitando desbordamiento. ¿Cuál es el valor negativo más pequeño (en valor absoluto) que repetido en toda la lista causaría desbordamiento con 32bits (en complemento a 2)?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xfc00 0000</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xfbff ffff</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xf800 0000</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xf800 0001</code></label></li>
</ul>
</li>
<li>
<p>¿Qué valor contendrá <code>edx</code> tras ejecutar las siguientes instrucciones?<br><code> xor %eax, %eax<br> sub $1, %eax<br> cltd<br> idiv %eax</code><br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 0.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> -1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No puede saberse con los datos del enunciado.</label></li>
</ul>
</li>
<li>
<p>La práctica <em>popcount</em> debería calcular la suma de bits de los elementos de un array. Un estudiante entrega lo siguiente:<br><code>int popcount4(unsigned* array, int len){<br> int i, j, res = 0;<br> for(int i = 0; i &lt; len; ++i){<br> unsigned x = array[i];<br> int n = 0;<br> do{<br> n += x &amp; 0x01010101L;<br> x &gt;&gt;= 1;<br> } while(x);<br><br> for(j = 16; j == 1; j /= 2){<br> n^= (n &gt;&gt;= j);<br> }<br> res += n &amp; 0xff;<br> }<br> return res;<br>}</code><br>Esta función <code>popcount4</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>La práctica <em>paridad</em> debía calcular la suma de paridades impar (<code>XOR</code> de todos los bits) de los elementos de un array. Un estudiante entrega la siguiente versión de <code>parity6</code>:<br><code>int parity6(unsigned* array, int len){<br> int i, result = 0;<br> unsigned x;<br> for(int i=0; i<len; i++){<br> x = array[i];<br> asm("mov %[x], %%edx \n\t"<br> "shr $15, %%edx \n\t"<br> "shr $8, %%edx \n\t"<br> "xor %%edx, %%edx \n\t"<br> "setp %%dl \n\t"<br> "movzx %%dl, %[x] \n\t"<br> : [x] "+r" (x)<br> :<br> : <br> );<br> result += x;<br> }<br> return result;<br>}</code><br>Esta función <code>parity6</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Produce siempre el resultado correcto.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es correcta pero el error no se manifiesta en los ejemplos propuestos, o se manifiesta en ambos.</label></li>
</ul>
</li>
<li>
<p>En la práctica <em>paridad</em> se pide calcular la suma de paridades de una lista de enteros sin signo. Suponer que un estudiante entrega la siguiente versión:<br><code>int paridad5(unsigned* array, int len){<br> int i, k, result = 0;<br> unsigned x;<br> for(int i = 0; i &lt; len; i++){<br> x = array[i];<br> for(k = 16; k == 1; k /= 2)<br> x ^= x &gt;&gt; k;<br> result += (x &amp; 0x0x1);<br> }<br> return result;<br>}</code><br>Esta función:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es correcta.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Fallaría con <code>array = {0,1,2,3}</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Fallaría con <code>array = {1,2,4,8}</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede marcar una y sólo una de las opciones anteriores.</label></li>
</ul>
</li>
<li>
<p>Utilizando la sentencia <code>asm</code>, las denominadas restricciones que se indican al final de dicha sentencia, involucran a:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solamente las entradas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solamente las salidas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solamente los sobrescritos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguan de las anteriores es cierta.</label></li>
</ul>
</li>
<li>
<p>En la resalización de la práctica de la bomba digital, una parte del código máquina es el siguiente:<br><code> 0x080486e8 (main+120): call 0x8048524 (strncmp)<br> 0x080486ed (main+125): test %eax, %eax<br> 0x080486ef (main+127): je 0x80486f6 (main+134)<br> 0x080486f1 (main+129): call 0x8048604 (boom)</code><br>¿Cuál de los siguientes comandos cambiaría el salto condicional por un salto incondicional?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>set $0x080486ef=0xeb</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>set *(char*)0x080486ef=0xeb</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>set *(char*)0x080486f6=jmp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>set %0x080486ef=0xeb</code></label></li>
</ul>
</li>
<li>
<p>En una bomba como las estudiadas en prácticas, del tipo...<br><code> 0x0804873f (main+207): call 0x8048504 (scanf)<br> 0x08048744 (main+212): mov 0x24(%esp), %edx<br> 0x08048748 (main+216): mov 0x804a044, %eax<br> 0x0804874d (main+221): cmp %eax, %edx<br> 0x0804874f (main+223): je 0x8048756 (main+230)<br> 0x08048751 (main+225): call 0x8048604 (boom)<br> 0x08048756 (main+230): ...</code><br>La contraseña es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El entero <code>0x804a044</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El entero almacenado a partir de la posición de memoria <code>0x804a044</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El string almacenado a partir de la posición de memoria <code>0x24(%esp)</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>En una bomba como las estudiadas en prácticas, del tipo...<br><code> 0x080486e8 (main+120): call 0x8048524 (strcmp)<br> 0x080486ed (main+125): test %eax, %eax<br> 0x080486ef (main+127): je 0x80486f6 (main+134)<br> 0x080486f1 (main+129): call 0x8048604 (boom)<br> 0x080486f6 (main+134): ...</code><br>La contraseña es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El valor que tenga <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El string almacenado a partir de donde apunta <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El entero almacenado a partir de donde apunta <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>El servidor de SWAD tiene dos procesadores Xeon E5540 con 4 núcleos cada uno. Cada procesador tiene 4 caches L1 de instrucciones de 32 KB, 4 caches L1 de datos de 32 KB, 4 caches unificadas L2 de 256 KB y una cache unificada L3 de 8MB. Suponga que un proceso swad, que se ejecuta en un núcleo, tiene que ordenar un vector de estudiantes accediendo repetidamente a sus elementos. Cada elemento es una estructura de datos de un estudiante y tiene un tamaño de 4KB. Si representamos en una gráfica las prestaciones en función del número de estudiantes a ordenar, ¿para qué límites teóricos en el número de estudiantes se observarán saltos en las prestaciones debidos a accesos a la jerarquía de memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4 / 32 / 512 estudiantes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 8 / 64 / 2048 estudiantes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 / 32 / 64 estudiantes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32 / 256 / 8192 estudiantes.</label></li>
</ul>
</li>
<li>
<p>En la práctica de la cache, el código de <code>line.cc</code> incluye la sentencia:
     <code>for(unsigned line=1; line&lt;=MAXLINE; line&lt;&lt;=1){...}</code>.
     ¿Qué objetivo tiene la expresión <code>line&lt;&lt;=1</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Salir del bucle si el tamaño de línea se volviera menor o igual que 1 para algún elemento del vector.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Duplicar el tamaño del salto en los accesos al vector respecto a la iteración anterior.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Volver al principio del vector cuando el índice exceda la longitud del vector.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sacar un uno (1) por el stream <code>line</code>.</label></li>
</ul>
</li>
<li>
<p>Sea un computador de 32 bits con una memoria caché L1 para datos de 32 KB y líneas de 64 bytes asociativa por conjuntos de 2 vías. Dado el siguiente fragmento de código:
     <code>int v[262144];<br> for(int i = 0; i &lt; 262144; i+=2)<br>v[i]=9;</code>
     ¿Cuál será la tasa de fallos aproximada que se obtiene en la primera ejecución del bucle anterior?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 0 (ningún fallo).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/2 (mitad aciertos, mitad fallos).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 1/8 (un fallo por cada 8 accesos).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1 (todo son fallos).</label></li>
</ul>
</li>
<li>
<p>Con los mismos supuestos, imaginar que se modifica la última sentencia (el cuerpo anidado) por esta otra:
     <code>C[i][j] += A[i][k] * B[j][k];</code>
     de manera que se calcule <code>C = A x Bt</code> (A por traspuesta de <code>B</code>).
     Aproximadamente, ¿qué tasa de fallos se podría esperar de esta nueva función para valores grandes de <code>N</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 1/16</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/8</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/4</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1/2</label></li>
</ul>
</li>
<li>
<p>En contraposición a un ejecutable Linux ELF, un fichero objeto (obtenido con <code>gcc -c</code>):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No contiene tablas de símbolos, que sólo se añaden al ejecutable tras enlazar.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ubica el código (y los datos) a partir de la posición <code>0x0</code>, las direcciones definitivas sólo se calculan tras enlazar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Contiene tablas de símbolos, pero sólo para los símbolos locales; p.ej., sólo al enlazar un programa que llame a <code>printf</code> se añadirá una entrada a la tabla con la dirección de <code>printf</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No reserva espacio para las direcciones de objetos desconocidos; p.ej., sólo al enlazar un <code>CALL</code> a <code>printf</code> se insertan los 4B de la dirección de printf entre el codop de <code>CALL</code> y el de la siguiente instrucción máquina.</label></li>
</ul>
</li>
<li>
<p>Tras ejecutar las tres instrucciones que se muestran desensambladas a continuación, el registro <code>EAX</code> toma el valor:
     <code>08048074 (_start):<br> 08048074: be 74 80 04 08 mov $_start, %esi<br> 08048079: 46 inc %esi<br> 0804807a: 8b 06 mov (%esi), %eax</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x08048074</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x08048075</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x08048079</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x0804807a</code></label></li>
</ul>
</li>
<li>
<p>Si <code>%edx</code> contiene <code>0xf000</code> y <code>%ecx</code> contiene <code>0x0100</code>, el direccionamiento <code>0x80(%ecx,%edx,2)</code> se refiere a la posición:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xf182</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xf280</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x1e180</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las respuestas anteriores es correcta.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes secuencias de instrucciones multiplica <code>%eax</code>por 10?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leal (%eax,%eax,2), %eax; sall $2, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>imull $0x10, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>addl %eax, %eax; shll $5, %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Varias o ninguna de las respuestas anteriores son correctas, no se puede marcar una y sólo una.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes secuencias de instrucciones calcula <code>a=b-a</code>, suponiendo que <code>%eax</code> es <code>a</code> y <code>%ebx</code> es <code>b</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>subl %eax, %ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>subl %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>notl %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Varias o ninguna de las respuestas anteriores son correctas, no se puede marcar una y sólo una.</label></li>
</ul>
</li>
<li>
<p>Para desplazar <code>%eax</code> a la derecha un número variable de posiciones 32, indicado en <code>%ebx</code>, se puede hacer:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>sar %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>sar %bl, %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov %ebx, %ecx; sar %cl, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede, <code>sar</code> sólo admite un número fijo de posiciones (debe ser un valor inmediato).</label></li>
</ul>
</li>
<li>
<p>Indicar cuál es la dirección de salto (en qué dirección se empiza la subrutina (<code>main</code>) para esta instrucción <code>call</code>):
     <code> 0804854e: e8 3d 06 00 00 call (main)<br> 08048553: 50 pushl %eax</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>08048b90</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>08048b8b</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>450a854e</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede deducir de la información proporcionada, faltan datos.</label></li>
</ul>
</li>
<li>
<p>El ajuste de marco de pila que gcc (Linux/IA-32) prepara para todas las funciones consiste en las instrucciones:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl %ebp, %esp; pushl %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl %esp, %ebp; pushl %esp</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>pushl %ebp; movl %esp, %ebp</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>pushl %esp; movl %ebp, %esp</code></label></li>
</ul>
</li>
<li>
<p>Al traducir de lenguaje C a ensamblador, gcc en máquinas Linux/IA-32 almacena (reserva espacio para) una variable <code>var</code> local a una función <code>fun</code> en una dirección de memoria referenciable (en lenguaje ensamblador) como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>var</code> (el nombre de la variable representa su posición de memoria).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>-k(%ebp)</code>, siendo <code>k</code> un número constante positivo relativamente pequeño.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>k(%ebp)</code>, siendo <code>k</code> un número constante positivo relativamente pequeño.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>k(%esp)</code>, siendo <code>k</code> un numero constante positivo reslativamente pequeño.</label></li>
</ul>
</li>
<li>
<p>En x86-64 se pueden referenciar los registros:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>%rax, %eax, %ax, %ah, %al</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%rsi, %esi, %si, %sih, %sil</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%r8, %r8d, %r8w, %r8l</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%r12q, %r12d, %r12w, %r12l</code></label></li>
</ul>
</li>
<li>
<p>Comparando las convenciones de llamada de gcc Linux IA-32 con x86-64 respecto a registros: <strong>(NO ENTRA EN TEMARIO DE EC)</strong></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> En IA-32 <code>%ebx</code> es salva-invocante, pero en x86-64 <code>%rbx</code> es salva-invocado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En IA-32 <code>%ecx</code> es salva-invocante, y en x86_64 <code>%rcx</code> es salva-invocante también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En IA-32 <code>%esi</code> es salva-invocado, y en x86_64 <code>%rsi</code> es salva-invocado también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En IA-32 <code>%ebp</code> es especial (marco de pila), y en x86_64 <code>%rbp</code> también.</label></li>
</ul>
</li>
<li>
<p>Si declaramos <code>int val[5] = {1,5,2,1,3};</code> entonces:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>&amp;val[2]</code> es de tipo <code>int*</code> y vale lo mismo que <code>val+8</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>val+4</code> es de tipo <code>int*</code> y se cumple que <code>*(val+4)==5</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>val+1</code> es de tipo <code>int</code> y vale 2.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>val[5]</code> es de tipo <code>int</code> y vale 3.</label></li>
</ul>
</li>
<li>
<p>Al traducir la sentencia C <code>r-&gt;i = val;</code> gcc genera el código ASM <code>mov %edx, 12(%eax)</code>. Se deduce que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>r</code>es un puntero que apunta a la posición de memoria 12.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El desplazamiento de <code>i</code> en <code>*r</code> es 12.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>i</code> es un entero que vale 12.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>val</code>es un entero que vale 12.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.addClass('text-warning');
            } else {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>