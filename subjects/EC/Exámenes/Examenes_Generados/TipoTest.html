<!DOCTYPE html>
<html>
<head>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans-serif;
        }
        code, pre {
            font-family: monospace;
        }
        h1 code,
        h2 code,
        h3 code,
        h4 code,
        h5 code,
        h6 code {
            font-size: inherit;
        }
        ul li {
            list-style-type: none;
        }
        table {
        @extend .table;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>EC. Preguntas Tipo Test de Teoría.</h1>
<p><strong>Autor:</strong> Jose Juan Urrutia Milán 'JJ'.<br>
<strong>Autor:</strong> Lucas Hidalgo Herrera.<br>
<strong>Autor:</strong> Arturo Olivares Martos.</p>
<hr>
<ul>
<li><strong>Asignatura:</strong> Estructura de Computadores.</li>
<li><strong>Curso Académico:</strong> 2023-24.</li>
<li><strong>Grado:</strong> Doble Grado en Ingeniería Informática y Matemáticas.</li>
<li><strong>Grupo:</strong> A.</li>
<li><strong>Profesor:</strong> Ignacio Rojas Ruiz.</li>
<li><strong>Descripción:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Estructura de Computadores. En él, se pueden encontrar una gran variedad de preguntas de EC de los últimos años.</li>
</ul>
<p>Las preguntas se encuentran en <a href=https://losdeldgiim.github.io/subjects/EC/Ex%C3%A1menes/Examenes_Generados/TipoTest.html>esta web</a>.</p>
<p>Las explicaciones de cada pregunta se pueden encontrar en el archivo Markdown correspondiente, que se encuentra pinchando <a href=https://github.com/LosDelDGIIM/LosDelDGIIM.github.io/blob/main/subjects/EC/Ex%C3%A1menes/TipoTest.md>aquí</a>.</p>
<hr>
<ol>
<li>
<p>Respecto a direccionamiento a memoria en ensamblador IA32 (sintaxis AT&amp;T), de la forma <code>D(Rb, Ri, S)</code>, sólo una de las siguientes afirmaciones es FALSA. ¿Cuál?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  El desplazamiento D puede ser una constante lineal (1, 2 ó 4 bytes).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>EBP</code> no se puede usar como registro base.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>ESP</code> no se puede usar como registro índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  El factor de escala <code>S</code> puede ser 1, 2, 4, 8.</label></li>
</ul>
</li>
<li>
<p>La extensión de signo a m bits de un número original N de n bits, con m &gt; n, consiste en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N}\)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Realizar la operación \(2^{m– N-1}\)</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Incrementar la cantidad de bits a m preservando el signo y el valor del número.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Incrementar la cantidad de bits a m rellenando con unos por la izquierda.</label></li>
</ul>
</li>
<li>
<p>En IA32, ¿cuál de los siguientes fragmentos de programa tiene un efecto sobre los flags distinto al resto?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>sub %edi,%edi</code> <br> <code>adc $0xFFFFFFFF, %edi</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov $-1, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov$-1,%edi</code> <br> <code>add $0, %edi</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>mov $0, %edi</code> <br> <code>sub $1, %edi</code></label></li>
</ul>
</li>
<li>
<p>Si <code>%rsp</code> vale <code>0xdeadbeefdeadd0d0</code>, ¿cuál será su nuevo valor después de que se ejecute <code>pushq %rbx?</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0d8</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>0xdeadbeefdeadd0cc</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xdeadbeefdeadd0c8</code></label></li>
</ul>
</li>
<li>
<p>¿Cómo se devuelve en ensamblador x86-64 Linux gcc el valor de retorno de una función long int al terminar esta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La instrucción <code>RET</code> lo almacena en un registro especial de retorno.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Por convención se guarda en <code>%eax</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Se almacena en pila justo encima de los argumentos de la función.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ninguna de esas formas es correcta.</label></li>
</ul>
</li>
<li>
<p>Comparando las convenciones de llamada de gcc Linux IA32 con x86-64 respecto a registros.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebx</code> es salva-invocante, pero en x86-64 <code>%rbx</code> es salva-invocado.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En IA32 <code>%ecs</code> es salva-invocante, y en x86-64 <code>%rcd</code> es salva-invocante también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%esi</code> es salva-invocado, y en x86-64 <code>%rsi</code> es salva-invocado también.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  En IA32 <code>%ebp</code> es especial (marco de pila1), y en x86-64 <code>%rbp</code> también.</label></li>
</ul>
</li>
<li>
<p>Son funciones de la unidad de control:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  La codificación de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  La lectura de memoria principal de la instrucción apuntada por el PC.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El secuenciamiento de las instrucciones máquina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Todas las respuestas son ciertas.</label></li>
</ul>
</li>
<li>
<p>Respecto a <code>MBR</code> y <code>MAR</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos son accesibles por el programador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  <code>MAR</code> contiene el dato/instrucción que se leerá o escribirá en memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>MAR</code> requiere menos señales de control que <code>MBR</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Ambos permiten guardar información sobre el marco de pila.</label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina puede desglosarse en las siguientes operaciones elementales:<br>
<code>sp := ps-1; m[sp] := pc; pc:= x</code><br>
Probablemente se trate de una instrucción de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  Apilamiento.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Llamada a subrutina.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Carga total.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Almacenamiento local.</label></li>
</ul>
</li>
<li>
<p>En una unidad de control microprogramada con formato de microinstrucciones vertical, un subcampo que debe especificar 16 señales de control codificadas de tal forma que pueda activarse sólo una o ninguna harbá de tener una anchura mínima de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" />  4 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 5 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  16 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  17 bits.</label></li>
</ul>
</li>
<li>
<p>Dado un camino de datos concreto, un posible formato de microprogramación se caracteriza como horizontal o vertical según tenga más o menos (señalar la respuesta falsa)</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> codificación</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> solapamiento</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> micro bifurcaciones</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> longitud relativa de microinstrucción</label></li>
</ul>
</li>
<li>
<p>El control residual se utiliza para:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> reducir el tiempo de ejecución de las instrucciones máquina</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> eliminarlos bits residuales de la ejecución de las microinstrucciones</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> reducir el tamaño de la memoria de control</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ninguna de las anteriores es cierta</label></li>
</ul>
</li>
<li>
<p>Un procesador está segmentado en las etapas F, D, E, M y W. Cada una de  ellas consume un tiempo t. La aceleración ideal (si no hay riesgos) al ejecutar n instrucciones respecto a un procesador no segmentado será:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 5n/(4+n)_</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (4+n)/5t</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4n/(5+n)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> (5+n)/4t</label></li>
</ul>
</li>
<li>
<p>En un procesador con segmentación de cauce, aumentar el número de etapas (p.ej. de 2 a 4, o de 4 a 8), tiene en general como consecuencia:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un Incremendo De Las Prestaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" />  Un mayor retraso en la ejecución de los programas debido al incremento del número de etapas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución en la posible dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una disminución de la máxima frecuencia de reloj a la que puede operar el cauce.</label></li>
</ul>
</li>
<li>
<p>En la secuencia de instrucciones siguiente, siendo el primer registro el destino, ¿cuántos riesgos se dan?<br>
<code>sub r2,r1,r3 or r8,r6,r2</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un riesgo estructural.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un riesgo por dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un Riesgo Estructural Dos Po dependencia de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos riesgos por dependencia de datos y uno de control.</label></li>
</ul>
</li>
<li>
<p>La precaptación(cola de instrucciones) está relacionada con...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Los riesgos estructurales(intenta evitar el efecto de un fallo de cache)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de (dependencia de) datos (intenta que el dato esté disponible anticipadamente)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos control(intenta determinar de antemano el flujo de control)</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los riesgos de transferencia(intenta agrupar las posibles transferencias de un conjunto de instrucciones).</label></li>
</ul>
</li>
<li>
<p>Respecto a la segmentación, ¿cuál de las siguientes afirmaciones es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La técnica de register forwarding habilita una serie de cambios(buses) que se añaden al cauce para permitir que los resultados de una etapa pasen como entradas a la etapa donde son necesarias.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La reorganizacion del código y la introducción de instrucciones no permite evitar dependencias de datos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retrasar la fase de decisión saltar/no saltar de las instrucciones de salto condicional contribuye a mejorar el rendimiento del procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuantas más etapas tenga un cauce, más instrucciones se estarán ejecutando en distintas fases y más posibilidades se presentan de que existan riesgos entre ellas.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes modos de direccionamento es menos preferible para un procesador de 32 bits y con tamaño de instrucción de 32 bits?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> registro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indexado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> indirecto a través de registro.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> directo (o absoluto)</label></li>
</ul>
</li>
<li>
<p>La conexión entre un dispositivo de E/S y el procesador mediante bus:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es difícil de expandir.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Permite conectar en paralelo varios dispositivos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere mucha circuitería.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere multiplexores y demultiplexores para las señales de datos.</label></li>
</ul>
</li>
<li>
<p>El fragmento de código ensamblador de un microprocesador de 8 bits:<br><code>lds IOBuf  ; Apuntar puntero pila a ...área mem.intermedia<br>ldx Count    ; Inicializar x-contador<br>poll lda a Status; Leer estado en A<br>bpl poll ; Signo (A) != 1 =&gt; repetir<br>lda a Data   ; Leer dato en A<br>psh a       ; transferir dato a pila<br>dex         ; decrementar contador x<br>bne poll    ; Seguir leyendo si x!=0<br></code><br> Corresponde a:<br></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Entrada programada con consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada sin consulta de estado. </label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Entrada programada sin consulta de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Salida programada con consulta de estado.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones sobre el benchmark SPEC CPU es falsa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La última versión es SPEC CPU2006 V1.2 de 2011.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se cronometran unos 12 tests de enteros (CINT2006) y unos 17 tests de punto flotante (CFP2006).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se usa como referencia un computador UltraSPARC II 300MHz, y para cada test se calcula el cociente entre el tiempo de ejecución en el computador a testear y en el de referencia.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El resultado final es la media aritmética de las (12 ó 17) velocidades, bien sea de enteros ó de punto flotante (SPECint2006 ó SPECfp2006).</label></li>
</ul>
</li>
<li>
<p>¿En qué generación, dentro de la historia de los computadores digitales, aparecieron la microprogramación, la segmentación de cauce, la memoria cache, los S.O. multiusuario y la memoria virtual?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 2a generación (1955-65).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 3a generación (1965-75).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 4a generación (1975-85).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Esas innovaciones se repartieron a lo largo de varias generaciones, no sólo una.</label></li>
</ul>
</li>
<li>
<p>Respecto a tamaños de tipos integrales en x86 y x86-64, la excepción es que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>int</code> pasa de 4 B (x86) a 8 B (x86-64).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>long int</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>long long</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>Con el repertorio IA32, para sumar <code>%eax</code> y <code>%ebx</code> dejando el resultado en <code>%ecx</code> se podría hacer lo siguiente:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %eax, %ebx, %ecx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>lea (%eax, %ebx, 1), %ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %ecx, [%eax, %ebx]</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>lea %ecx, %ebx, %eax</code></label></li>
</ul>
</li>
<li>
<p>Cuál de las instrucciones máquina siguientes es incorrecta en x86-64:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>testl %edx, %edx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>movl %r8, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movl (%rdi, %rcx, 4), %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>addq $1, %rcx</code></label></li>
</ul>
</li>
<li>
<p>Si la variable <code>val</code> está almacenada en <code>ebx</code> y la variable <code>x</code> está almacenada en <code>eax</code>, la sentencia <code>val ^= x;</code> se puede traducir a ensamblador como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>xorl %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>xorl %eax, %ebx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>andl %ebx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>testl %eax, %ebx</code></label></li>
</ul>
</li>
<li>
<p>Para poner a 1 el bit 5 del registro <code>%edx</code> sin cambiar el resto de bits podemos usar la instrucción máquina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>and $32, %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>and $0x5, %edx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>or $0b101, %edx</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>or $0x20, %edx</code></label></li>
</ul>
</li>
<li>
<p>Si tenemos un número <code>n</code>, de 64 bits, almacenado en la pareja de registros <code>EDX:EAX</code> (<code>EDX</code> contiene los 32 bits más significativos y <code>EAX</code> los 32 bits menos significativos y queremos realizar la división <code>n / 232</code> entonces:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos quedarnos con <code>EDX</code>, pero sólo en el caso de que <code>n</code> sea un número sin signo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Podemos quedarnos con <code>EDX</code> tanto si <code>n</code> es un número con signo como sin signo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos usar las instrucciones siguientes, pero sólo en el caso de que <code>n</code> sea un número con signo: <br><code>mov $0x100000000, %ecx<br>div %ecx</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Podemos usar las instrucciones siguientes, tanto si <code>n</code> es un número con signo como sin signo: <br><code>mov $0x100000000, %ecx<br>div %ecx</code></label></li>
</ul>
</li>
<li>
<p>¿Dónde está ubicado el primer argumento a una función (suponer código ensamblador cdecl generado por gcc para Linux/x86) inmediatamente después de ejecutar la instrucción call?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%ebp + 0x4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%ebp - 0x4</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>%esp + 0x4</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>%esp - 0x4</code></label></li>
</ul>
</li>
<li>
<p>Dado el código C siguiente:<br><code>struct data {<br> char str[16];<br>};<br>char <em>f(struct data </em>ptr) {<br> return &amp;(ptr-&gt;str[2]);<br>}</code><br>La función se traducirá a ensamblador de x86-64 como:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>leaq 2(%rdi), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movq (,%rdi,2), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>movq 2(%rdi), %rax</code> <br><code>ret</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>leaq (,%rdi,2), %rax</code> <br><code>ret</code></label></li>
</ul>
</li>
<li>
<p>Respecto a requisitos de alineamiento de structs en gcc/IA32 x86 y x86-64, alguna de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> En x86 Linux alinea <code>double</code> a 4x (Windows no).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86 Linux alinea <code>long double</code> a 4x (Windows también).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86-64 Linux alinea <code>double</code> a 8x (Windows también).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> En x86-64 Linux alinea <code>float</code> a 8x (Windows también).</label></li>
</ul>
</li>
<li>
<p>Si la estructura struct <code>a</code> ocupa un espacio de 28 bytes en memoria, ¿cuántos bytes ocupa la siguiente estructura struct <code>b</code> cuando se compila en 64 bits? <br><code>struct b {<br> struct a a1;<br> int i;<br> struct a a2;<br>};</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 24 bytes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 60 bytes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 bytes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 84 bytes.</label></li>
</ul>
</li>
<li>
<p>Respecto a los términos microinstrucción y microcódigo:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Son equivalentes, llamamos microcódigo o microinstrucción a una palabra de la memoria de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una microinstrucción está programada en microcódigo, que es un lenguaje para programar señales de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un microcódigo controla una serie de señales de control relacionadas (por ejemplo, el código <code>000</code> para que la ALU realice la suma), y varios microcódigos juntos forman una microinstrucción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Microcódigo es el contenido de la memoria de control, y una microinstrucción es una palabra de dicha memoria.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es verdadera?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La unidad de control necesita como entrada el registro de estado para poder controlar la ejecución de las instrucciones de salto condicional.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro de instrucción es un registro de propósito específico que contiene la dirección de la siguiente instrucción a ejecutar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las únicas instrucciones en las que algunas de sus fases de ejecución conllevan un acceso a memoria son las instrucciones load y store.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro puntero de pila es un registro de propósito general que suele contener tanto direcciones como datos.</label></li>
</ul>
</li>
<li>
<p>Un procesador con una unidad de control microprogramada tiene una memoria de control de 300 palabras de 100 bits, de las que 200 son diferentes. Si se rediseñara como unidad de control nanoprogramada, ¿qué tamaño ocuparía la nanomemoria que contiene las microinstrucciones completas sin repeticiones?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 20000 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 21600 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 22400 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 30000 bits.</label></li>
</ul>
</li>
<li>
<p>En el pseudocódigo usado para representar las microinstrucciones, la expresión <code>goto f(IR)</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se utiliza para realizar un microsalto condicional en función del registro de estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Realiza una llamada a una microsubrutina.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Salta a una dirección de memoria de control que depende de la instrucción máquina actual.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite saltar a la dirección de memoria de control del principio de un microbucle.</label></li>
</ul>
</li>
<li>
<p>Respecto a la predicción de saltos, alguna de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Si se toma la misma decisión para cada tipo de instrucción, se trata de "predicción estática".</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si la predicción cambia según la historia de ejecución del programa, se trata de "predicción dinámica".</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Para predicción estática, es conveniente decidir que los saltos hacia adelante siempre se cumplen, y hacia atrás no.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Para predicción dinámica, existen, entre otros, algoritmos de dos o cuatro estados, que requieren 1 o 2 bits por instrucción.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de procesamiento segmentado y superescalar, una de las siguientes afirmaciones es falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Idealmente, con el segmentado se intenta ejecutar una instrucción por ciclo, y con el superescalar más de una por ciclo (al combinarlo con segmentado).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> En cualquier procesador resulta ventajoso usar una cola de instrucciones, pero es más importante para uno segmentado (fundamental) que para uno superescalar (conveniente).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Por definición, un procesador superescalar debe tener varias unidades funcionales (más de una).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Implícitamente, se presupone que un procesador superescalar emitirá más de una instrucción por ciclo.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de interfaz de dispositivo, controlador(a), puerto de E/S:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> La controladora o interfaz contiene los puetos necesarios para utilizar el dispositivo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada puerto o interfaz es una línea de comunicación con el procesador. El conjunto de ellos forma el controlador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El puerto, o interfaz, contiene los controladores necesarios para comunicar el dispositivo con el procesador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El interfaz contiene las controladoras necesarias para conectar los puertos con el procesador.</label></li>
</ul>
</li>
<li>
<p>Respecto a los conceptos de procesador de E/S, canal de E/S, dispositivos de E/S:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un procesador o canal tiene un repertorio de instrucciones específico para manejar los dispositivos de E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada canal es una línea de comunicación entre el procesador y un dispositivo de E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Al conjunto de conexiones entre el procesador y los dispositivos se le denomina canal de E/S (de ese ordenador).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La pregunta es capciosa, el procesador no es E/S, son otros dos componentes von Neumann distintos (ALU+UC).</label></li>
</ul>
</li>
<li>
<p>La E/S programada:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Mejora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU tiene el control de toda la operación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Mejora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU es más rápida que el controlador de interrupciones y la interfaz del periférico.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Empeora las prestaciones globales del sistema respecto a la E/S por interrupciones porque una .instrucción de transferencia individual de datos con la interfaz del periférico (por ej. IN, OUT) es más lenta en E/S programada que en E/S por interrupciones.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Empeora las prestaciones globales del sistema respecto a la E/S por interrupciones porque la CPU debe encargarse de la sincronización con la interfaz del periférico haciendo una espera activa.</label></li>
</ul>
</li>
<li>
<p>Una puerta <code>AND</code> con 16 entradas conectada a un bus de direcciones de 16 bits, con todos los bits negados excepto <code>A10</code> y <code>A6</code>, permite seleccionar un dispositivo (con CS activa en alta) en la dirección:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xFDDF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xFBBF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0x0220</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0x0440</code></label></li>
</ul>
</li>
<li>
<p>Un computador con 15 líneas de direcciones tiene 3 módulos de memoria de 213 palabras y utiliza E/S mapeada en memoria. ¿Cuál es el número máximo de periféricos que pueden conectarse, si cada uno de ellos utiliza 8 direcciones?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 210.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 212.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 211.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 213.</label></li>
</ul>
</li>
<li>
<p>Un procesador accede en el instante de tiempo <code>t</code> a una posición de memoria <code>d(t)</code>. Poco tiempo después (en el instante de tiempo <code>t+k</code>) accede a la posición anterior <code>d(t)-1</code>. Esos dos accesos son un ejemplo de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Localidad espacial.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Localidad temporal.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No tiene nombre, ese tipo de localidad con incremento negativo (<code>d(t)-1</code>) no se ha estudiado en clase.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No es una localidad, esa condición no guarda relación con el concepto de localidad.</label></li>
</ul>
</li>
<li>
<p>Una jerarquía de memoria consta de una cache de con una tasa de aciertos del 92% y 4 ns de tiempo de acceso y una memoria principal con una tasa de aciertos del 100% y 100 ns de tiempo de acceso. ¿Cuál es el tiempo promedio estimado de acceso a memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 6 ns.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8 ns.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 10 ns.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 12 ns.</label></li>
</ul>
</li>
<li>
<p>Una SRAM de <code>1Mx4bit</code> (4Mbit) puede venir organizada en 2048 filas, dedicando por tanto al decodificador de columnas:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 6 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 7 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 9 bits.</label></li>
</ul>
</li>
<li>
<p>Un sistema basado en un microprocesador con un bus de datos de <code>n</code> bits y un bus de direcciones de 16 bits direcciona la memoria por palabras de <code>n</code> bits y dispone de una memoria SRAM formada por dos módulos de <code>16 K x n</code> cada uno. ¿Qué porcentaje del mapa de memoria está ocupado por la SRAM?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 12.5%</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 25%</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 50%</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 100%</label></li>
</ul>
</li>
<li>
<p>Un módulo de memoria de 16 GB está formado por varios chips DRAM de <code>1024Mx4</code>. ¿Cuántos chips DRAM necesita el módulo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 4.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 8.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 32.</label></li>
</ul>
</li>
<li>
<p>Una cache de 256 B asociativa por conjuntos de 4-vías con líneas de 16 B tendría:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> 4 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 64 conjuntos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ningún conjunto.</label></li>
</ul>
</li>
<li>
<p>En un sistema con memoria de bytes, ¿cuál sería el tamaño de una línea de cache, si la cache del procesador fuera de 4MB, asociativa por conjuntos de 16-vías, y contuviera 4096 conjuntos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32 B.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 64 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 128 B.</label></li>
</ul>
</li>
<li>
<p>El conjunto de todos los atributos de un sistema que son visibles para el programador y son necesarios para programar en lenguaje máquina se denomina:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Arquitectura del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Conjunto de componentes físicos del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Organización del computador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Repertorio de instrucciones máquina.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes afirmaciones es cierta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La arquitectura Von Neumann de los computadores tradicionales consiste en tener almacenados los datos separados de las instrucciones en memorias distintas.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El registro de estado (flags) es un registro de propósito específico cuyo contenido puede ser visto directa o indirectamente por el usuario mediante el uso de ciertas instrucciones específicas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La unidad de control necesita como entrada el registro contador de programa para saber cuál es la instrucción que debe ejecutar a continuación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El registro de direcciones de memoria es un registro de propósito general que puede contener tanto direcciones como datos.</label></li>
</ul>
</li>
<li>
<p>En una máquina little-endian con memoria de bytes y representación en complemento a dos que permite accesos a memoria de tamaño byte (1 B), media palabra (2 B) y palabra (4 B), se almacenan a partir de la posición <code>0xCAFEBAB0</code> cuatro palabras con valores -1, -2, -3, -4. ¿Qué se obtendría al consultar la media palabra de la posición <code>0xCAFEBABE</code>?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> -1.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> -4.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No se puede saber, faltan datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>Se pretende almacenar una palabra de 4 B en una memoria de bytes a partir de una dirección determinada. ¿Cuál de las siguientes es válida, si la palabra debe quedar alineada?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>0xFACEB00C</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xDEADBEEF</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xCAFEBABE</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>0xABADF00D</code></label></li>
</ul>
</li>
<li>
<p>En una arquitectura de acumulador, la instrucción <code>LOAD X</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Transfiere el contenido del registro <code>X</code>a la memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Suma <code>M(x)</code> al acumulador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Transfiere el contenido del acumulador a la posición de memoria <code>X</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Transfiere el contenido a la posición de memoria <code>X</code> al acumulador.</label></li>
</ul>
</li>
<li>
<p>Una instrucción máquina del tipo <code>Add M,R</code> podría formar parte del repertorio de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina de acumulador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una máquina con arquitectura R/R.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una máquina con arquitectura M/M.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes no es un modo de direccionamiento IA-32?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Registro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Cache.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inmediato.</label></li>
</ul>
</li>
<li>
<p>Un bus se compone de:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de datos y líneas de dirección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de alimentación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Líneas de estado y líneas de control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Líneas de control/estado, líneas de dirección y líneas de datos.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes no es un tipo de bus?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Secuencial.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Paralelo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sistema.</label></li>
</ul>
</li>
<li>
<p>Si en un bus de direcciones de 32 bits se decodifica parcialmente la dirección de un dispositivo de 32 posiciones usando 22 bits, ¿cuántas veces aparecerá repetido en el mapa de memoria?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 10.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 32.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 1024.</label></li>
</ul>
</li>
<li>
<p>Para obtener una única velocidad comparativa final, el benchmark SPEC CPU combina las velocidades de ejecución de una serie de tests, respecto a un ordenador de referencia, usando la media:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Aritmética.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Geométrica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Armónica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ponderada.</label></li>
</ul>
</li>
<li>
<p>El primer computador electrónico basaba su funcionamiento en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Tubos de vacío.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Circuitos integrados LSI.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Amplifficadores operacionales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Núcleos de ferrita.</label></li>
</ul>
</li>
<li>
<p>En Linux IA-32, si gcc usa la instrucción <code>leave</code> se puede asegurar que en ese punto del programa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Correspondería emitir la secuencia de salida <code>pop/ret</code>, pero <code>leave</code> hace lo mismo y ocupa menos espacio</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ya no hay registros salva-invocado que recuperar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ya no hay variables locales que destruir.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ya no se hacen llamadas anidadas y por tanto no hay parámetros que ocupen espacio en pila.</label></li>
</ul>
</li>
<li>
<p>Usando el repertorio IA-32, para intercambiar el valor de 2 variables (por ejemplo <code>A: .int 1</code> y <code>B: .int 2</code>) se pueden usar:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Dos instrucciones <code>mov</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una instrucción <code>mov</code> y una instrucción <code>lea</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 3 <code>mov</code>, no menos (se le llama "intercambio circular").</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 4 <code>mov</code>, no menos (debido a la arquitectura R/M).</label></li>
</ul>
</li>
<li>
<p>Respecto a registros base e índice en IA-32, la excepción es que:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EBP</code> no puede ser registro base.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>EBP</code> no puede ser registro índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>ESP</code> no puede ser registro base.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>ESP</code> no puede ser registro índice.</label></li>
</ul>
</li>
<li>
<p>El registro <code>SP / ESP / RSP</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro transparente al suuario y contiene la instrucción que se está ejecutando.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Es un registro de propósito específico y contiene la dirección de la cima de la pila.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro transparente al usuario y contiene la dirección de memoria a la que se está accediendo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es un registro de propósito específico y contiene la dirección de la siguiente instrucción a ejecutar.</label></li>
</ul>
</li>
<li>
<p>Diferencias gcc Linux IA-32/x86-64: marcar la respuesta falsa:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los enteros largos (<code>long</code>) pasan de 32 a 64 bits.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los punteros (<code>void*</code>) pasan de 32 a 64 bits.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El tipo <code>double</code> pasa de 4 B a 8 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>long double</code> pasa de 10/12 B a 16 B.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes fragmentos de código deja en <code>%eax</code>un resultado distinto a los otros tres fragmentos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> <code>mov $-1, %edx</code><br><code>sub %eax, %edx</code><br><code>mov %edx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>not %eax</code><br><code>add $1, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>xor %edx, %edx</code><br><code>sub %eax, %edx</code><br><code>mov %edx, %eax</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>neg %eax</code></label></li>
</ul>
</li>
<li>
<p>Si <code>A</code> y <code>B</code> son dos enteros almacenados respectivamente en <code>%eax</code> y <code>%ebx</code>, ¿cuál de las siguientes implementaciones de:<br><code>if(!A &amp;&amp; !B){... then part ...}</code> es incorrecta?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>or %ebx, %eax</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true:</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>cmp $0, %eax</code><br><code>jne not_true</code><br><code>cmp $0, %ebx</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>test %ebx, %eax</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>test %eax, %%eax</code><br><code>jne not_true</code><br><code>test %ebx, %ebx</code><br><code>jne not_true</code><br><code>...then part...</code><br><code>not_true</code><br><code>...</code></label></li>
</ul>
</li>
<li>
<p>Dada la siguiente declaración en lenguaje C, una estructura de este tipo podría ocupar en un sistema Linux IA-32 o bien en uno x86- 64 un total de:<br><code>struct a {<br> int i;<br> double d;<br> char c;<br> short s;<br>};</code></p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 18 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 20 B.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 22 B.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 24 B.</label></li>
</ul>
</li>
<li>
<p>En un sistema Linux x86-64, ¿cuál de las siguientes expresiones es equivalente a la expresión <code>C (x[2] + 4)[3]</code>? Suponer que previamente se ha declarado <code>int **x</code>.</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> <code>*((*(x + 16)) + 28)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>*(((*x) + 2) + 7)</code></label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> <code>(*(*(x + 2) + 4) + 3)</code></label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> <code>*((*(x + 2) + 4) + 3)</code></label></li>
</ul>
</li>
<li>
<p>Una unidad de control microprogramada se denomina "con secuenciamiento de microinstrucciones explícito" según tenga o no tenga:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> ROM/PLA para traducir el codop en dirección de inicio de microprograma (<code>goto f(IR)</code>).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un multiplexor para seleccionar la fuente de la dirección de la memoria de control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un micro-contador de programa atacando a las líneas de dirección de la memoria de control.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Microcódigo de decodificación que analice el codop bit a bit de izquierda a derecha.</label></li>
</ul>
</li>
<li>
<p>Dado un camino de datos concreto, un posible formato de microprogramación se caracteriza como horizontal o vertical según tenga más o menos (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Codificación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solapamiento.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Microbifurcaciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Longitud relativa de microinstrucción.</label></li>
</ul>
</li>
<li>
<p>Motivos que impiden que la ganancia (aceleración) de un cauce
    segmentado sea ideal (señalar la respuesta falsa): - ( ) Registros de acoplo (coste de la segmentación). - ( ) Fragmentación desigual (duración desigual de etapas). - ( ) Riegos (hazards). - (x) Cola de instrucciones (precaptación).</p>
</li>
<li>
<p>La técnica de "adelanto de registros" (register forwarding) en un cauce segmentado se usa para limitar el impacto de los riesgos:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Estructurales.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Organizativos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> De control.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> (Por dependencias) de datos.</label></li>
</ul>
</li>
<li>
<p>Las técnicas principales de E/S son (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> DMA (por acceso directo).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S programada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> E/S cableada (hardwired).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> IRQ (por interrupciones).</label></li>
</ul>
</li>
<li>
<p>Para determinar la causa de una interrupción se pueden usar las siguientes técnicas: (señalar la respuesta falsa):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Múltiples líneas de interrupción: <code>INT1#, INT2#, ...</code>.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Línea de reconocimiento <code>INTA#</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Consulta de estado, o polling.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Interreupciones vectorizadas.</label></li>
</ul>
</li>
<li>
<p>Utilizar una cache en el mismo chip del procesador:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Aumenta el tamaño de los bloques enviados entre cache y procesador.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Reduce los tiempos de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reduce el tamaño del bus.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Aumenta la tasa de aciertos.</label></li>
</ul>
</li>
<li>
<p>En un sistema Linux IA-32, ¿cuántos enteros se podrían almacenar en una línea de cache, si la cache del procesador fuera de 4 KB, asociativa por conjuntos de 4-vías, y contuviera 4 conjuntos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> 16.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 32.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> 64.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> 128.</label></li>
</ul>
</li>
<li>
<p>La cache con correspondencia directa se puede considerar como un caso límite de la asociativa por conjuntos, en donde:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Sólo hay 1 línea por conjunto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo hay 1 palabra por bloque.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sólo hay 1 conjunto por cache.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.addClass('text-warning');
            } else {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });
});</script>
</div>
</body>
</html>