\documentclass[12pt]{article}

\input{../../_assets/preambulo.tex}


\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    
    \input{../../_assets/portada}
    \portadaExamen{etsiitA4.jpg}{Estructura de\\Computadores\\Examen VIII}{EC. Examen VIII}{MidnightBlue}{-8}{28}{2025}{}

    \begin{description}
        \item[Asignatura] Estructura de Computadores.
        \item[Curso Académico] 2024/25.
        \item[Grado] Doble Grado en Ingeniería Informática y Matemáticas.
        \item[Grupo] Único.
        \item[Profesor] Ignacio Rojas Ruíz.
        \item[Descripción] Examen de la Convocatoria Ordinaria.
        \item[Fecha] 16 de enero del 2025.
        \item[Duración] 2 horas.
    
    \end{description}
    \newpage


    % ------------------------------------
    
    \section*{Examen Tipo Test (3 puntos)}
    \noindent
    Todas las preguntas son de elección simple sobre 4 alternativas.
    Cada respuesta vale $\nicefrac{3}{30}$ si es correcta, 0 si está en blanco o claramete tachada, $\nicefrac{-1}{30}$ si es errónea.
    \begin{ejercicio}
        En la práctica ``media'' se pide como ejercicio previo sumar una lista de $N$ enteros SIN signo produciendo un resultado \verb|.quad| (doble precisión). El programa esqueleto ofrecido (\verb|suma.s|, que suma la conocida lista de 9 elementos en simple precisión) no es válido. Se podría comprobar imprimiendo el resultado SIN signo y usando como contraejemplo las siguientes listas:
        \begin{enumerate}[label=\alph*)]
            \item \verb|0x4000 0000| y \verb|0x8000 0000| (el usuario piensa que sus datos NO tienen signo).
            \item \verb|0x8000 0000| y \verb|0xC000 0000|.
            \item Ninguna de las dos.
            \item Ambas.
        \end{enumerate}
    \end{ejercicio}

    \begin{ejercicio}
        En la práctica ``media'' se pide como ejercicio previo sumar una lista de $N$ enteros CON signo produciendo un resultado \verb|.quad| (doble precisión). El programa esqueleto ofrecido (\verb|suma.s|) no es válido. Se podría comprobar imprimiendo el resultado CON signo, y usando como contraejemplo las siguientes listas:
        \begin{enumerate}[label=\alph*)]
            \item $-1$ y $-1$ (el usuario piensa que sus datos tienen signo).
            \item \verb|0x4000 0000| y \verb|0x4000 0000|.
            \item Ninguna de las dos.
            \item Ambas.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Suponga una memoria cache con las siguientes propiedades:
        \begin{itemize}
            \item Tamaño: 512 bytes.
            \item Política de reemplazo: LRU\@.
            \item Estado inicial: vacía (todas las líneas válidas).
        \end{itemize}
        Suponga que para la siguiente secuencia de direcciones enviadas a la cache: 0, 10, 16, 20, 30, 32, 40, 50, 60, 64, la tasa de acierto es $0.50$. ¿Cuál es el tamaño de la línea de la cache?
        \begin{enumerate}[label=\alph*)]
            \item 4 bytes.
            \item 8 bytes.
            \item 16 bytes.
            \item Ninguo de los anteriores.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Sea un computador de 64 bits con una memoria cache L1 para datos de 32 KB y líneas de 64 bytes asociativa por conjuntos de 8 vías. Dado el siguiente fragmento de código:
        \begin{minted}[numbers=none]{c}
            char v[262144];
            for(i = 0; i < 262144; i+=8)
               v[i] = 9;
        \end{minted}
        ¿Cuál será la tasa de fallos aproximada que se obtiene en la ejecución del bucle anterior?
        \begin{enumerate}[label=\alph*)]
            \item $\nicefrac{1}{2}$ (mitad aciertos, mitad fallos).
            \item $\nicefrac{1}{4}$ (un fallo por cada 4 accesos).
            \item $\nicefrac{1}{8}$ (un fallo por cada 8 accesos).
            \item 1 (todo son fallos).
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        En una bomba como las estudiadas en prácticas, del tipo:
        \begin{minted}[escapeinside=\~\~, numbers=none]{asm}
            ~0x080486e8:~ call 0x8048524 <strncmp>
            ~0x080486ed:~ test %eax, %eax
            ~0x080486ef:~ je 0x80486f6 <main+134>
            ~0x080486f1:~ call 0x8048604 <boom>
            ~0x080486f6:~ ...
        \end{minted}
        la contraseña correcta es:
        \begin{enumerate}[label=\alph*)]
            \item el \verb|string| almacenado  a partir de \verb|0x8048524|.
            \item el \verb|string| almacenado  a partir de \verb|0x80486f6|.
            \item el \verb|string| almacenado  a partir de \verb|0x8048604|.
            \item Ninguna de las otras opciones.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        La lectura de un elemento de un array anidado neceita los siguientes accesos a memoria:
        \begin{enumerate}[label=\alph*)]
            \item Ninguna respuesta es correcta.
            \item Uno.
            \item Dos.
            \item Tres.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿En qué registro está contenido el último dato (o instrucción) leído de memoria, o el dato que se va a escribir en memoria?
        \begin{enumerate}[label=\alph*)]
            \item Registro de propósito general.
            \item MAR\@.
            \item PC\@.
            \item MBR/MDR\@.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuál de las siguientes instrucciones máquina es incorrecta en \verb|x86-64|?
        \begin{enumerate}[label=\alph*)]
            \item \verb|movl %r8, %eax|.
            \item \verb|testl %edx, %edx|.
            \item \verb|addq $1, %rcx|.
            \item \verb|movl (%rdi,%rcx,4), %edx|.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Si \verb|ECX| vale 0, la instrucción \verb|adc $0, %ecx|:
        \begin{enumerate}[label=\alph*)]
            \item Pone \verb|CF=0|.
            \item Pone \verb|CF=1|.
            \item No cambia \verb|CF|.
            \item Cambia \verb|CF|.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Dada la siguiente definición de datos:
        \begin{minted}[escapeinside=\~\~, numbers=none]{asm}
            lista: .int ~0x10000000, 0x50000000~,
                        ~0x10000000, 0x20000000~
            longlista: .int (.-lista)~/~4
            resultado: .quad ~0x123456789ABCDEF~
            formato: .ascii "suma=%llu=%llx hex\n\0"
        \end{minted}
        la instrucción \verb|movl longlista %ecx| copia el siguiente valor:
        \begin{enumerate}[label=\alph*)]
            \item 16.
            \item 8.
            \item 32.
            \item 4.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Dado el siguiente fragmento de progama:
        \begin{minted}[numbers=none]{asm}
            .section .data
            lista: .int 1,2,0x10,3,-3
            longlista: .int .-lista
            resultadO: .quad 0

            .section .text
            main: .global main

            xor %edx, %edx
            mov $-12, %eax
            cltd
            mov longlista, %ebx

            idiv %ebx
        \end{minted}
        El valor de \verb|%rdx| después de la división es:
        \begin{enumerate}[label=\alph*)]
            \item \verb|0x00000004|.
            \item Ninguna de las soluciones es correcta.
            \item \verb|0x00000010|.
            \item \verb|0xFFFFFFF4|.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Considere la siguiente declaración:
        \begin{minted}[numbers=none]{c++}
            struct rec{
               int i;
               int j;
               int a[10];
               int *p;
            };
        \end{minted}
        y una función \verb|void f(struct rec *r);| cuyo código en ensamblador es:
        \begin{minted}[numbers=none]{asm}
            mov 0x4(%rdi), %eax
            add (%rdi), %eax
            cltq # RAX <- (long) EAX
            lea 0x8(%rdi,%rax,4), %rax
            mov %rax, 0x30(%rdi)
            retq
        \end{minted}
        ¿Cuál es el código C de la función \verb|f|?
        \begin{enumerate}[label=\alph*)]
            \item \verb|r->a[r->i] = r->j;|
            \item \verb|r->p = &(r->a[r->i + r->j]);|
            \item \verb|r->a[r->i] = r->a[r->j];|
            \item \verb|r->p = (int *)(long)(r->a[r->i] + r->a[r->j]);|
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Dada una matriz de $5\times 3$ enteros, una posible traducción a ensamblador de una función que devuelve el elemento $i,j$: 
        \begin{minted}[numbers=none]{c}
            int elemn(int A[5][3], size_t i, size_t j);
        \end{minted}
        es:
        \begin{enumerate}[label=\alph*)]
            \item 
                \begin{minted}[numbers=none]{asm}
                   movq (%rdi, %rsi, 4), %rax
                   movl (%rax, %rdx, 4), %eax
                   ret
                \end{minted}
            \item 
                \begin{minted}[numbers=none]{asm}
                   leaq (%rdx, %rsi, 4), %rax
                   movl (%rdi, %rax, 4), %eax
                   ret
                \end{minted}
            \item 
                \begin{minted}[numbers=none]{asm}
                   leaq (%rsi, %rsi, 4), %rax
                   leaq (%rdx, %rdx, 2), %rdx
                   addq %rdx, %rax
                   movl (%rad, %rdi), %eax
                   ret
                \end{minted}
            \item 
                \begin{minted}[numbers=none]{asm}
                   leaq (%rsi, %rsi, 2), %rax
                   leaq (%rdi, %rax, 4), %rax
                   movl (%rax, %rdx, 4), %eax
                   ret
                \end{minted}
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuál de las siguientes afirmaciones acerca de la memoria es FALSA?
        \begin{enumerate}[label=\alph*)]
            \item La memoria dinámica usa señales de control \verb|RAS#| y \verb|CAS#|.
            \item Las celdas de memoria dinámica están construidas por un transistor y un condensador.
            \item Las celdas de memoria estática tienen que ser constantemente refrescadas.
            \item La memoria estática se emplea en las caches L1 y L2.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Al traducir la sentencia C
        \begin{minted}[numbers=none]{c}
            r->i = val;
        \end{minted}
        \verb|gcc| genera el código ASM:
        \begin{minted}[numbers=none]{asm}
            movl %edx, 12(%rax)
        \end{minted}
        Se puede deducir que:
        \begin{enumerate}[label=\alph*)]
            \item \verb|i| es un entero que vale 12.
            \item El desplazamiento de \verb|i| en \verb|*r| es 12.
            \item \verb|r| es un puntero que apunta a la posición de memoria 12.
            \item \verb|val| es un entero que vale 12.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuántas líneas de dirección (patillas) son necesarias para direccionar un chip de memoria DRAM de $4096\times 8$?
        \begin{enumerate}[label=\alph*)]
            \item 6.
            \item 10.
            \item 11.
            \item 12.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuántas líneas de dirección son necesarias en una memoria RAM de 256 K palabras dinámica? ¿Y estática?
        \begin{enumerate}[label=\alph*)]
            \item 9/9.
            \item 9/18.
            \item 18/9.
            \item 18/18.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Qué necesitamos para construir una memoria de 1K$\times 8$ bits?
        \begin{enumerate}[label=\alph*)]
            \item 64 memorias de $128\times 1$ bits.
            \item 8 memorias de $512\times 2$ bits.
            \item 8 memorias de $256\times 4$ bits y un decodificador de 2 a 4.
            \item 4 memorias de $512\times 2$ bits y un decodificador de 2 a 4.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        En un sistema con memoria direccionable por bytes, ¿cuál sería el tamaño de una línea de cache, si la cache del procesador fuera de 4 MB, asociativa por conjuntos de 16 vías, y contuviera 4096 conjuntos?
        \begin{enumerate}[label=\alph*)]
            \item 16 B.
            \item 32 B.
            \item 64 B.
            \item 128 B.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        En una caché con 64 bytes de longitud de línea, ¿cuál es la dirección de memoria de la primera palabra de la línea de caché que contenga la posición de memoria \verb|0xBEE3DE72|?
        \begin{enumerate}[label=\alph*)]
            \item \verb|0xBEE3DE6E|.
            \item \verb|0xBEE3DE70|.
            \item \verb|0xBEE3DE40|.
            \item \verb|0x0EE3DE72|.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Se definen:
        \begin{minted}[numbers=none]{c}
            struct S1 { int i[3]; char c[3]; doble v } p[3];
            union U1 { int i[3]; char c[3]; doble v } q[3];
        \end{minted}
        Indica qué afirmación es correcta.
        \begin{enumerate}[label=\alph*)]
            \item \verb|q| tiene un tamaño mayor que \verb|p|.
            \item \verb|q| no está alineada y \verb|p| sí.
            \item \verb|p| tiene un tamaño mayor que \verb|q|.
            \item \verb|p| y \verb|q| tienen el mismo tamaño.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Dada la siguiente estructura:
        \begin{minted}[numbers=none]{c}
            struct W { int j[2]; char s[8]; short a[4]; long *j; };
        \end{minted}
        Indique el tamaño total de la estructura:
        \begin{enumerate}[label=\alph*)]
            \item 30.
            \item 32.
            \item 26.
            \item 28.
        \end{enumerate}
    \end{ejercicio}
    F\begin{ejercicio}
        Dado un vector \verb|W| de enteros (en \verb|%rdx|), y un índice \verb|j| (en \verb|%rcx|). La expresión \verb|*(W+j-4)| podría traducirse en una sentencia de ensamblador, del tipo:
        \begin{enumerate}[label=\alph*)]
            \item \verb|movl -16(%rdx, %rcx, 4), %eax|
            \item \verb|leaq 4(%rdx, %rdx, 4), %rax|
            \item \verb|movl (%rdx, %rcx, 4), %eax|
            \item \verb|movl -12(%rdx, %rcx, 4), %eax|
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Para leer un dato de un array multi-nivel, se requieren acceder a memoria
        \begin{enumerate}[label=\alph*)]
            \item Ninguna respuesta es correcta.
            \item Tres accesos a memoria.
            \item Dos accesos a memoria.
            \item Una sola vez.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Dadas las siguientes estructuras:
        \begin{minted}[numbers=none]{c}
           struct W2 { char w[16]; char *c[2] };
           struct W1 { short i; int c; int *j; short *d };
           struct W { struct W2 q[2]; struct W1 z };
        \end{minted}
        Calcule el tamaño necesario para almacenar \verb|W|. Indique el tamaño total de la estructura.
        \begin{enumerate}[label=\alph*)]
            \item Todas las respuestas son incorrectas.
            \item 38.
            \item 40.
            \item 36.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Qué valor contendrá el registro \verb|RDX| tras ejecutar las dos instrucciones siguientes?
        \begin{minted}[numbers=none]{c}
            movq $-1, %rdx
            shr $16, %edx
        \end{minted}
        \begin{enumerate}[label=\alph*)]
            \item \verb|0xFFFF FFFF FFFF 0000|.
            \item \verb|0xFFFF FFFF FFFF FFFF|.
            \item \verb|0x0000 0000 0000 FFFF|.
            \item \verb|0xFFFF FFFF 0000 FFFF|.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuál de las siguientes instrucciones es errónea? (sale mensaje de error al intentar ensamblar):
        \begin{enumerate}[label=\alph*)]
            \item \verb|movb %sil, (%rax)|
            \item \verb|pushq $0xFF|
            \item \verb|movsbw (%rax), %dx|
            \item \verb|movzlq %edx, %rax|
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        Se dispone de un procesador con una frecuencia de reloj de 1 GHz. Se le conecta un dispositivo que genera $100000$ interrupciones por segundo. La rutina de servicio de interrupción ejecuta $500$ instrucciones. El número medio de ciclos por instrucción es 2. ¿Qué porcentaje del tiempo dedica el procesador al dispositivo?
        \begin{enumerate}[label=\alph*)]
            \item 1\%.
            \item 10\%.
            \item 50\%.
            \item 90\%.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Cuántos conjuntos tendría una cache de 256 KB asociativa por conjuntos de 16 vías con línea de 64 bytes?
        \begin{enumerate}[label=\alph*)]
            \item 4.
            \item 16.
            \item 64.
            \item 256.
        \end{enumerate}
    \end{ejercicio}
    \begin{ejercicio}
        ¿Qué componentes necesitamos para construir una memoria de 2K $\times 8$ bits?
        \begin{enumerate}[label=\alph*)]
            \item 64 memorias de $128\times 1$ bits y un decodificador de 4 a 16.
            \item 8 memorias de $512\times 2$ bits y un decodificador de 1 a 2.
            \item 8 memorias de $256\times 4$ bits y un decodificador de 2 a 4.
            \item 16 memorias de $512\times 2$ bits y un decodificador de 2 a 4.
        \end{enumerate}
    \end{ejercicio}

    \newpage
    \setcounter{ejercicio}{0}
    \section*{Examen de Problemas (3 puntos)}
    \begin{ejercicio}[1 punto]
        Una función, \verb|switcher|, tiene la siguiente estructura general (Figura~\ref{fig:switcher_c}). Rellena las líneas en blanco del código C con ayuda del código ensamblador que se adjunta (Figura~\ref{fig:switcher_asm}).
        \begin{figure}[H]
        \begin{minted}{asm}
            movl   8(%ebp), %eax
            cmpl   $7, %eax
            ja     .L2
            jap    *.L7(,%eax,4)
        .L2:
            movl   12(%ebp), %eax
            jmp    .L8
        .L5:
            movl   $4, %eax
            jap    .L8
        .L6:
            movl   12(%ebp), %eax
            xorl   $15, %eax
            movl   %eax, 16(%ebp)
        .L3:
            movl   16(%ebp), %eax
            addl   $112, %eax
            jmp    .L8
        .L4:
            movl   16(%ebp), %eax
            addl   12(%ebp), %eax
            sall   $2, %eax
        .L8:
        .L7:
            .long .L3
            .long .L2
            .long .L4
            .long .L2
            .long .L5
            .long .L6
            .long .L2
            .long .L4
        \end{minted}
        \caption{Código de \texttt{switcher} en ensamblador.}
        \label{fig:switcher_asm}
        \end{figure}
        \begin{figure}[H]
        \begin{minted}{c}
            int switcher(int a, int b, int c)
            {
               int answer;
               switch(a){
                  case ______:   /* Case A */
                     c = ______;
                     /* Fall through */
                  case ______:   /* Case B */
                     answer = ______;
                     break;
                  case ______:   /* Case C */
                  case ______:   /* Case D */
                     answer = ______;
                     break;
                  case ______:   /* Case E */
                     answer = ______;
                     break;
                  default:
                     answer = ______;
               }
               return answer;
            }
        \end{minted}
        \caption{Código C a completar.}
        \label{fig:switcher_c}
        \end{figure}
    \end{ejercicio}
    \begin{ejercicio}[1.25 puntos]
        La siguiente subrutina en C++ (Figura~\ref{sum_c}) implementa la función sumatoria. Al compilar el programa en un sistema de 64 bits da lugar al código ensamblador que podemos ver (Tabla~\ref{tab:sum_asm}). Supongamos que el procesador utiliza una \textbf{caché de correspondencia asociativa por conjuntos} con 8 marcos de bloque, 8 palabras por bloqe y 4 bloques por conjunto. Recuerde que se direcciona a nivel de bytes (1 palabra = 1 byte). El algoritmo de reemplazo es LRU (menos reciementemente usado).
        \begin{itemize}
            \item Simule la ejecución del programa y muestre el contenido de la caché en cada instante (primeras 7 instrucciones).
            \item ¿Cuál es la tasa de acierto de la caché tras la ejecución de las primeras 7 instrucciones del programa?
        \end{itemize}
        Condiciones iniciales:
        \begin{itemize}
            \item \verb|$eax = 0x600d90$|.
            \item \verb|$rbx = 0x600d90$|.
            \item \verb|$edi = 0x3$|.
            \item \verb|$rip = 0x400828$|.
            \item \verb|$rsp = 0x7fffe16e4c18$|.
        \end{itemize}
        \begin{figure}[H]
            \begin{minted}{c++}
                int sum(int x)
                {
                   if (x<2)
                      return x;
                   else
                      return x + sum(x-1);
                }
            \end{minted}
            \caption{Programa en C++.}
            \label{sum_c}
        \end{figure}
        \begin{table}[H]
        \centering
        \begin{tabular}{|c|l|l|l|}
            \hline
            Dirección & Codificación & Instrución & Comentario \\
            \hline
            400828 & 83 ff 01 & \verb|cmp edi, 0x1| & \\
            \hline
            40082b & 53 & \verb|push rbx| & \\
            \hline
            40082c & 89 fb & \verb|mov ebx, edi| & \\
            \hline
            40082e & 7e 0a & \verb|jle 40083a| & \\
            \hline
            400830 & 8d 7b ff & \verb|lea edi, [rbd-1]| & edi = rbx - 1 \\
            \hline
            400833 & e8 f0 ff ff ff & \verb|call 400828| & apila rip y salta\\
            \hline
            400838 & 01 c3 & \verb|add ebx, eax| & \\
            \hline
            40083a & 89 d8 & \verb|mov eax, ebx| & \\
            \hline
            40083c & 5b & \verb|pop rbx| & \\
            \hline
            40083d & c3 & \verb|ret| & \\
            \hline
        \end{tabular}
        \caption{Código ensamblador.}
        \label{tab:sum_asm}
        \end{table}
    \end{ejercicio}
    \begin{ejercicio}[0.75 puntos]
        Configuración de memoria. Partiendo de circuitos DRAM de 1K $\times 1$ bits, dibuje un sistema de memoria direccionable por palabras de 2 bytes, para llegar a direccionar 4 K palabras. Indique la primera y la última dirección en hexadecimal de cada fila de circuitos. Indique el número de patillas del bus de direcciones para la nueva memoria construida.
    \end{ejercicio}
\end{document}

