\newpage
\section{Autómatas Finitos}

\begin{comment}
\begin{tikzpicture}
    \node[state, initial] (q1) {$q_1$};
    \node[state, accepting, right of=q1] (q2) {$q_2$};
    \node[state, right of=q2] (q3) {$q_3$};
    \draw (q1) edge[loop above] node{0} (q1)
    (q1) edge[above] node{1} (q2)
    (q2) edge[loop above] node{1} (q2)
    (q2) edge[bend left, above] node{0} (q3)
    (q3) edge[bend left, below] node{0, 1} (q2);
\end{tikzpicture}
\end{comment}

\begin{ejercicio} \label{ej:1.2.1}
    Considera el siguiente Autómata Finito Determinista (AFD) dado por $M = (Q, A, \delta, q_0, F)$, donde:
    \begin{itemize}
        \item $Q = \{q_0, q_1, q_2\}$
        \item $A = \{0, 1\}$
        \item La función de transición viene dada por:
        \begin{align*}
            \delta(q_0, 0) &= q_1, & \delta(q_0, 1) &= q_0 \\
            \delta(q_1, 0) &= q_2, & \delta(q_1, 1) &= q_0 \\
            \delta(q_2, 0) &= q_2, & \delta(q_2, 1) &= q_2
        \end{align*}
        \item $F = \{q_2\}$
    \end{itemize}
    Describe informalmente el lenguaje aceptado.\\

    Su representación gráfica está en la Figura~\ref{fig:ej:1.2.1}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, accepting, right of=q1] (q2) {$q_2$};

            \draw   (q0) edge[loop above] node{1} (q0)
                    (q0) edge[above, bend left] node{0} (q1)
                    (q1) edge[below, bend left] node{1} (q0)
                    (q1) edge[above] node{0} (q2)
                    (q2) edge[loop above] node{0, 1} (q2);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.1}.}
        \label{fig:ej:1.2.1}
    \end{figure}

    Tenemos que el lenguaje aceptado por el autómata es el conjunto de todas las palabras que contienen
    la cadena $00$ como subcadena. Es decir,
    \begin{align*}
        L = \{u_100u_2 \in \{0, 1\}^* \mid u_1, u_2 \in \{0, 1\}^*\}.
    \end{align*}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.2}
    Dado el AFD de la Figura~\ref{fig:ej:1.2.2}, describir el lenguaje aceptado por dicho autómata.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, accepting, right of=q1] (q2) {$q_2$};

            \draw   (q0) edge[loop above] node{$b$} (q0)
                    (q0) edge[above] node{$a$} (q1)
                    (q1) edge[loop above] node{$b$} (q1)
                    (q1) edge[bend left, above] node{$a$} (q2)
                    (q2) edge[bend left, below] node{$a$} (q1)
                    (q2) edge[loop above] node{$b$} (q2);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.2}.}
        \label{fig:ej:1.2.2}
    \end{figure}

    El lenguaje aceptado por el autómata es el conjunto de todas las palabras que contienen
    un número par de $a$'s. Es decir,
    \begin{align*}
        L = \{u \in \{a, b\}^* \mid n_a(u) \text{\ es par},~n_a(u)>0\},
    \end{align*}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.3}
    Dibujar AFDs que acepten los siguientes lenguajes con alfabeto $\{0, 1\}$:
    \begin{enumerate}
        \item El lenguaje vacío,
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};

                \draw   (q0) edge[loop above] node{0, 1} (q0);
            \end{tikzpicture}
        \end{figure}
        \item El lenguaje formado por la palabra vacía, es decir, $\{\varepsilon\}$,
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial, accepting] (q0) {$q_0$};
                \node[state, right of=q0, error] (E) {$E$};

                \draw   (q0) edge[above] node{0, 1} (E);
                \draw   (E) edge[loop above] node{0, 1} (E);
            \end{tikzpicture}
        \end{figure}
        \item El lenguaje formado por la palabra $01$, es decir, $\{01\}$,
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};
                \node[state, accepting, right of=q1] (q2) {$q_2$};
                \node[state, below of=q1, error] (E) {$E$};

                \draw   (q0) edge[above] node{0} (q1)
                        (q1) edge[above] node{1} (q2);
                \draw   (q0) edge[below] node{1} (E)
                        (q1) edge[left] node{0} (E)
                        (q2) edge[below right] node{0, 1} (E)
                        (E) edge[loop below] node{0, 1} (E);
            \end{tikzpicture}
        \end{figure}
        \item El lenguaje $\{11, 00\}$,
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, above right of=q0] (q1) {$q_1$};
                \node[state, below right of=q0] (q2) {$q_2$};
                \node[state, accepting, right of=q0] (q3) {$q_3$};
                \node[state, right of=q3, error] (E) {$E$};

                \draw   (q0) edge[above] node{1} (q1)
                        (q0) edge[below] node{0} (q2)
                        (q1) edge[above] node{0} (E)
                        (q1) edge[left] node{1} (q3)
                        (q2) edge[left] node{0} (q3)
                        (q2) edge[below] node{1} (E);
                \draw   (E) edge[loop above] node{0, 1} (E);
                \draw   (q3) edge[above left] node{0, 1} (E);
            \end{tikzpicture}
        \end{figure}
        \item El lenguaje $\{(01)^i \mid i \geq 0\}$,
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial, accepting] (q0) {$q_0$};
                \node[state, below right of=q0, error] (E) {$E$};
                \node[state, above right of=E] (q1) {$q_1$};


                \draw   (q0) edge[below] node{0} (q1)
                        (q0) edge[below] node{1} (q2)
                        (q1) edge[left] node{0} (q2)
                        (q1) edge[above, bend right] node{1} (q0)
                        (q2) edge[loop below] node{0, 1} (q2);
            \end{tikzpicture}
        \end{figure}
        \item El lenguaje formado por las cadenas con $0$'s y $1$'s donde el número de unos es divisible por $3$.
        
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial, accepting] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};
                \node[state, right of=q1] (q2) {$q_2$};

                \draw   (q0) edge[loop above] node{0} (q0)
                        (q0) edge[above] node{1} (q1)
                        (q1) edge[loop above] node{0} (q1)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[loop above] node{0} (q2)
                        (q2) edge[below, bend left] node{1} (q0);
            \end{tikzpicture}
        \end{figure}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.4}
    Obtener a partir de la gramática regular $G = (\{S, B\}, \{1, 0\}, P, S)$, con
    \begin{align*}
        P = \left\{
            \begin{aligned}
                S &\to 110B \\
                B &\to 0B \mid 1B \mid \varepsilon
            \end{aligned}
        \right.
    \end{align*}
    un AFND que reconozca el lenguaje generado por esa gramática.

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.4}.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, right of=q1] (q2) {$q_2$};
            \node[state, accepting, right of=q2] (q3) {$q_3$};

            \draw   (q0) edge[above] node{1} (q1)
                    (q1) edge[above] node{1} (q2)
                    (q2) edge[above] node{0} (q3)
                    (q3) edge[loop above] node{0, 1} (q3);
        \end{tikzpicture}
        \caption{Autómata Finito No Determinista del Ejercicio~\ref{ej:1.2.4}.}
        \label{fig:ej:1.2.4}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.5}
    Dada la gramática regular $G = (\{S\}, \{1, 0\}, P, S)$, con
    \begin{align*}
        P = \{S &\to S10, S \to 0\},
    \end{align*}
    obtener un AFD que reconozca el lenguaje generado por esa gramática.\\

    El lenguaje es:
    \begin{equation*}
        L = \{0(10)^n \mid n\in \bb{N}\cup \{0\}\}.
    \end{equation*}

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.5}.
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, below right of=q0, error] (E) {$E$};
            \node[state, accepting, above right of=E] (q1) {$q_1$};

            \draw   (q0) edge[above, bend left] node{0} (q1)
                    (q0) edge[below] node{1} (E)
                    (q1) edge[above, bend left] node{1} (q0)
                    (q1) edge[below] node{0} (E)
                    (E) edge[loop below] node{0, 1} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.5}.}
        \label{fig:ej:1.2.5}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.6}
    Construir un AFND o AFD (dependiendo del caso) que acepte las cadenas $u \in \{0, 1\}^*$ que:
    \begin{enumerate}
        \item AFND\@. Contengan la subcadena $010$.~\label{ej:1.2.6.1}
        
        El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.6.1}.
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};
                \node[state, right of=q1] (q2) {$q_2$};
                \node[state, accepting, right of=q2] (q3) {$q_3$};

                \draw   (q0) edge[above] node{0} (q1)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[above] node{0} (q3)
                        (q3) edge[loop above] node{0, 1} (q3)
                        (q0) edge[loop above] node{0, 1} (q0);
            \end{tikzpicture}
            \caption{Autómata Finito No Determinista del Ejercicio~\ref{ej:1.2.6} apartado~\ref{ej:1.2.6.1}.}
            \label{fig:ej:1.2.6.1}
        \end{figure}
        \item AFND\@. Contengan la subcadena $110$. \label{ej:1.2.6.2}
        
        El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.6.2}.
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};
                \node[state, right of=q1] (q2) {$q_2$};
                \node[state, accepting, right of=q2] (q3) {$q_3$};

                \draw   (q0) edge[above] node{1} (q1)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[above] node{0} (q3)
                        (q3) edge[loop above] node{0, 1} (q3)
                        (q0) edge[loop above] node{0, 1} (q0);
            \end{tikzpicture}
            \caption{Autómata Finito No Determinista del Ejercicio~\ref{ej:1.2.6} apartado~\ref{ej:1.2.6.2}.}
            \label{fig:ej:1.2.6.2}
        \end{figure}
        \item AFD\@. Contengan simultáneamente las subcadenas $010$ y $110$. \label{ej:1.2.6.3}
        
        El estado $q_0$ representa que no se ha empezado ninguna de las subcadenas, y el estado $q_F$ representa que se han encontrado ambas cadenas.
        Hay dos opciones:
        \begin{description}
            \item[Opción 1] Primero se lee $010$ y luego $110$. Son los siguientes estados:
            \begin{itemize}
                \item $q_0$: Estado inicial, no ha empezado la subcadena $010$.
                \item $q_1$: Se ha leído el $0$ de la subcadena $010$.
                \item $q_2$: Se ha leído la subcadena $01$ de la subcadena $010$.
                \item $q_3$: Se ha leído la subcadena $010$. No ha empezado la subcadena $110$.
                \item $q_4$: Se ha leído el $1$ de la subcadena $110$.
                \item $q_5$: Se ha leído la subcadena $11$ de la subcadena $110$.
                \item $q_F$: Se ha leído la subcadena $110$. Se han leído ambas subcadenas.
            \end{itemize}

            \item[Opción 2] Primero se lee $110$ y luego $010$. Son los siguientes estados:
            \begin{itemize}
                \item $q_0$: Estado inicial, no ha empezado la subcadena $110$.
                \item $q_1'$: Se ha leído el $1$ de la subcadena $110$.
                \item $q_2'$: Se ha leído la subcadena $11$ de la subcadena $110$.
                \item $q_3'$: Se ha leído la subcadena $110$. Se ha leído el $0$ de la subcadena $010$. Notemos que en este caso podemos agruparlo, puesto que el último carácter de la subcadena $110$ es el mismo que el primero de la subcadena $010$.
                \item $q_4'$: Se ha leído la subcadena $01$ de la subcadena $010$.
                \item $q_F$: Se ha leído la subcadena $010$. Se han leído ambas subcadenas.
            \end{itemize}
        \end{description}

        El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.6.3}.
        \begin{figure}
            \centering
            \begin{tikzpicture}[node distance=2.2cm]
                \node[state, initial] (q0) {$q_0$};
                \node[state, above right of=q0] (q1) {$q_1$};
                \node[state, right of=q1] (q2) {$q_2$};
                \node[state, right of=q2] (q3) {$q_3$};
                \node[state, right of=q3] (q4) {$q_4$};
                \node[state, right of=q4] (q5) {$q_5$};
                \node[state, accepting, below right of=q5] (qF) {$q_F$};

                \node[state, below right of=q0] (q1p) {$q_1'$};
                \node[state, right of=q1p] (q2p) {$q_2'$};
                \node[state, right of=q2p] (q3p) {$q_3'$};
                \node[state, right of=q3p, xshift=2.5em] (q4p) {$q_4'$};
                
                % Conexiones directas por arriba
                \draw   (q0) edge[above] node{0} (q1)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[above] node{0} (q3)
                        (q3) edge[above] node{1} (q4)
                        (q4) edge[above] node{1} (q5)
                        (q5) edge[above] node{0} (qF)
                        (qF) edge[loop above] node{0, 1} (qF);
                
                % Conexiones directas por abajo
                \draw   (q0) edge[below] node{1} (q1p)
                        (q1p) edge[below] node{1} (q2p)
                        (q2p) edge[below] node{0} (q3p)
                        (q3p) edge[below] node{1} (q4p)
                        (q4p) edge[below] node{0} (qF);

                % Completamos los de arriba
                \draw   (q1) edge[loop above] node{0} (q1)
                        (q2) edge[left] node{1} (q2p)
                        (q3) edge[loop above] node{0} (q3)
                        (q4) edge[bend left, below] node{0} (q3)
                        (q5) edge[loop above] node{1} (q5);

                % Completamos los de abajo
                \draw   (q1p) edge[left] node{0} (q1)
                        (q2p) edge[loop below] node{1} (q2p)
                        (q3p) edge[loop below] node{0} (q3p)
                        (q4p) edge[bend right, above] node{1} (q2p);
                
            \end{tikzpicture}
            \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.6} apartado~\ref{ej:1.2.6.3}.}
            \label{fig:ej:1.2.6.3}
        \end{figure}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.7}
    Construir un AFD que acepte el lenguaje generado por la siguiente gramática:
    \begin{align*}
        S &\to AB, & A &\to aA, & A &\to c, & B &\to bBb, & B &\to b.
    \end{align*}

    El lenguaje generado por la gramática es:
    \begin{align*}
        L = \{a^ncb^{2m+1} \mid n, m \in \bb{N}\cup \{0\}\}.
    \end{align*}

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.7}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, right of=q1, accepting] (q2) {$q_2$};
            \node[state, below of=q1, error] (E) {$E$};

            \draw   (q0) edge[loop above] node{$a$} (q0)
                    (q0) edge[above] node{$c$} (q1)
                    (q0) edge[above] node{$b$} (E)
                    (q1) edge[left] node{$a,c$} (E)
                    (q1) edge[above, bend right] node{$b$} (q2)
                    (q2) edge[above, bend right] node{$b$} (q1)
                    (q2) edge[above] node{$a,c$} (E)
                    (E) edge[loop below] node{$a,b,c$} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.7}.}
        \label{fig:ej:1.2.7}
    \end{figure}

\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.8}
    Construir un AFD que acepte el lenguaje $L \subseteq \{a, b, c\}^*$ de todas las palabras con un número impar de ocurrencias de la subcadena $abc$.

    El autómata tiene los siguientes estados:
    \begin{itemize}
        \item $q_0$: Llevo un número par de ocurrencias de $abc$, y no he empezado la siguiente.
        \item $q_1$: Acabo de empezar una ocurrencia impar de $abc$, llevo solo una $a$.
        \item $q_2$: Estoy en una ocurrencia impar de $abc$, llevo $ab$.
        \item $q_3$: Llevo un número impar de ocurrencias de $abc$, y no he empezado la siguiente.
        \item $q_4$: Acabo de empezar una ocurrencia par de $abc$, llevo solo una $a$.
        \item $q_5$: Estoy en una ocurrencia par de $abc$, llevo $ab$.
    \end{itemize}

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.8}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, right of=q1] (q2) {$q_2$};
            \node[state, below of=q2, accepting] (q3) {$q_3$};
            \node[state, left of=q3, accepting] (q4) {$q_4$};
            \node[state, left of=q4, accepting] (q5) {$q_5$};

            % Conexiones básicas
            \draw   (q0) edge[above] node{$a$} (q1)
                    (q1) edge[above] node{$b$} (q2)
                    (q2) edge[right] node{$c$} (q3)
                    (q3) edge[below] node{$a$} (q4)
                    (q4) edge[below] node{$b$} (q5)
                    (q5) edge[left] node{$c$} (q0);

            % Completamos
            \draw   (q0) edge[loop above] node{$b,c$} (q0)
                    (q1) edge[loop above] node{$a$} (q1)
                    (q1) edge[above, bend right] node{$c$} (q0)
                    (q2) edge[above, bend right] node{$a$} (q1)
                    (q2) edge[below, bend left] node{$b$} (q0)
                    (q3) edge[loop below] node{$b,c$} (q3)
                    (q4) edge[bend right, below] node{$c$} (q3)
                    (q4) edge[loop below] node{$a$} (q4)
                    (q5) edge[bend right, below] node{$a$} (q4)
                    (q5) edge[bend left, above] node{$b$} (q3);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.8}.}
        \label{fig:ej:1.2.8}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.9}
    Sea $L$ el lenguaje de todas las palabras sobre el alfabeto $\{0, 1\}$ que no contienen dos $1$s que estén separados por un número impar de símbolos. Describir un AFD que acepte este lenguaje.

    Sea $u\in L$. Veamos que, a lo sumo, puede tener dos $1$'s. Supongamos por reducción al absurdo que tiene tres $1$'s. Entonces, entre la primera y la segunda hay un número impar de símbolos, y entre la segunda y la tercera hay un número impar de símbolos. Por lo tanto, entre el primer y el tercer $1$ hay:
    \begin{itemize}
        \item Un número par de símbolos antes del segundo $1$.
        \item El segundo $1$.
        \item Un número par de símbolos entre el segundo y el tercer $1$.
    \end{itemize}
    Por tanto, como el número de símbolos entre el primer y el tercer $1$ es impar, entonces $u\notin L$. Por lo tanto, $u$ tiene a lo sumo dos $1$'s.\\

    Por tanto, los estados son:
    \begin{itemize}
        \item $q_0$: No se ha introducido ningún $1$.
        \item $q_{p}$: Se ha introducido un $1$, después de él y antes del siguiente $1$ hay un número par de símbolos.
        \item $q_{i}$: Se ha introducido un $1$, después de él y antes del siguiente $1$ hay un número impar de símbolos.
        \item $q_{2}$: Se han introducido dos $1$'s, y no se ha introducido ningún otro.
        \item $E$: Estado de error.
    \end{itemize}

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.9}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0) {$q_0$};
            \node[state, right of=q0, accepting] (qp) {$q_p$};
            \node[state, right of=qp, accepting] (qi) {$q_i$};
            \node[state, below of=qp, accepting] (q2) {$q_2$};
            \node[state, below of=qi, error] (E) {$E$};

            \draw   (q0) edge[loop below] node{0} (q0)
                    (q0) edge[above] node{1} (qp)
                    (qp) edge[below, bend right] node{0} (qi)
                    (qp) edge[right] node{1} (q2)
                    (qi) edge[above, bend right] node{0} (qp)
                    (qi) edge[right] node{1} (E)
                    (q2) edge[loop left] node{0} (q2)
                    (q2) edge[above] node{1} (E)
                    (E) edge[loop right] node{0, 1} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.9}.}
        \label{fig:ej:1.2.9}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.10}
    Dada la expresión regular $(a + \varepsilon)b^*$, encontrar un AFND asociado y, a partir de este, calcular un AFD que acepte el lenguaje.

    El AFND con transiciones nulas obtenido (siguiendo el algoritmo) es el de la Figura~\ref{fig:ej:1.2.10}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, above right of=q0] (q1) {$q_1$};
            \node[state, below right of=q0] (q2) {$q_2$};
            \node[state, right of=q1] (q3) {$q_3$};
            \node[state, below right of=q3, accepting] (q4) {$q_4$};
            \node[state, right of=q4] (q5) {$q_5$};
            \node[state, right of=q5, accepting] (q6) {$q_6$};

            \draw   (q0) edge[above] node{$\varepsilon$} (q1)
                    (q0) edge[below] node{$\varepsilon$} (q2)
                    (q1) edge[above] node{$a$} (q3)
                    (q2) edge[above, bend right] node{$\veps$} (q4)
                    (q3) edge[above] node{$\varepsilon$} (q4)
                    (q4) edge[above] node{$\varepsilon$} (q5)
                    (q5) edge[above] node{$b$} (q6)
                    (q6) edge[below, bend left] node{$\veps$} (q5);
        \end{tikzpicture}
        \caption{Autómata Finito No Determinista algorítmico del Ejercicio~\ref{ej:1.2.10}.}
        \label{fig:ej:1.2.10}
    \end{figure}

    Podemos simplificar este autómata para que así la transición al AFD sea más sencilla. El autómata simplificado es el de la Figura~\ref{fig:ej:1.2.10.simplified}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0, accepting] (q6) {$q_6$};

            \draw   (q0) edge[above] node{$a, \veps$} (q6)
                    (q6) edge[loop above] node{$b$} (q6);
        \end{tikzpicture}
        \caption{Autómata Finito No Determinista simplificado del Ejercicio~\ref{ej:1.2.10}.}
        \label{fig:ej:1.2.10.simplified}
    \end{figure}

    A partir de este autómata simplificado, obtenemos el AFD de la Figura~\ref{fig:ej:1.2.10.afd}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0q6) {$\{q_0, q_6\}$};
            \node[state, right of=q0q6, accepting] (q6) {$q_6$};
            \node[state, right of=q6, error] (E) {$E$};

            \draw   (q0q6) edge[above] node{$a,b$} (q6)
                    (q6) edge[loop above] node{$b$} (q6)
                    (q6) edge[above] node{$a$} (E)
                    (E) edge[loop above] node{$a,b$} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.10}.}
        \label{fig:ej:1.2.10.afd}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.11}
    Obtener una expresión regular para el lenguaje complementario al aceptado por la gramática
    \begin{align*}
        S &\to abA \mid B \mid baB \mid \varepsilon, & A &\to bS \mid b, & B &\to aS.
    \end{align*}
    \begin{observacion}
        Construir un AFD asociado.
    \end{observacion}

    Esta gramática es lineal por la derecha. Algorítmicamente, obtenemos el autómata de la Figura~\ref{fig:ej:1.2.11_L} para el lenguaje generado por $S$, $\cc{L}(S)$.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            % Estados: abA, bA, A, B, baB, aB, B, veps, bS, S, b, aS, S
            \node[state, initial] (S) {$[S]$};
            \node[state, right of=S] (abA) {$[abA]$};
            \node[state, right of=abA] (bA) {$[bA]$};
            \node[state, right of=bA] (A) {$[A]$};
            \node[state, below of=abA] (B) {$[B]$};
            \node[state, below of=B] (baB) {$[baB]$};
            \node[state, right of=baB] (aB) {$[aB]$};
            \node[state, above of=S, accepting] (veps) {$[\varepsilon]$};
            \node[state, below of=A] (bS) {$[bS]$};
            \node[state, right of=A] (b) {$[b]$};
            \node[state, right of=B] (aS) {$[aS]$};

            \draw   (S) edge[above] node{$\veps$} (abA)
                    (abA) edge[above] node{$a$} (bA)
                    (bA) edge[above] node{$b$} (A)
                    (S) edge[above] node{$\veps$} (B)
                    (S) edge[below] node{$\veps$} (baB)
                    (baB) edge[above] node{$b$} (aB)
                    (aB) edge[above] node{$a$} (B)
                    (S) edge[left] node{$\veps$} (veps)
                    (A) edge[left] node{$\veps$} (bS)
                    (A) edge[below] node{$\veps$} (b)
                    (b) edge[above] node{$b$} (veps)
                    (bS) edge[above] node{$b$} (S)
                    (B) edge[above] node{$\veps$} (aS)
                    (aS) edge[below] node{$a$} (S);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del lenguaje $\cc{L}(S)$ del Ejercicio~\ref{ej:1.2.11}.}
        \label{fig:ej:1.2.11_L}
    \end{figure}

    Ahora, tendríamos que eliminar las transiciones nulas para poder así aplicar el algoritmo para hallar la expresión regular. Esto no es sencillo, por lo que vamos a intentar obtener de forma directa el AFD\@. Para ello, la gramática dada genera el mismo lenguaje que las siguientes reglas de producción, donde hemos eliminado la variable $B$:
    \begin{align*}
        S &\to abA \mid aS \mid baaS \mid \varepsilon, & A &\to bS \mid b
    \end{align*}

    Eliminamos ahora la variable $A$:
    \begin{align*}
        S &\to abbS \mid abb \mid aS \mid baaS \mid \varepsilon
    \end{align*}

    Veamos ahora que la regla $S \to abb$ no es relevante, ya que podemos obtenerla a partir de $S \to abbS$ y $S \to \varepsilon$. Por tanto, la gramática dada inicialmente genera el mismo lenguaje que si estas fuesen las reglas de producción:
    \begin{align*}
        S &\to abbS \mid aS \mid baaS \mid \varepsilon
    \end{align*}

    Por tanto, vemos que:
    \begin{equation*}
        \cc{L}(G)=\{abb, a, baa\}^*.
    \end{equation*}

    En consecuencia, la expresión regular asociada a $\cc{L}(G)$ es:
    \begin{equation*}
        (abb + a + baa)^*
    \end{equation*}

    El AFND asociado a esta expresión regular es el de la Figura~\ref{fig:ej:1.2.11_L_AFND}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0) {$q_0$};
            \node[state, right of=q0] (q20) {$q_{20}$};
            \node[state, above of=q20] (q10) {$q_{10}$};
            \node[state, below of=q20] (q30) {$q_{30}$};
            \node[state, right of=q10] (q11) {$q_{11}$};
            \node[state, right of=q11] (q12) {$q_{12}$};
            \node[state, right of=q12] (q13) {$q_{13}$};
            \node[state, right of=q20] (q21) {$q_{21}$};
            \node[state, right of=q30] (q31) {$q_{31}$};
            \node[state, right of=q31] (q32) {$q_{32}$};
            \node[state, right of=q32] (q33) {$q_{33}$};

            \draw   (q0) edge[above] node{$\veps$} (q10)
                    (q0) edge[above] node[pos=0.8]{$\veps$} (q20)
                    (q0) edge[above] node{$\veps$} (q30)
                    (q10) edge[above] node{$a$} (q11)
                    (q11) edge[above] node{$b$} (q12)
                    (q12) edge[above] node{$b$} (q13)
                    (q13) edge[above] node{$\veps$} (q0)
                    (q20) edge[above] node{$a$} (q21)
                    (q21) edge[above, bend right] node{$\veps$} (q0)
                    (q30) edge[below] node{$b$} (q31)
                    (q31) edge[below] node{$a$} (q32)
                    (q32) edge[below] node{$a$} (q33)
                    (q33) edge[below] node{$\veps$} (q0);
        \end{tikzpicture}
        \caption{AFND asociado a $\cc{L}(G)$ del Ejercicio~\ref{ej:1.2.11}.}
        \label{fig:ej:1.2.11_L_AFND}
    \end{figure}

    Convirtiendo este autómata en un AFD, obtenemos el de la Figura~\ref{fig:ej:1.2.11_L_AFD}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0_q10_q20_q30) {$q_0q_{10}q_{20}q_{30}$};
            \node[state, right of=q0_q10_q20_q30, accepting, xshift=5em] (q11_q21_q0_q10_q20_q30) {$q_{11}q_{21}q_{0}q_{10}q_{20}q_{30}$};
            \node[state, right of=q11_q21_q0_q10_q20_q30, xshift=5em] (q12_q31) {$q_{12}q_{31}$};
            \node[state, below of=q0_q10_q20_q30] (q31) {$q_{31}$};
            \node[state, below of=q11_q21_q0_q10_q20_q30] (q32) {$q_{32}$};
            \node[state, below of=q12_q31, error] (E) {$E$};

            \draw   (q0_q10_q20_q30) edge[above] node{$a$} (q11_q21_q0_q10_q20_q30)
                    (q0_q10_q20_q30) edge[left] node{$b$} (q31)
                    (q11_q21_q0_q10_q20_q30) edge[above] node{$b$} (q12_q31)
                    (q11_q21_q0_q10_q20_q30) edge[loop below] node{$a$} (q11_q21_q0_q10_q20_q30)
                    (q12_q31) edge[below, bend right] node{$b$} (q0_q10_q20_q30)
                    (q12_q31) edge[above] node{$a$} (q32)
                    (q31) edge[above] node{$a$} (q32)
                    (q31) edge[bend right, above] node{$b$} (E)
                    (q32) edge[above] node{$a$} (q0_q10_q20_q30)
                    (q32) edge[above] node{$b$} (E)
                    (E) edge[loop above] node{$a,b$} (E);
        \end{tikzpicture}
        \caption{AFD asociado a $\cc{L}(G)$ del Ejercicio~\ref{ej:1.2.11}.}
        \label{fig:ej:1.2.11_L_AFD}
    \end{figure}

    Para que buscar la expresión regular del lenguaje complementario de $\cc{L}(G)$ sea más cómoda, cambiaremos la notación de cada estado.
    El AFD del lenguaje complementario de $\cc{L}(G)$ es el de la Figura~\ref{fig:ej:1.2.11_L_comp}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0_q10_q20_q30) {$p_0$};
            \node[state, right of=q0_q10_q20_q30, xshift=5em] (q11_q21_q0_q10_q20_q30) {$p_1$};
            \node[state, right of=q11_q21_q0_q10_q20_q30, xshift=5em, accepting] (q12_q31) {$p_2$};
            \node[state, below of=q0_q10_q20_q30, accepting] (q31) {$p_3$};
            \node[state, below of=q11_q21_q0_q10_q20_q30, accepting] (q32) {$p_4$};
            \node[state, below of=q12_q31, error, accepting] (E) {$E$};

            \draw   (q0_q10_q20_q30) edge[above] node{$a$} (q11_q21_q0_q10_q20_q30)
                    (q0_q10_q20_q30) edge[left] node{$b$} (q31)
                    (q11_q21_q0_q10_q20_q30) edge[above] node{$b$} (q12_q31)
                    (q11_q21_q0_q10_q20_q30) edge[loop below] node{$a$} (q11_q21_q0_q10_q20_q30)
                    (q12_q31) edge[below, bend right] node{$b$} (q0_q10_q20_q30)
                    (q12_q31) edge[above] node{$a$} (q32)
                    (q31) edge[above] node{$a$} (q32)
                    (q31) edge[bend right, above] node{$b$} (E)
                    (q32) edge[above] node{$a$} (q0_q10_q20_q30)
                    (q32) edge[above] node{$b$} (E)
                    (E) edge[loop above] node{$a,b$} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del lenguaje $\ol{\cc{L}(G)}$ del Ejercicio~\ref{ej:1.2.11}.}
        \label{fig:ej:1.2.11_L_comp}
    \end{figure}

    Buscamos ahora una expresión para $\ol{\cc{L}(G)}$. Resolvemos el siguiente sistema:
    \begin{equation*}
        \begin{cases}
            p_0 &= ap_1 + bp_3\\
            p_1 &= ap_1 + bp_2\\
            p_2 &= ap_4 + bp_0 + \varepsilon\\
            p_3 &= ap_4 + bE + \varepsilon\\
            p_4 &= ap_0 + bE + \varepsilon\\
            E &= aE + bE + \varepsilon
        \end{cases}
    \end{equation*}

    De la última ecuación, obtenemos que $E = (a+b)^*$. El sistema queda:
    \begin{equation*}
        \begin{cases}
            p_0 &= ap_1 + bp_3\\
            p_1 &= ap_1 + bp_2\\
            p_2 &= ap_4 + bp_0 + \varepsilon\\
            p_3 &= ap_4 + b(a+b)^* + \varepsilon\\
            p_4 &= ap_0 + b(a+b)^* + \varepsilon
        \end{cases}
    \end{equation*}

    Sustituyendo $p_4$, obtenemos:
    \begin{equation*}
        \begin{cases}
            p_0 &= ap_1 + bp_3\\
            p_1 &= ap_1 + bp_2\\
            p_2 &= a[ap_0 + b(a+b)^* + \varepsilon] + bp_0 + \varepsilon = (aa+b)p_0 + ab(a+b)^* + a+\veps\\
            p_3 &= a[ap_0 + b(a+b)^* + \varepsilon] + b(a+b)^* + \varepsilon = aap_0 + (a+\veps)(b(a+b)^* + \veps)\\
        \end{cases}
    \end{equation*}

    Tenemos que:
    \begin{equation*}
        p_1 = ap_1 + bp_2 = a^*bp_2
        = a^*b[(aa+b)p_0 + ab(a+b)^* + a+\veps]
    \end{equation*}

    Sustituyendo, tenemos que:
    \begin{align*}
        p_0 &= a[a^*b[(aa+b)p_0 + ab(a+b)^* + a+\veps]] + b[aap_0 + (a+\veps)(b(a+b)^* + \veps)] =\\
        &= a^+b(aa+b)p_0 + a^+bab(a+b)^* + a^+ba + a^+b + baap_0 + b(a+\veps)(b(a+b)^* + \veps) =\\
        &= [a^+b(aa+b)+baa]p_0 + a^+bab(a+b)^* + a^+ba + a^+b + b(a+\veps)(b(a+b)^* + \veps) \AstIg\\
        & \AstIg [a^+b(aa+b)+baa]^*[a^+bab(a+b)^* + a^+ba + a^+b + b(a+\veps)(b(a+b)^* + \veps)]
    \end{align*}
    donde en $(\ast)$ hemos aplicado el Lema de Arden.
    Por tanto, la expresión regular asociada a $\ol{\cc{L}(G)}$ es:
    \begin{equation*}
        [a^+b(aa+b)+baa]^*[a^+bab(a+b)^* + a^+ba + a^+b + b(a+\veps)(b(a+b)^* + \veps)]
    \end{equation*}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.12}
    Dar expresiones regulares para los lenguajes sobre el alfabeto $\{a, b\}$ dados por las siguientes condiciones:
    \begin{enumerate}
        \item Palabras que no contienen la subcadena $a$,
        \begin{equation*}
            b^*
        \end{equation*}
        \item Palabras que no contienen la subcadena $ab$.
        \begin{equation*}
            b^*a^*
        \end{equation*}
        \item \label{ej:1.2.12_3}
        Palabras que no contienen la subcadena $aba$.
        
        Este lenguaje viene descrito por el autómata de la Figura~\ref{fig:ej:1.2.12_3}.
        \begin{figure}
            \centering
            \begin{tikzpicture}
                \node[state, initial, accepting] (q0) {$q_0$};
                \node[state, right of=q0, accepting] (q1) {$q_1$};
                \node[state, right of=q1, accepting] (q2) {$q_2$};
                \node[state, right of=q2, error] (q3) {$E$};

                \draw   (q0) edge[above] node{$a$} (q1)
                        (q1) edge[above] node{$b$} (q2)
                        (q2) edge[above] node{$a$} (q3)
                        (q0) edge[loop above] node{$b$} (q0)
                        (q1) edge[loop above] node{$a$} (q1)
                        (q2) edge[below, bend left] node{$b$} (q0)
                        (q3) edge[loop above] node{$a,b$} (q3);
            \end{tikzpicture}
            \caption{AFD del lenguaje del Ejercicio~\ref{ej:1.2.12} apartado~\ref{ej:1.2.12_3}.}
            \label{fig:ej:1.2.12_3}
        \end{figure}

        Obtenemos la expresión regular asociada al lenguaje del autómata de la Figura~\ref{fig:ej:1.2.12_3}.
        \begin{equation*}
            \begin{cases}
                q_0 &= bq_0 + aq_1 + \varepsilon\\
                q_1 &= aq_1 + bq_2 + \varepsilon\\
                q_2 &= bq_0 + aE + \varepsilon\\
                E &= aE + bE = (a+b)E + \emptyset
            \end{cases}
        \end{equation*}

        Usando el Lema de Arden, obtenemos que $E=\emptyset(a+b)^*=\emptyset$. Sustituyendo, obtenemos:
        \begin{equation*}
            \begin{cases}
                q_0 &= bq_0 + aq_1 + \varepsilon\\
                q_1 &= aq_1 + bq_2 + \varepsilon\\
                q_2 &= bq_0 + a\emptyset + \varepsilon = bq_0 + \varepsilon
            \end{cases}
        \end{equation*}

        Sustituyendo $q_2$, obtenemos:
        \begin{equation*}
            \begin{cases}
                q_0 &= bq_0 + aq_1 + \varepsilon\\
                q_1 &= aq_1 + b(bq_0 + \varepsilon) + \varepsilon\\
            \end{cases}
        \end{equation*}

        Usando el Lema de Arden, obtenemos que:
        \begin{equation*}
            q_1 = a^*[b(bq_0 + \varepsilon) + \varepsilon]
        \end{equation*}

        Sustituyendo en la primera ecuación, tenemos que:
        \begin{align*}
            q_0 &= bq_0 +aa^*[b(bq_0 + \varepsilon) + \varepsilon] + \veps=\\
            &= bq_0 + a^+[bbq_0 + b + \varepsilon] + \veps =\\
            &= (b+a^+bb)q_0 + a^+[b + \varepsilon] + \veps \AstIg\\
            &\AstIg (b+a^+bb)^*[a^+(b + \varepsilon)+\varepsilon]
        \end{align*}
        donde en $(\ast)$ hemos aplicado el Lema de Arden.
        Por tanto, la expresión regular asociada al lenguaje del autómata de la Figura~\ref{fig:ej:1.2.12_3} es:
        \begin{equation*}
            (b+a^+bb)^*[a^+(b + \varepsilon)+\varepsilon]
        \end{equation*}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Determinar si el lenguaje generado por la siguiente gramática es regular:
    \begin{align*}
        S &\to AabB, & A &\to aA \mid bA \mid \varepsilon, & B &\to Bab \mid Bb \mid ab \mid b.
    \end{align*}
    En caso de que lo sea, encontrar una expresión regular asociada.\\

    Es directo ver que el lenguaje generado por la gramática tiene como expresión regular asociada:
    \begin{align*}
        (a+b)^*ab(ab+b)^+.
    \end{align*}

    Por tanto, el lenguaje es regular.
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.14}
    Sobre el alfabeto $A = \{0, 1\}$ realizar las siguientes tareas:
    \begin{enumerate}
        \item \label{ej:1.2.14.1}
        Describir un autómata finito determinista que acepte todas las palabras que contengan a $011$ o a $010$ (o las dos) como subcadenas.
        
        Tenemos los siguientes estados:
        \begin{itemize}
            \item \ul{$q_0$}: No se ha empezado ninguna subcadena.
            \item \ul{$q_1$}: Se ha empezado una subcadena deseada. Tengo el carácter $0$.
            \item \ul{$q_2$}: Se continúa la subcadena deseada. Tengo los caracteres $01$.
            \item \ul{$q_3$}: Se ha encontrado la subcadena deseada. Tengo los caracteres $011$ o $010$.
        \end{itemize}

        El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.14.1}.
        \begin{figure}
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};
                \node[state, right of=q1] (q2) {$q_2$};
                \node[state, accepting, right of=q2] (q3) {$q_3$};

                \draw   (q0) edge[above] node{0} (q1)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[above] node{0,1} (q3)
                        (q1) edge[loop above] node{0} (q1)
                        (q0) edge[loop above] node{1} (q0)
                        (q3) edge[loop above] node{0,1} (q3);
            \end{tikzpicture}
            \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.14} apartado~\ref{ej:1.2.14.1}.}
            \label{fig:ej:1.2.14.1}
        \end{figure}
        
        \item \label{ej:1.2.14.2}
        Describir un autómata finito determinista que acepte todas las palabras que empiecen o terminen (o ambas cosas) por $01$.
        
        Tenemos los siguientes estados:
        \begin{itemize}
            \item \ul{$q_0$}: No hemos leído nada.
            \item \ul{$q_1$}: Hemos empezado con un $0$, por lo que puede comenzar por $01$ (o terminar por $01$).
            \item \ul{$q_2$}: Hemos empezado con $01$, por lo que ya no hay más restricciones.
            \item \ul{$q_3$}: No hemos empezado por $01$, por lo que ha de terminar por $01$.
            \item \ul{$q_4$}: Ha de terminar por $01$, y estamos en $0$, por lo que si introduce un $1$ puede terminar.
            \item \ul{$q_5$}: Ha de terminar por $01$, y acabamos de leer $01$, por lo que podemos terminar.
        \end{itemize}

        El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.14.2}.
        \begin{figure}
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, above right of=q0] (q1) {$q_1$};
                \node[state, right of=q1, accepting] (q2) {$q_2$};
                \node[state, below right of=q0] (q3) {$q_3$};
                \node[state, right  of=q3] (q4) {$q_4$};
                \node[state, accepting, right of=q4] (q5) {$q_5$};

                % Uniones directas
                \draw   (q0) edge[above] node{0} (q1)
                        (q0) edge[above] node{1} (q3)
                        (q1) edge[above] node{1} (q2)
                        (q2) edge[loop above] node{0,1} (q2)
                        (q3) edge[above] node{0} (q4)
                        (q4) edge[above] node{1} (q5);
                
                % Completamos autómata
                \draw   (q1) edge[left] node{0} (q4)
                        (q3) edge[loop below] node{1} (q3)
                        (q4) edge[loop above] node{0} (q4)
                        (q5) edge[above, bend right] node{0} (q4)
                        (q5) edge[below, bend left] node{1} (q3);
            \end{tikzpicture}
            \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.14} apartado~\ref{ej:1.2.14.2}.}
            \label{fig:ej:1.2.14.2}
        \end{figure}

        \item Dar una expresión regular para el conjunto de las palabras en las que hay dos ceros separados por un número de símbolos que es múltiplo de $4$ (los símbolos que separan los ceros pueden ser ceros y puede haber otros símbolos delante o detrás de estos dos ceros).
        \begin{equation*}
            (0+1)^*\red{0}\left((0+1)(0+1)(0+1)(0+1)\right)^*\red{0}(0+1)^*
        \end{equation*}
        Notemos que los dos $0$'s en cuestión están marcados en rojo para facilitar la comprensión.
        \item Dar una expresión regular para las palabras en las que el número de ceros es divisible por $4$.
        
        En un primer momento, podríamos pensar en:
        \begin{equation*}
            (1^*01^*01^*01^*01^*)^*
        \end{equation*}
        No obstante, una palabra con $1$'s y sin $0$'s, que es aceptada por el lenguaje, no está contemplada en la expresión regular. La expresión regular correcta es:
        \begin{equation*}
            (1^*01^*01^*01^*0)^*1^*
        \end{equation*}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}~\label{ej:1.2.15}
    Construye una gramática regular que genere el siguiente lenguaje:
    \begin{align*}
        L_1 = \{u \in \{0, 1\}^* \mid \text{el número de $1$'s y de $0$'s es impar}\}.
    \end{align*}

    Tenemos los siguientes estados:
    \begin{itemize}
        \item \ul{$E_{01}$}: Tenemos un error en $0$ y $1$, ya que el número de $0$'s y de $1$'s es par.
        \item \ul{$E_0$}: Tenemos un error en $0$, ya que el número de $0$'s es par. El número de $1$'s es impar.
        \item \ul{$E_1$}: Tenemos un error en $1$, ya que el número de $1$'s es par. El número de $0$'s es impar.
        \item \ul{$X$}: No tenemos errores. El número de $0$'s y de $1$'s es impar.
    \end{itemize}

    La gramática obtenida es $G=(\{E_{01},E_0,E_1,X\}, \{0, 1\}, P, E_{01})$, donde $P$ es:
    \begin{align*}
        E_{01} &\to 0E_1 \mid 1E_0, \\
        E_0 &\to 0X \mid 1E_{01}, \\
        E_1 &\to 0E_{01} \mid 1X, \\
        X &\to 0E_0 \mid 1E_1 \mid \veps
    \end{align*}

\end{ejercicio}

\begin{ejercicio}
    Encuentra una expresión regular que represente el siguiente lenguaje:
    \begin{align*}
        L_2 = \{0^n1^m \mid n \geq 1, m \geq 0, n \text{\ múltiplo de\ } 3 \text{\ y\ } m \text{\ es par}\}.
    \end{align*}

    La expresión regular es:
    \begin{align*}
        (000)^+(11)^*
    \end{align*}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.17}
    Diseña un autómata finito determinista que reconozca el siguiente lenguaje:
    \begin{align*}
        L_3 = \{u \in \{0, 1\}^* \mid \text{el número de $1$'s no es múltiplo de\ } 3 \text{\ y el número de $0$'s es par}\}.
    \end{align*}

    Sean $n_0$ el número de $0$'s y $n_1$ el número de $1$'s.

    Tenemos la siguiente disposición de estados:
    \begin{itemize}
        \item Los estados de arriba representan $n_0 \text{ mod } 2 = 0$.
        \item Los estados de abajo representan $n_0 \text{ mod } 2 = 1$.
        \item Los estados de la primera columna representan $n_1 \text{ mod } 3 = 0$.
        \item Los estados de la segunda columna representan $n_1 \text{ mod } 3 = 1$.
        \item Los estados de la tercera columna representan $n_1 \text{ mod } 3 = 2$.
    \end{itemize}

    El estado $q_{ij}$ representa $n_0 \text{ mod } 2 = i$ y $n_1 \text{ mod } 3 = j$.
    
    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.17}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q00) {$q_{00}$};
            \node[state, right of=q00, accepting] (q01) {$q_{01}$};
            \node[state, right of=q01, accepting] (q02) {$q_{02}$};
            \node[state, below of=q00] (q10) {$q_{10}$};
            \node[state, right of=q10] (q11) {$q_{11}$};
            \node[state, right of=q11] (q12) {$q_{12}$};

            \draw   (q00) edge[above] node{1} (q01)
                    (q01) edge[above] node{1} (q02)
                    (q02) edge[above, bend right] node{1} (q00)
                    (q10) edge[above] node{1} (q11)
                    (q11) edge[above] node{1} (q12)
                    (q12) edge[below, bend left] node{1} (q10)
                    (q00) edge[left] node{0} (q10)
                    (q10) edge[right, bend right] node{0} (q00)
                    (q01) edge[left] node{0} (q11)
                    (q11) edge[right, bend right] node{0} (q01)
                    (q02) edge[left] node{0} (q12)
                    (q12) edge[right, bend right] node{0} (q02);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.17}.}
        \label{fig:ej:1.2.17}
    \end{figure}
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.18}
    Dar una expresión regular para el lenguaje aceptado por el autómata de la Figura~\ref{fig:ej:1.2.18}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0) {$q_0$};
            \node[state, accepting, below right of=q0] (q2) {$q_2$};
            \node[state, above right of=q2] (q1) {$q_1$};

            \draw   (q1) edge[loop above] node{$a$} (q1)
                    (q0) edge[above] node{$a,b$} (q1)
                    (q1) edge[below, bend left] node{$b$} (q2)
                    (q2) edge[below, bend left] node{$b$} (q1)
                    (q2) edge[above] node{$a$} (q0);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.18}.}
        \label{fig:ej:1.2.18}
    \end{figure}

    Establecemos una ecuación por cada uno de los estados. El sistema inicial es:
    \begin{equation*}
        \begin{cases}
            q_0 = \veps + aq_1 + bq_1, \\
            q_1 = aq_1 + bq_2, \\
            q_2 = \veps + aq_0 + bq_1.
        \end{cases}
    \end{equation*}

    Buscamos obtener la expresión regular asociada a $q_1$:
    \begin{align*}
        q_1 &= aq_1 + b + baq_0 +bbq_1=\\
        &= baq_0 + b + (a+bb)q_1\AstIg\\
        &\AstIg (a+bb)^*(baq_0 + b)
    \end{align*}
    donde en $(\ast)$ hemos aplicado el Lema de Arden. Sustituyendo en la ecuación de $q_0$ obtenemos:
    \begin{align*}
        q_0 &= \veps + (a+b)q_1 =\\
        &= \veps + (a+b)(a+bb)^*(baq_0 + b) =\\
        &= \veps + (a+b)(a+bb)^*b + (a+b)(a+bb)^*baq_0 \AstIg\\
        &\AstIg ((a+b)(a+bb)^*ba)^*(\veps + (a+b)(a+bb)^*b)
    \end{align*}
    donde, de nuevo, en $(\ast)$ hemos aplicado el Lema de Arden. Por tanto, la expresión regular asociada al autómata es:
    \begin{align*}
        ((a+b)(a+bb)^*ba)^*(\veps + (a+b)(a+bb)^*b).
    \end{align*}
\end{ejercicio}


\begin{ejercicio} \label{ej:1.2.19}
    Dado el lenguaje
    \begin{align*}
        L = \{u110 \mid u \in \{1, 0\}^*\},
    \end{align*}
    encontrar la expresión regular, la gramática lineal por la derecha, la gramática lineal por la izquierda y el AFD asociado.

    La expresión regular es:
    \begin{align*}
        (0+1)^*110.
    \end{align*}

    La gramática lineal por la derecha es $G=(\{S,A\}, \{0, 1\}, P, S)$, donde $P$ es:
    \begin{align*}
        S &\to 0S \mid 1S \mid A\\
        A &\to 110.
    \end{align*}

    La gramática lineal por la izquierda es $G=(\{S,A\}, \{0, 1\}, P', S)$, donde $P'$ es:
    \begin{align*}
        S &\to X110\\
        X &\to X0 \mid X1 \mid \varepsilon.
    \end{align*}

    El AFD asociado es el de la Figura~\ref{fig:ej:1.2.19}. Sus estados son:
    \begin{itemize}
        \item \ul{$q_0$}: No estoy en la cadena $110$ final.
        \item \ul{$q_1$}: He leído un $1$ de la cadena final.
        \item \ul{$q_2$}: He leído un $11$ de la cadena final.
        \item \ul{$q_3$}: He leído un $110$ de la cadena final.
    \end{itemize}
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial] (q0) {$q_0$};
            \node[state, right of=q0] (q1) {$q_1$};
            \node[state, right of=q1] (q2) {$q_2$};
            \node[state, accepting, right of=q2] (q3) {$q_3$};

            \draw   (q0) edge[above] node{1} (q1)
                    (q1) edge[above] node{1} (q2)
                    (q2) edge[above] node{0} (q3)
                    (q0) edge[loop above] node{0} (q0)
                    (q1) edge[above, bend right] node{0} (q0)
                    (q2) edge[loop above] node{1} (q2)
                    (q3) edge[below, bend left] node{0} (q0)
                    (q3) edge[below, bend left] node[pos=0.9]{1} (q1);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.19}.}
        \label{fig:ej:1.2.19}
    \end{figure}
\end{ejercicio}

\begin{ejercicio}
    Dado un AFD, determinar el proceso que habría que seguir para construir una gramática lineal por la izquierda capaz de generar el Lenguaje aceptado por dicho autómata.\\

    Sea $M=(Q, A, \delta, q_0, F)$ un AFD\@. Como $Q$ es finito, podemos enumerar los estados como $Q=\{q_1, q_2, \ldots, q_n\}$.    
    La Gramática Lineal por la Izquierda asociada es $G=(Q\cup \{S\}, A, P, S)$, donde hemos supuesto $S\notin Q$ debido a nuestra enumeración de los estados. Las reglas de producción son:
    \begin{equation*}
        P=\left\{
            \begin{array}{rcll}
                S &\to& q_i &\qquad \forall q_i\in F\\
                q_i &\to& q_j a &\qquad \forall q_i,q_j\in Q, a\in A \mid \delta(q_j, a)=q_i \\
                q_0 &\to& \veps.
            \end{array}
        \right.
    \end{equation*}
    Notemos que lo que hacemos es invertir el autómata, obtener la gramática lineal por la derecha, y después invertir las reglas de producción de esta última.
\end{ejercicio}

\begin{ejercicio} \label{ej:1.2.21}
    Construir un autómata finito determinista que acepte el lenguaje de todas las palabras sobre el alfabeto $\{0, 1\}$ que no contengan la subcadena $001$.
    Construir una gramática regular por la izquierda a partir de dicho autómata.\\

    Los estados son los siguientes:
    \begin{itemize}
        \item \ul{$q_0$}: No se ha empezado la subcadena $001$
        \item \ul{$q_1$}: Se ha leído un $0$ de la subcadena $001$.
        \item \ul{$q_2$}: Se ha leído un $00$ de la subcadena $001$.
        \item \ul{$E$}: Se ha leído la subcadena $001$, por lo que es el estado de error.
    \end{itemize}

    El autómata obtenido es el de la Figura~\ref{fig:ej:1.2.21}.
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node[state, initial, accepting] (q0) {$q_0$};
            \node[state, right of=q0, accepting] (q1) {$q_1$};
            \node[state, right of=q1, accepting] (q2) {$q_2$};
            \node[state, error, right of=q2] (E) {$E$};

            \draw   (q0) edge[below] node{0} (q1)
                    (q0) edge[loop above] node{1} (q0)
                    (q1) edge[below] node{0} (q2)
                    (q1) edge[above, bend right] node{1} (q0)
                    (q2) edge[loop above] node{0} (q0)
                    (q2) edge[below] node{1} (E)
                    (E) edge[loop above] node{0,1} (E);
        \end{tikzpicture}
        \caption{Autómata Finito Determinista del Ejercicio~\ref{ej:1.2.21}.}
        \label{fig:ej:1.2.21}
    \end{figure}
    
    Respecto a la gramática regular por la izquierda, usando el algoritmo descrito en el apartado anterior, tenemos que la gramática es $G=(Q\cup \{S\}, \{0, 1\}, P, S)$, donde $P$ es:
    \begin{align*}
        P=\left\{
            \begin{array}{rcll}
                S &\to& q_0 \mid q_1 \mid q_2,\\
                q_0 &\to& q_0 1 \mid q_1 1 \red{\mid \veps}\\
                q_1 &\to& q_0 0,\\
                q_2 &\to& q_1 0 \mid q_2 0,\\
                E &\to& E0 \mid E1 \mid q_2 1,
            \end{array}
        \right.
    \end{align*}
\end{ejercicio}

\begin{ejercicio}
    Sea $B_n = \{a^k \mid k \text{\ es múltiplo de\ } n\}$. Demostrar que $B_n$ es regular para todo $n$.\\

    Fijado $n\in \bb{N}$, la expresión regular correspondiente es:
    \begin{align*}
        (a\overbrace{\cdots }^{n \text{\ veces}}a)^* = (a^n)^*
    \end{align*}

    Equivalentemente, usando la notación de las expresiones regulares de UNIX, la expresión regular sería:
    \begin{equation*}
        (a\{n\})^*
    \end{equation*}
\end{ejercicio}

\begin{ejercicio}
    Sea $A$ un alfabeto. Decimos que $u\in A^*$ es un prefijo de $v\in A^*$ si existe $w\in A^*$ tal que $uw = v$. Decimos que $u$ es un prefijo propio de $v$ si además $u \neq v$ y $u \neq \varepsilon$. Demostrar que si $L$ es regular, también lo son los lenguajes siguientes:
    \begin{enumerate}
        \item $\text{NOPREFIJO}(L) = \{u \in L \mid \text{ningún prefijo propio de } u \text{ pertenece a } L\}$,
        
        Como $L$ es regular, existe un AFD $M=(Q, A, \delta, q_0, F)$ tal que $L=\cc{L}(M)$. Construimos un AFD $M'=(Q\cup \{E\}, A, \delta', q_0, F)$,
        donde $E$ es un estado de error ($E\notin Q$) y $\delta'$ es:
        \begin{equation*}
            \begin{cases}
                \delta'(q, a) = \delta(q, a)&\qquad \forall q\in Q\setminus F, a\in A\\
                \delta'(q, a) = E&\qquad \forall q\in F, a\in A\\
                \delta'(E, a) = E&\qquad \forall a\in A
            \end{cases}
        \end{equation*}

        Demostramos mediante doble inclusión que $\text{NOPREFIJO}(L)=\cc{L}(M')$.
        \begin{description}
            \item[$\subseteq)$] Sea $u\in \text{NOPREFIJO}(L)$. Entonces, por definición de $\text{NOPREFIJO}(L)$, $u\in L$. Por tanto, $\exists q\in F$ tal que $\delta^{\ast}(q_0, u)=q$. Para ver que $u\in \cc{L}(M')$, basta ver que $(\delta')^{\ast}(q_0, u)\in F$.

            Como $u$ no tiene prefijos propios en $L$, entonces $\delta^{\ast}(q_0, u')\notin F$ para todo prefijo propio $u'$ de $u$; es decir, en los pasos de cálculo desde $q_0$ hasta $\delta^{\ast}(q_0, u)$ no se pasa por ningún estado final. Por tanto, como en esos casos $\delta'=\delta$, entonces $\delta^{\ast}(q_0, u)=q\in F$, por lo que $u\in \cc{L}(M')$.

            \item[$\supseteq)$] Sea $u\in \cc{L}(M')$. En primer lugar, tenemos que $(\delta')^{\ast}(q_0, u)\in F$. Veamos ahora que los pasos de cálculo desde $q_0$ hasta $(\delta')^{\ast}(q_0, u)$ leyendo $u$ no son ninguno finales.
            
            Si alguno de ellos fuese final (si $u$ tuviese algún prefijo propio $v\in L$), entonces desde él pasaríamos a $E$, y de este estado no final no saldríamos, llegando a contradicción. Por tanto, $u$ no tiene prefijos propios pertenecientes a $L$. Además, como en estos casos $\delta'=\delta$, tenemos que $\delta^{\ast}(q_0, u)\in F$, luego $u\in L$. De esta forma, $u\in \text{NOPREFIJO}(L)$.
        \end{description}
        
        \item $\text{NOEXTENSION}(L) = \{u \in L \mid u \text{ no es un prefijo propio de ninguna palabra de } L\}$.
        
        Como $L$ es regular, existe un AFD $M=(Q, A, \delta, q_0, F)$ tal que $L=\cc{L}(M)$. Construimos un AFD $M'=(Q, A, \delta, q_0, F')$, donde:
        \begin{equation*}
            F'=\{q\in F\mid \delta^{\ast}(q,u)\notin F,\forall u\in A^*\}
        \end{equation*}

        Demostramos mediante doble inclusión que $\text{NOEXTENSION}(L)=\cc{L}(M')$.
        \begin{description}
            \item[$\subseteq)$] Sea $u\in \text{NOEXTENSION}(L)$. Entonces, por definición de $\text{NOEXTENSION}(L)$, $u\in L$. Por tanto, $\exists q\in F$ tal que $\delta^{\ast}(q_0, u)=q$. Para ver que $u\in \cc{L}(M')$, basta ver que $q\in F'$. 
            
            Supongamos por reducción al absurdo $q\notin F'$. Entonces, $\exists v\in A^*$ tal que $\delta^{\ast}(q, v)\in F$. Pero entonces, $\delta^{\ast}(q_0, uv)=\delta^{\ast}(\delta^{\ast}(q_0, u), v)=\delta^{\ast}(q, v)\in F$, por lo que $uv\in L$ y, por tanto, $u$ es prefijo propio de $uv$, lo cual es una contradicción. Por tanto, $q\in F'$ y, por tanto, $u\in \cc{L}(M')$.

            \item[$\supseteq)$] Sea $u\in \cc{L}(M')$. En primer lugar, tenemos que $\delta^{\ast}(q_0, u)=q\in F'\subset F$, luego $u\in L$. Veamos ahora que $u$ no es prefijo propio de ninguna palabra de $L$.
            
            Supongamos por reducción al absurdo que $u$ es prefijo propio de alguna palabra de $L$. Entonces, $\exists v\in A^*\setminus \{\veps\}$ tal que $uv\in L$. Por tanto, $\delta^{\ast}(q_0, uv)\in F$. Pero entonces, $\delta^{\ast}(q_0, uv)=\delta^{\ast}(\delta^{\ast}(q_0, u), v)=\delta^{\ast}(q, v)\in F$.
            No obstante, hemos demostrado entonces que $q\notin F'$, lo cual es una contradicción. Por tanto, $u$ no es prefijo propio de ninguna palabra de $L$ y, por tanto, $u\in \text{NOEXTENSION}(L)$.
        \end{description}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Si $L \subseteq A^*$, define la relación $\equiv$ en $A^*$ como sigue: si $u, v \in A^*$, entonces $u \equiv v$ si y solo si para toda $z \in A^*$, tenemos que $(uz \in L \Leftrightarrow vz \in L)$.
    \begin{enumerate}
        \item Demostrar que $\equiv$ es una relación de equivalencia.
        
        Veamos las tres propiedades de las relaciones de equivalencia:
        \begin{itemize}
            \item \ul{Reflexiva}: Sea $u\in A^*$. Entonces, para todo $z\in A^*$, tenemos trivialmente que $(uz\in L\Leftrightarrow uz\in L)$. Por tanto, $u\equiv u$.
            \item \ul{Simétrica}: Sean $u,v\in A^*$ tales que $u\equiv v$. Entonces, para todo $z\in A^*$, tenemos que $(uz\in L\Leftrightarrow vz\in L)$. Por tanto, para todo $z\in A^*$, tenemos que $(vz\in L\Leftrightarrow uz\in L)$, lo cual implica que $v\equiv u$.
            \item \ul{Transitiva}: Sean $u,v,w\in A^*$ tales que $u\equiv v$ y $v\equiv w$. Entonces, para todo $z\in A^*$, tenemos que $(uz\in L\Leftrightarrow vz\in L)$ y $(vz\in L\Leftrightarrow wz\in L)$. Por tanto, para todo $z\in A^*$, tenemos que $(uz\in L\Leftrightarrow wz\in L)$, lo cual implica que $u\equiv w$.
        \end{itemize}
        Tenemos por tanto que $\equiv$ es una relación de equivalencia.

        \item Calcular las clases de equivalencia de $L = \{a^ib^i \mid i \geq 0\}$.
        
        En este caso, $A=\{a,b\}$.
        La primera clase de equivalencia que encontramos es las palabras que, le añadamos al final lo que le añadamos, no pertenecen al lenguaje. Es decir:
        \begin{equation*}
            [u\in A^* \mid \text{en $u$ hay una $a$ después de una $b$} \qquad \lor\qquad u=a^ib^j,~j>i]
        \end{equation*}
        Por comodidad, ya que $b\notin L$, considerando este representante de clase de equivalencia, notaremos a esta clase de equivalencia con $[b]$.
        Además, para cada $k\in \bb{N}\cup \{0\}$, tenemos:
        \begin{equation*}
            [a_k] =: \{a^{k+j}b^j\mid j\in \bb{N}\cup \{0\}\}
        \end{equation*}

        Veamos en primer lugar que no hay más clases de equivalencia. Dado $u\in A^*$, si $u$ tiene una $a$ después de una $b$, entonces $u\in [b]$. En caso contrario, tenemos $u=a^ib^j$ con $i,j\in \bb{N}\cup \{0\}$.
        \begin{itemize}
            \item Si $j>i$, entonces $u\in [b]$.
            \item Si $j\leq i$, entonces $u\in [a_{i-j}]$.
        \end{itemize}
        Por tanto, tenemos que no hay más clases de equivalencia. Veamos ahora que estas clases de equivalencia son disjuntas.
        \begin{itemize}
            \item Sea $u\in [b]$. Si $u$ tiene una $a$ después de una $b$, entonces de forma directa $\nexists k\in \bb{N}\cup \{0\}$ tal que $u\in [a_k]$, ya que las palabras de estas clase de equivalencia son casos particulares de $a^*b^*$. Por otro lado, si $u=a^ib^j$ con $j>i$, entonces para que sea de la forma $a^{k+j}b^j$ es necesario que $k+j=i$, por lo que $k=i-j<0$, luego $\nexists k\in \bb{N}\cup \{0\}$ tal que $u\in [a_k]$.
            
            En conclusión, vemos que $[b]\cap [a_k]=\emptyset$ para todo $k\in \bb{N}\cup \{0\}$.

            \item Sean $k_1,k_2\in \bb{N}\cup \{0\}$ tales que $k_1\neq k_2$. Supongamos que $[a_{k_1}]\cap [a_{k_2}]\neq \emptyset$. Entonces, $\exists u\in A^*$ tal que $u\in [a_{k_1}]\cap [a_{k_2}]$. Por tanto, tenemos que $u=a^{k_1+j_1}b^{j_1}=a^{k_2+j_2}b^{j_2}$ con $j_1,j_2\in \bb{N}\cup \{0\}$. Igualando las potencias de $a$ y $b$, tenemos que $k_1+j_1=k_2+j_2$ y $j_1=j_2$. Por tanto, $k_1=k_2$, lo cual es una contradicción. Por tanto, $[a_{k_1}]\cap [a_{k_2}]=\emptyset$ para todo $k_1,k_2\in \bb{N}\cup \{0\}$ tales que $k_1\neq k_2$.
        \end{itemize}

        Por tanto, vemos que las clases de equivalencia de $L$ son $[b]$ y $[a_k]$ para todo $k\in \bb{N}\cup \{0\}$. Notemos que:
        \begin{itemize}
            \item $[b]$ es la clase de equivalencia de las palabras que, le añadamos al final lo que le añadamos, no pertenecen al lenguaje. Para cualquier par $u,v\in [b]$, tenemos que, para todo $z\in A^*$, $uz\in L\Leftrightarrow vz\in L$ es cierto por vacuidad, puesto que en ambos casos $uz,vz\notin L$.
            \item $[a_0]$ es la clase de equivalencia de las palabras que pertenecen al lenguaje. Para cualquier par $u,v\in [a_0]$, tenemos que, para todo $z\in A^*$, $uz\in L\Leftrightarrow vz\in L$ es cierto. Tomando $z=\veps$, tenemos que $u=uz,v=vz\in L$; mientras que si $z\neq \veps$, entonces $uz,vz\notin L$.
            \item $[a_k]$ para $k\neq 0$ es la clase de equivalencia de las palabras que tan solo pertenecen al lenguaje al concatenarles $b^k$. Para cualquier par $u,v\in [a_k]$, tenemos que, para todo $z\in A^*$, $uz\in L\Leftrightarrow vz\in L$ es cierto. Tomando $z=b^k$, tenemos que $ub^k,vb^k\in L$; mientras que si $z\neq b^k$, entonces $uz,vz\notin L$.
        \end{itemize}

        \item Calcular las clases de equivalencia de $L = \{a^ib^j \mid i, j \geq 0\}$.
        
        La primera clase de equivalencia que encontramos es las palabras que, le añadamos al final lo que le añadamos, no pertenecen al lenguaje. Es decir:
        \begin{equation*}
            [u\in A^* \mid \text{en $u$ hay una $a$ después de una $b$}]
        \end{equation*}
        Por comodidad, ya que $ba\notin L$, considerando este representante de clase de equivalencia, notaremos a esta clase de equivalencia con $[ba]$. Además, tenemos dos clases de equivalencia más:
        \begin{align*}
            [a] &= \{a^i\mid i\in \bb{N}\cup \{0\}\}\\
            [ab] &= \{a^ib^j\mid i\in \bb{N}\cup \{0\},j\in \bb{N}\}
        \end{align*}
        
        Veamos en primer lugar que no hay más clases de equivalencia. Dado $u\in A^*$, si $u$ tiene una $a$ después de una $b$, entonces $u\in [ba]$. En caso contrario, tenemos $u=a^ib^j$ con $i,j\in \bb{N}\cup \{0\}$.
        \begin{itemize}
            \item Si $j=0$, entonces $u\in [a]$.
            \item Si $j>0$, entonces $u\in [ab]$.
        \end{itemize}
        Por tanto, tenemos que no hay más clases de equivalencia. Veamos ahora que estas clases de equivalencia son disjuntas.
        \begin{itemize}
            \item Sea $u\in [ba]$. Como $u$ tiene una $a$ después de una $b$, entonces de forma directa tenemos que $u\notin [a], [ab]$.
            En conclusión, vemos que $[ba]\cap [a]=[ba]\cap [ab]=\emptyset$.

            \item Sea $u\in [ab]$. Como $u=a^ib^j$ con $i,j\in \bb{N}\cup \{0\}$ con $j\neq 0$, entonces $u\notin [a]$. Por tanto, vemos que $[ab]\cap [a]=\emptyset$.
        \end{itemize}

        Por tanto, vemos que las clases de equivalencia de $L$ son $[ba]$, $[a]$ y $[ab]$; y estas son disjuntas.

        \item Demostrar que $L$ es aceptado por un autómata finito determinista si y solo si el número de clases de equivalencia es finito.
        
        Demostramos mediante doble inclusión.
        \begin{description}
            \item[$\Longrightarrow)$] Supongamos que $L$ es aceptado por un autómata finito determinista. Sea $M=(Q, A, \delta, q_0, F)$ su AFD minimal que acepta $L$.
            Supongamos $u,v\in A^*$ tales que $u\equiv v$. Sean:
            \begin{align*}
                q_u &:= \delta^{\ast}(q_0, u)\in F,\\
                q_v &:= \delta^{\ast}(q_0, v)\in F.
            \end{align*}

            Veamos ahora que $q_u,q_v$ son indistingibles, es decir, $q_u=q_v$.
            \begin{itemize}
                \item Para todo $z\in A^*$, como $u\equiv v$, se tiene que:
                \begin{equation*}
                    uz\in L\Leftrightarrow vz\in L.
                \end{equation*}
    
                Equivalentemente, tenemos que:
                \begin{equation*}
                    \delta^{\ast}(\delta^{\ast}(q_0, u), z)\in F\Longleftrightarrow \delta^{\ast}(\delta^{\ast}(q_0, v), z)\in F
                \end{equation*}

                Es decir:
                \begin{equation*}
                    \delta^{\ast}(q_u, z)\in F\Longleftrightarrow \delta^{\ast}(q_v, z)\in F
                \end{equation*}

                Por tanto, $q_u$ y $q_v$ son indistinguibles; y como el autómata es minimal, $q_u=q_v$.
            \end{itemize}
            
            Por tanto, hemos demostrado que si $u\equiv v$, entonces $\delta^{\ast}(q_0, u)=\delta^{\ast}(q_0, v)$, por lo que el número de clases de equivalencia es menor o igual que el número de estados de $Q$. Como $Q$ es finito, el número de clases de equivalencia también lo es finito.

            \item[$\Longleftarrow)$] Supongamos que el número de clases de equivalencia es finito. Sea el autómata $M=(Q, A, \delta, q_0, F)$, donde:
            \begin{itemize}
                \item $Q$ es el conjunto de clases de equivalencia de $L$,
                \item $q_0=[\varepsilon]$,
                \item $\delta([u], a)=[ua]$. Veamos que está bien definida.
                
                Sea $u,v\in A^*$ tales que $u\equiv v$, y veamos que, para todo $a\in A$, $ua\equiv va$.
                Como $u\equiv v$, para todo $z\in A^*$, tenemos que:
                \begin{equation*}
                    uz\in L\Leftrightarrow vz\in L.
                \end{equation*}

                Por tanto, tomando $z=az'$, con $z'\in L$, tenemos que:
                \begin{equation*}
                    uaz'\in L\Leftrightarrow vaz'\in L.
                \end{equation*}

                Es decir, $ua\equiv va$. Por tanto, $\delta$ está bien definida.
                \item $F=\{[u]\in Q\mid u\in L\}$.
                
                Para ver que $F$ está bien definida, veamos que, si $u\equiv v$, entonces $u\in L\Longleftrightarrow v\in L$.
                Esto es directo tomando $z=\veps$.
            \end{itemize}

            Veamos ahora que $L=\cc{L}(M)$.
            \begin{align*}
                u\in \cc{L}(M)&\Longleftrightarrow \delta^{\ast}(q_0, u)\in F\Longleftrightarrow \delta^{\ast}([\varepsilon], u)\in F\Longleftrightarrow [\veps u]\in F\Longleftrightarrow [u]\in F \Longleftrightarrow \\ &\Longleftrightarrow u\in L
            \end{align*}

        \end{description}
        \item ¿Qué relación existe entre el número de clases de equivalencia y el autómata finito minimal que acepta $L$?
        
        Veamos que el autómata descrito en el apartado anterior es minimal. En primer lugar, hemos de demostrar que no tiene estados inaccesibles.
        \begin{itemize}
            \item Sea $q\in Q$ una clase de equivalencia de $L$. Tomando un representante $u\in q$, tenemos que $\delta^{\ast}(q_0, u)=q$. Por tanto, $q$ es accesible.
        \end{itemize}

        Veamos ahora que no tiene estados indistingibles.
        \begin{itemize}
            \item Sean $q_1,q_2\in Q$ clases de equivalencia distintas de $L$. Tomando representantes $u_1\in q_1,u_2\in q_2$, tenemos que:
            \begin{align*}
                \delta^{\ast}(q_0, u_1)=[u_1]=q_1,\\
                \delta^{\ast}(q_0, u_2)=[u_2]=q_2.
            \end{align*}
            Entonces, como son clases de equivalencia distintas, $u_1\not\equiv u_2$, lo cual implica que $\exists z\in A^*$ tal que $u_1z\in L$ y $u_2z\notin L$ o viceversa. Supongamos sin pérdida de generalidad el primer caso, luego:
            \begin{equation*}
                \exists z\in A^*\mid u_1z\in L\quad \land \quad u_2z\notin L
                \Longleftrightarrow
                \delta^{\ast}(q_0, u_1z)\in F\quad \land \quad \delta^{\ast}(q_0, u_2z)\notin F
            \end{equation*}
            Por tanto, $q_1$ y $q_2$ no son indistinguibles.
        \end{itemize}

        Por tanto, hemos visto que todos los estados de $Q$ son accesibles y no son indistinguibles, por lo que el autómata $M$ del ejercicio anterior es minimal. Por tanto, la relación es que el número de clases de equivalencia es igual al número de estados del autómata finito minimal que acepta $L$.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
    Dada una palabra $u = a_1 \cdots a_n \in A^*$, se llama $\operatorname{Per}(u)$ al conjunto
    \begin{align*}
        \{a_{\sigma(1)}, \ldots, a_{\sigma(n)} \mid \sigma \text{\ es una permutación de\ } \{1, \ldots, n\}\}.
    \end{align*}
    Dado un lenguaje $L$, se llama $\operatorname{Per}(L) = \bigcup\limits_{u \in L} \operatorname{Per}(u)$.
    Dar expresiones regulares y autómatas minimales para $\operatorname{Per}(L)$ en los siguientes casos:
    \begin{enumerate}
        \item $L = (00 + 1)^*$,
        
        Tenemos que:
        \begin{align*}
            \operatorname{Per}(L) &= \{u\in A^*\mid \text{\ $n_0(u)$ es par}\}
        \end{align*}

        Su autómata finito minimal es:
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial, accepting] (q0) {$q_0$};
                \node[state, right of=q0] (q1) {$q_1$};

                \draw   (q0) edge[loop above] node{1} (q0)
                        (q0) edge[above, bend right] node{0} (q1)
                        (q1) edge[loop above] node{1} (q1)
                        (q1) edge[above, bend right] node{0} (q0);
            \end{tikzpicture}
        \end{figure}
        
        Este es de forma directa minimal, puesto que sus dos estados son distinguibles al ser uno final y el otro no. Para obtener la expresión regular, resolvemos el sistema de ecuaciones:
        \begin{align*}
            q_0 &= 1q_0 + 0q_1 + \veps\\
            q_1 &= 1q_1 + 0q_0
        \end{align*}
        De la segunda ecuación, obtenemos $q_1=1^*0q_0$. Sustituyendo en la primera, obtenemos:
        \begin{align*}
            q_0 &= 1q_0 + 0(1^*0q_0) + \veps\\
            q_0 &= 1q_0 + 01^*0q_0 + \veps\\
            q_0 &= (1+01^*0)q_0 + \veps\\
            q_0 &= (1+01^*0)^*
        \end{align*}

        De forma directa, podríamos haber obtenido la siguiente expresión regular:
        \begin{align*}
            1^*(01^*01^*)^*
        \end{align*}
        \item $L = (0 + 1)^*0$,
        
        Tenemos que $\operatorname{Per}(L) = \{u\in A^*\mid n_0(u)>0\}$.
        Su autómata finito minimal es:
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \node[state, initial] (q0) {$q_0$};
                \node[state, right of=q0, accepting] (q1) {$q_1$};

                \draw   (q0) edge[loop above] node{1} (q0)
                        (q0) edge[above] node{0} (q1)
                        (q1) edge[loop above] node{0,1} (q1);
            \end{tikzpicture}
        \end{figure}
        Este es de forma directa minimal, puesto que sus dos estados son distinguibles al ser uno final y el otro no. Para obtener la expresión regular, resolvemos el sistema de ecuaciones:
        \begin{align*}
            q_0 &= 1q_0+0q_1\\
            q_1 &= (0+1)q_1 + \veps
        \end{align*}
        Tenemos por tanto que $q_1=(0+1)^*$, y sustituyendo en la primera ecuación, obtenemos:
        \begin{equation*}
            q_0 = 1q_0 + 0(0+1)^* = 1^*\red{0}(0+1)^*
        \end{equation*}

        \item $L = (01)^*$.
        
        Tenemos que $\operatorname{Per}(L) = \{u\in A^*\mid n_0(u)=n_1(u)\}$.
        En este caso, veamos que el lenguaje no es regular usando el Lema de Bombeo. Para todo $n\in \bb{N}$, consideramos la palabra $z=0^n1^n$, que cumple $|z|\geq n$. Si consideramos una descomposición $z=uvw$ con $|uv|\leq n$ y $|v|\geq 1$, tenemos que:
        \begin{equation*}
            u=0^k,\quad v=0^l,\quad w=0^{n-k-l}1^n, \qquad \text{\ con\ } k+l\leq n, l\geq 1
        \end{equation*}
        Entonces, tomando $i=2$, tenemos que $uv^2w=0^{n+l}1^n\notin L$. Por tanto, $L$ no es regular.
    \end{enumerate}
    ¿Es posible que, siendo $L$ regular, $\operatorname{Per}(L)$ no lo sea?\\

    Como hemos visto en el apartado anterior, el lenguaje $L=(01)^*$ es regular, pero su permutación no lo es. Por tanto, es posible que, siendo $L$ regular, $\operatorname{Per}(L)$ no lo sea.
\end{ejercicio}

\subsection{Preguntas Tipo Test}
Se pide discutir la veracidad o falsedad de las siguientes cuestiones.
\begin{enumerate}
    \item Si $r$ y $s$ son expresiones regulares, siempre se verifica que ${(rs)}^{\ast}=r^\ast s^\ast$.\\

        Falso, si $r = 0$ y $s = 1$, tenemos que:
        \begin{itemize}
            \item La expresión regular ${(01)}^{\ast}$ está asociada al lenguaje $L_1 = \{{(01)}^{i}\mid i \in \mathbb{N}\}$.
            \item La expresión regular $0^\ast 1^\ast$ está asociada al lenguaje $L_2 = \{0^i 1^j \mid i,j\in \mathbb{N}\}$.
        \end{itemize}
        Y los lenguajes no son iguales, ya que $011\in L_2 \setminus L_1$.
    \item Si $r$ y $s$ son expresiones regulares, siempre se verifica que ${(r+s)}^{\ast} = r^\ast + s^\ast$.\\

        Falso, si $r = 0$ y $s= 1$, tenemos que:
        \begin{itemize}
            \item La expresión regular ${(0+1)}^{\ast}$ está asociada al lenguaje $L_1={\{0,1\}}^{\ast}$.
            \item La expresión regular $0^\ast + 1^\ast$ está asociada al lenguaje $L_2 = {\{0\}}^{\ast}\cup {\{1\}}^{\ast}$.
        \end{itemize}
        Y como $010\in L_1\setminus L_2$, no son iguales.
    \item Si $r_1$ y $r_2$ son expresiones regulares tales que su lenguaje asociado contiene la palabra vacía, entonces ${(r_1r_2)}^{\ast}={(r_2r_1)}^{\ast}$\\

        Verdadero, sean $R_1$ y $R_2$ los lenguajes asociados a $r_1$ y a $r_2$ respectivamente, tratamos de comprobar si
        \begin{equation*}
            {(R_1R_2)}^{\ast} = {(R_2R_1)}^{\ast}
        \end{equation*}
        con la condición de que $\veps \in R_1 \cap R_2$.
        \begin{itemize}
            \item Sea $u\in {(R_1R_2)}^{\ast}$, entonces $u$ será de la forma
                \begin{equation*}
                    u = v_1w_1v_2w_2\ldots v_nw_n \qquad v_i \in R_1, \quad w_i \in R_2 \qquad \forall i \in \{1,\ldots,n\}
                \end{equation*}
                y podemos reescribir $u$ como:
                \begin{equation*}
                    u = \veps v_1w_1v_2w_2 \ldots v_nw_n\veps \in {(R_2R_1)}^{\ast}
                \end{equation*}
            \item De forma análoga, si $u\in {(R_2R_1)}^{\ast}$, podemos llegar a que $u\in {(R_1R_2)}^{\ast}$.
        \end{itemize}
    \item Si $r$ y $s$ son expresiones regulares, siempre se verifica que ${(r+\veps )}^{\ast}=r^\ast$.\\

        Verdadero, sea $R$ el lenguaje asociado a $r$, tenemos que
        \begin{equation*}
            {(R\cup \{\veps\})}^{\ast} = R^\ast
        \end{equation*}
        con lo que ${(r+\veps)}^{\ast}=r^\ast$.
    \item Si $r$ y $s$ son expresiones regulares, siempre se verifica que $r{(r+s)}^{\ast}={(r+s)}^{\ast}r$.\\

        Falso, sean $r = 0$ y $s = 1$, tenemos que:
        \begin{itemize}
            \item $0{(0+1)}^{\ast}$ es la expresión regular asociada al lenguaje \newline$L_1=\{0u \mid u\in {\{0,1\}}^{\ast}\}$.
            \item ${(0+1)}^{\ast}0$ es la expresión regular asociada al lenguaje \newline$L_2 = \{u0 \mid u\in {\{0,1\}}^{\ast}\}$.
        \end{itemize}
        Como $0111 \in L_1\setminus L_2$, los lenguajes no son iguales.
    \item Si $r_1$ y $r_2$ son expresiones regulares, entonces $r_1^\ast r_2^\ast \subseteq {(r_1r_2)}^{\ast}$, en el sentido de que los lenguajes asociados están incluidos.\\

        Falso, si $r_1 = 1$ y $r_2 = 0$, estaríamos afirmando que $1^\ast 0^\ast \subseteq {(10)}^{\ast}$, lo cual es falso, ya que $110$ es una palabra del lenguaje asociado a la primera expresión regular pero no al lenguaje asociado a la segunda.
    \item \label{item:preg2_7}
    Si $r_1$, $r_2$ y $r_3$ son expresiones regulares, entonces ${(r_1+r_2)}^{\ast}r_3=r_1^\ast r_3 + r_2^\ast r_3$.\\

        Falso, si $r_1 = a$, $r_2 = b$ y $r_3 = c$, estaríamos afirmando que 
        \begin{equation*}
            {(a+b)}^{\ast}c = a^\ast c + b^\ast c
        \end{equation*}
        Pero $abc$ es una palabra del lenguaje asociado a la primera expresión regular que no es del lenguaje asociado a la segunda expresión.
    \item \label{item:preg2_8}
     Si $r_1$ y $r_2$ son expresiones regulares entonces: ${(r_1^\ast r_2^\ast)}^{\ast}={(r_1+r_2)}^{\ast}$.\\

        Verdadero, sean $R_1$ y $R_2$ los lenguajes asociados a $r_1$ y a $r_2$ respectivamente, tratamos de ver que
        \begin{equation*}
            {(R_1^\ast R_2^\ast)}^{\ast} = {(R_1\cup R_2)}^{\ast}
        \end{equation*}
        Lo cual puede demostrarse que es cierto.
    \item Si $r_1$ y $r_2$ son expresiones regulares, entonces ${(r_1r_2)}^{\ast}={(r_1+r_2)}^{\ast}$.\\

        Falso, ya que si $r_1 = 0$ y $r_2 = 1$, estaríamos afirmando que 
        \begin{equation*}
            {(01)}^{\ast} = {(0+1)}^{\ast}
        \end{equation*}
        Pero $0$ es una palabra del lenguaje asociado a la segunda expresión regular y no del lenguaje asociado a la primera.
    \item Si $r$ es una expresión regular, entonces $r^\ast r^\ast = r^\ast$.\\

        Verdadero, si $R$ es el lenguaje asociado, tenemos que ver que $R^\ast R^\ast = R^\ast$:
        \begin{itemize}
            \item Sea $u\in R^\ast R^\ast$, entonces $u$ es de la forma:
                \begin{equation*}
                    u = v_1v_2\ldots v_nv_{n+1}v_{n+2}\ldots v_m \qquad v_1v_2\ldots v_n, v_{n+1}v_{n+2},\ldots v_m \in R^\ast
                \end{equation*}
                por lo que $v_i \in R$ $\forall i \in \{1,\ldots, m\}$ con lo que $u\in R^\ast$.

                Si por contrario $u = \veps$, entonces $u\in R^\ast$.
            \item Sea $u\in R^\ast$, entonces $u$ será de la forma:
                \begin{equation*}
                    u = v_1v_2\ldots v_n \qquad v_i \in R \quad \forall i \in \{1,\ldots, n\} \qquad n > 1
                \end{equation*}
                por lo que podemos tomar $w = v_2\ldots v_n \in R^\ast$ y $v_1\in R \subseteq R^\ast$, llegando a que
                \begin{equation*}
                    u = v_1w \qquad v_1,w \in R^\ast \Longrightarrow u\in R^\ast R^\ast
                \end{equation*}
                \begin{itemize}
                    \item En el caso en el que $u\in R\subseteq R^\ast$, entonces $u = \veps u$ con $\veps \in R^\ast$.
                    \item Además, si $u = \veps$, entonces $u = \veps \veps$ con $\veps \in R^\ast$.
                \end{itemize}
        \end{itemize}
    \item Si $r$ es una expresión regular, entonces $r\emptyset =r+\emptyset $.\\

        Falso, sea $R$ el lenguaje asociado a $r$, estaríamos afirmando que
        \begin{equation*}
            \emptyset  = R\emptyset  = R \cup \emptyset  = R
        \end{equation*}
        lo cual no es cierto, a no ser que $r = \emptyset $.
    \item Si $r$ es una expresión regular, entonces se verifica que $r^\ast\veps =r^+\veps$.\\

        Verdadero, sea $R$ el lenguaje asociado a $r$, entonces:
        \begin{equation*}
            R^\ast \cup \{\veps\} = R^\ast = R^+ \cup \{\veps\}
        \end{equation*}
    \item \label{item:preg13}
    Si $r_1$ y $r_2$ son expresiones regulares, entonces siempre $r_1{(r_2r_1)}^{\ast}={(r_1r_2)}^{\ast}r_1$.\\

        Verdadero, sean $R_1$ y $R_2$ los lenguajes asociados a $r_1$ y a $r_2$ respectivamente, entonces, tratamos de probar que
        \begin{equation*}
            R_1{(R_2R_1)}^{\ast} = {(R_1R_2)}^{\ast}R_1
        \end{equation*}
        \begin{itemize}
            \item Sea $u\in R_1{(R_2R_1)}^{\ast}$, entonces $u$ es de la forma
                \begin{equation*}
                    u = v_0w_1v_1w_2v_2 \ldots w_n v_n \qquad v_i \in R_1 \quad w_i \in R_2
                \end{equation*}
                con lo que podemos tomar:
                \begin{equation*}
                    v = v_0w_1v_1w_2v_2 \ldots w_n \in {(R_1R_2)}^{\ast}
                \end{equation*}
                y tenemos que $u = vv_n \in {(R_1R_2)}^{\ast}R_1$.
            \item Puede probarse de forma análoga que si $u\in {(R_1R_2)}^{\ast}R_1$, entonces $u\in R_1{(R_2R_1)}^{\ast}$.
        \end{itemize}
    \item Si $r_1$ y $r_2$ son expresiones regulares, siempre se verifica que $r_1{(r_2r_1)}^{\ast}={(r_1r_2)}^{\ast}r_1$.\\

        Verdadero, la pregunta es idéntica a la Pregunta~\ref{item:preg13}.
    \item Si $r$ y $s$ son expresiones regulares, entonces ${(r^\ast s^\ast)}^{\ast}={(r+s)}^{\ast}$.\\

        Verdadero, la pregunta es idéntica a la Pregunta~\ref{item:preg2_8}.
    \item Si $r$ es una expresión regular, entonces ${(rr)}^{\ast}\subseteq r^\ast$.\\

        Verdadero, sea $R$ el lenguaje asociado a $r$, tratamos de ver que 
        \begin{equation*}
            {(RR)}^{\ast} \subseteq  R^\ast
        \end{equation*}
        Sea $u\in {(RR)}^{\ast}$, entonces $u$ es de la forma
        \begin{equation*}
            u = v_1v_1'v_2v_2'\ldots v_nv_n' \qquad v_i, v_i' \in R \quad \forall i \in \{1,\ldots, n\}
        \end{equation*}
        por lo que $u\in R^\ast$.
    \item Si $r_1$ y $r_2$ son expresiones regulares, tales que su lenguaje asociado contiene la palabra vacía, entonces ${(r_1r_2)}^{\ast}={(r_1+r_2)}^{\ast}$.\\

        Verdadero, puede probarse de forma similar a como lo hicimos en la pregunta~\ref{item:preg8}.
    \item Si $r_1$, $r_2$, $r_3$ son expresiones regulares, entonces $r_1(r_2^\ast + r_3^\ast) = r_1r_2^\ast + r_1r_3^\ast$.\\

        Falso, podemos dar un contraejemplo de forma similar a como lo hicimos en la pregunta~\ref{item:preg2_7}.
    \item La demostración de que la clase de lenguajes aceptados por los autómatas no deterministas es la misma que la aceptada por los autómatas determistas, se basa en dado un autómata no determinista construir uno determinista que, ante una palabra de entrada, explore todas las posibles opciones que puede seguir el no determinista.\\

        Verdadero, así se comprueba que todo lenguaje aceptado por un autómata no determinista puede ser aceptado por uno determinista. No hace falta demostrarlo en la otra dirección, ya que un autómata determinista es a su vez no determinista.
    \item Un autómata finito puede ser determinista y no-determinista a la vez.\\

        Verdadero, ya que todos los autómatas deterministas son a su vez no deterministas.
    \item Para transformar un autómata que acepta el lenguaje $L$ en uno que acepte $L^\ast$, basta unir los estados finales con el inicial mediante transiciones nulas.\\

        Falso, tenemos que hacer que el estado inicial sean también final, para que la palabra $\veps$ sea aceptada por el autómata, en caso de que $\veps \notin L$.
    \item Para pasar de un autómata que acepte el lenguaje asociado a $r$ a uno que acepte $r^\ast$ basta con unir con transiciones nulas sus estados finales con el estado inicial.\\

        Falso, es la misma pregunta que la 21.
    \item Existe un lenguaje reconocido por un AFD y no generado por una gramática independiente del contexto.\\

        Falso, si un lenguaje es reconocido por un AFD, hemos visto en teoría que hay una gramática de tipo 3 que genera dicho lenguaje y como las gramáticas tipo 3 son a su vez independientes del contexto, el enunciado es falso.
    \item Existen lenguajes aceptados por AFD que no pueden ser aceptados por AF no determinísticos.\\

        Falso, el conjunto de lenguajes aceptados por un AFD coincide con el conjunto de lenguajes aceptados por AF no determinísticos, tal y como se ha visto en teoría.
    \item La clausura de un lenguaje aceptado por un AFD puede ser representado con una expresión regular.\\

        Verdadero, sea $L$ un lenguaje aceptado por un AFD, conocemos por teoría que podemos encontrar una expresión regular $r$ asociada a dicho lenguaje. Si ahora consideramos $r^\ast$, esta expresión regular estará asociada al lenguaje $L^\ast$.
    \item Un lenguaje representado por una expresión regular siempre puede ser reconocido por un AF no determinista.\\

        Verdadero, hemos visto en teoría que el conjunto de lenguajes representados por expresiones regulares coincide con el conjunto de lenguajes reconocidos por cualquier tipo de AF\@.
    \item Todo lenguaje regular puede ser generado por una gramática libre de contexto.\\

        Verdadero, ya que todo lenguaje regular puede ser generado por una gramática lineal por la derecha, que a su vez es independiente del contexto.
    \item Un lenguaje con un número finito de palabras siempre puede ser reconocido por un AF no determinista.\\

        Verdadero, sea $L = \{u_1, u_2, \ldots, u_n\}$ un lenguaje finito de $n$ palabras, entonces podemos considerar el autómata formado por un estado inicial $q_0$ y para cada palabra $u_i$ con $i \in \{1,\ldots,n\}$ de longitud $k=|u_i|$, añadimos $k$ nuevos estados a los que llamaremos por ejemplo $q_{ij}$ con $j\in \{1,\ldots,k\}$. De esta forma, si 
        \begin{equation*}
            u_i = a_{i1}a_{i2}\ldots a_{ik} \qquad a_{ij} \in A \quad \forall j \in \{1,\ldots,k\}
        \end{equation*}
        Entonces, añadimos las transiciones $\delta(q_{ij-1}, a_j) = q_{ij}$, entendiendo que $q_{i0} = q_0$ para cualquier $i \in \{1,\ldots,n\}$ y consideraremos que $q_{ik}$ es un estado final.

        De manera más formal, dado un lenguaje finito $L=\{u_1,u_2, \ldots, u_n\}$ sobre un alfabeto $A$, construimos el autómata $M=(Q,A,\delta, q_0, F)$ formado por los conjuntos:
        \begin{align*}
            Q &= \{q_0\} \cup \{q_{ij_i} \mid i \in \{1,\ldots,n\}, j_i \in \{1,\ldots, |u_i|\}\} \\
            F &= \{q_{ij_i} \mid j_i = |u_i|\}
        \end{align*}
        donde la función de transición $\delta$ viene dada por:
        \begin{align*}
            \delta(q_0, a) &= \left\{\begin{array}{ccl}
                    \{q_{i1}\} & \text{\ si\ } & a = a_{i1} \\
                    \emptyset & \text{\ si\ } & a\neq a_{i1} \quad \forall i \in \{1,\ldots,n\}
            \end{array}\right. \\
            \delta(q_{ij_i}, a) &= \left\{\begin{array}{ccl}
                    \{q_{ij_i+1}\} & \text{\ si\ } & a = a_{ij_i} \\
                    \emptyset & \text{\ si\ } & a \neq a_{ij_i} \quad \forall i \in \{1,\ldots,n\}, j_i\in \{1,\ldots,|u_i|\}
            \end{array}\right.
        \end{align*}
        Es decir, para cada palabra creamos un camino desde el estado inicial a un estado final que se recorra leyendo dicha palabra.

        Alternativamente, podríamos haber dicho que si $L=\{u_1,u_2,\ldots, u_n\}$ es un lenguaje finito, entonces podemos considerar la gramática $G=(\{S\}, A, P, S)$ donde $P$ es el conjunto:
        \begin{equation*}
            P = \{S\rightarrow u_1,  S\rightarrow u_2,  \ldots,  S\rightarrow u_n\}
        \end{equation*}
        Y argumentar que dicha gramática puede pasarse a un AF no determinista por la teoría vista en el Tema 2.
    \item Todo autómata finito determinista de $n$ estados, cuyo alfabeto $A$ contiene $m$ símbolos debe tener $m\cdot n$ transiciones.\\

        Verdadero, todo estado de un autómata finito determinista debe tener tantas transiciones como símbolos tenga su alfabeto $A$ de entrada, en este caso, $m$. Como en este caso el autómata finito determinista tiene $n$ estados, entonces el número de transiciones del autómata es:
        \begin{equation*}
            \sum_{i=1}^{n} m = n\cdot m
        \end{equation*}
    \item Para que un autómata con pila sea determinista es necesario que no tenga transiciones nulas.\\

        No hemos visto autómatas con pila todavía, esta pregunta no es parte del Tema 2.
    \item Si $r_1$ y $r_2$ son expresiones regulares, entonces siempre se tiene que ${(r_1+r_2)}^{\ast}={(r_1^\ast r_2)}^{\ast}r_1^\ast$.\\

        Verdadero, puede razonarse buscando la igualdad entre los lenguajes que representan ambas expresiones.
    \item Si un lenguaje es infinito no se puede encontrar una expresión regular que lo represente.\\

        Falso, el lenguaje $L=\{1^n \mid n \in \mathbb{N}\}$ es infinito por ser $\mathbb{N}$ infinito y puede representarse por la expresión regular $1^\ast$.
    \item Si $r_1$ y $r_2$ son expresiones regulares, entonces se verifica que ${(r_1+\veps)}^{+}r_2^+ = r_1^+ {(r_2+\veps)}^{+}$.\\

        Falso, si fuera cierto, entonces:
        \begin{equation*}
            r_1^\ast r_2^+ = {(r_1+\veps)}^{+}r_2^+ = r_1^+ {(r_2+\veps)}^{+} = r_1^+ r_2^\ast
        \end{equation*}
        para cualesquiera $r_1$ y $r_2$ expresiones regulares.

        Sin embargo, si tomamos $r_1 = 0$ y $r_2 = 1$, $1$ es una palabra del lenguaje asociado a la expresión regular $0^\ast 1^+$ pero no lo es del lenguaje asociado a la expresión regular $0^+ 1^\ast$, al no contener ningún ``0''.
    \item El conjunto de palabras sobre el alfabeto $\{0,1\}$ tales que eliminando los tres últimos símbolos, en la palabra resultante no aparece el patrón $0011$ es un lenguaje regular.\\

        Verdadero, ya que podemos dar un AFD que reconozca dicho lenguaje:

    \begin{figure}[H]
        \centering
    \begin{tikzpicture}
        \node[state, accepting, initial] (q0) {$q_0$};
        \node[state, accepting, right of=q0] (q1) {$q_1$};
        \node[state, accepting, right of=q1] (q2) {$q_2$};
        \node[state, accepting, right of=q2] (q3) {$q_3$};
        \node[state, accepting, right of=q3] (q4) {$q_4$};
        \node[state, accepting, below of=q4] (q5) {$q_5$};
        \node[state, accepting, left of=q5] (q6) {$q_6$};
        \node[state, error, left of=q6] (q7) {$E$};

        \draw (q0) edge[loop above] node{1} (q0)
              (q0) edge[above] node{0} (q1)
              (q1) edge[bend right, above] node{1} (q0)
              (q1) edge[left, above] node{0} (q2)
              (q2) edge[loop below] node{0} (q2)
              (q2) edge[right, above] node{1} (q3)
              (q3) edge[right, above] node{1} (q4)
              (q3) edge[bend right, above] node{0} (q1)
              (q4) edge[below, right] node{0, 1} (q5)
              (q5) edge[left, above] node{0, 1} (q6)
              (q6) edge[left, above] node{0, 1} (q7)
              (q7) edge[loop left] node{0, 1} (q7);
    \end{tikzpicture}
    \caption{Autómata Finito Determinista para la pregunta 34.}
    \end{figure}

    \item El lenguaje formado por las cadenas sobre $\{0,1\}$ que tienen un número impar de $0$ y un número par de $1$ no es regular.\\

        Falso, ya que podemos dar una gramática $G=(\{A,B,C,D\}, \{0,1\}, P, A)$ lineal por la derecha que genere dicho lenguaje. Si entendemos los estados $\{A,B,C,D\}$ como:
        \begin{itemize}
            \item $A$ quiere decir que la palabra generada hasta el momento contiene un número par de 0s y de 1s.
            \item $B$ quiere decir que la palabra generada hasta el momento contiene un número impar de 0s y par de 1s.
            \item $C$ quiere decir que la palabra generada hasta el momento contiene un número par de 0s e impar de 1s.
            \item $D$ quiere decir que la palabra generada hasta el momento contiene un número impar de 0s y de 1s.
        \end{itemize}
        Entonces, podemos dar las siguientes reglas de producción, que son las únicas reglas de producción que contiene $P$:
        \begin{align*}
            A &\rightarrow 0B\ |\ 1C \\
            B &\rightarrow \veps\ |\ 0A\ |\ 1D \\
            C &\rightarrow 1A\ |\ 0D \\
            D &\rightarrow 1B\ |\ 0C 
        \end{align*}
        Notemos que la variable inicial es $A$ ya que $\veps$ contiene un número par de 0s y de 1s.


    \item Si $L$ es un lenguaje regular con expresión regular asociada $r$, entonces $L^{-1}$ es regular con expresión regular $r^{-1}$.

        Cierto. El primer resultado ya se ha visto que es cierto, ya que invirtiendo el autómata para $L$ obtenemos un autómata para $L^{-1}$, siendo este último por tanto regular.
        Para la expresión regular, veámoslo en primer lugar para las operaciones básicas. Sean $L_1,L_2$ dos lenguajes regulares. Entonces:
        \begin{align*}
            (L_1\cup L_2)^{-1}
            &= \{w\in A^*\mid w^{-1}\in L_1\cup L_2\}
            = \{w\in A^*\mid w^{-1}\in L_1\}\cup \{w\in A^*\mid w^{-1}\in L_2\}
            =\\&= L_1^{-1}\cup L_2^{-1}\\
            (L_1L_2)^{-1}
            &= \{w\in A^*\mid w^{-1}\in L_1L_2\}
            = \{w\in A^*\mid w^{-1}=w_1w_2, w_1\in L_1, w_2\in L_2\}
            =\\&= \{w_2^{-1}w_1^{-1}\mid w_1\in L_1, w_2\in L_2\}
            = \{w_2w_1\mid w_1^{-1}\in L_1^{-1}, w_2^{-1}\in L_2^{-1}\}
            =\\&= L_2^{-1}L_1^{-1}\\
            (L_1^*)^{-1}
            &= \left(\bigcup_{i=0}^\infty L_1^i\right)^{-1}
            = \bigcup_{i=0}^\infty (L_1^i)^{-1}
            = \bigcup_{i=0}^\infty (L_1^{-1})^i
            = (L_1^{-1})^*
        \end{align*}
        donde para demostrar el tercer resultado se han usado los dos anteriores.
        
        Por tanto, como estas tres son las operaciones básicas para las expresiones regulares, se tiene que el resultado es cierto.
\end{enumerate}
