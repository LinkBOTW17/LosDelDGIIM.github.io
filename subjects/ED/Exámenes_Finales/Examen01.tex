\documentclass[12pt]{article}

\input{../../_assets/preambulo.tex}
\newcommand{\T}[0]{\cc{T}}

\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    
    \input{../../_assets/portada}
    \portadaExamen{etsiitA4.jpg}{Estructura\\de Datos\\Examen I}{Estructura de Datos. Examen I}{MidnightBlue}{-8}{28}{2023-2024}{José Juan Urrutia Milán}

    \begin{description}
        \item[Asignatura] Estructura de Datos.
        \item[Curso Académico] 2023-24.
        \item[Grado] Doble Grado en Ingeniería Informática y Matemáticas.
        \item[Grupo] Único.
        \item[Profesor] Joaquín Fernández Valdivia.
        \item[Descripción] Convocatoria Ordinaria.
        %\item[Fecha] 10 de noviembre de 2023.
        \item[Duración] 2 horas y media.
    
    \end{description}
    \newpage
    
    \begin{ejercicio}[1 punto] 
        Elegir en cada caso la opción correcta, de forma justificada.
        \begin{enumerate}[label=(\alph*)]
            \item Si inserto las claves $\{2,4,5,6,12,1,3\}$ en un \textbf{APO} de enteros:
                \begin{enumerate}[label=(a\arabic*)]
                    \item Hay que hacer un solo intercambio padre-hijo.
                    \item Hay que hacer dos intercambios padre-hijo.
                    \item Hay que hacer tres intercambios padre-hijo.
                    \item Todo lo anterior es falso.
                \end{enumerate}
                \textbf{Mostrar el árbol final}

            \item Dadas las siguientes 3 afirmaciones:
                \begin{itemize}
                    \item Es correcto en un esquema de \textbf{hashing cerrado} el uso como función hash de:
                        \begin{equation*}
                            h(k) = [k + 2k] \% M \qquad M \text{\ primo}
                        \end{equation*}
                    \item La declaración \verb|map<list<int>, string> m;| es una declaración válida.
                    \item El elemento de valor máximo en un \verb|ABB<int>| se encuentra en el nodo de más profundidad.
                \end{itemize}
                \begin{enumerate}[label=(b\arabic*)]
                    \item Todas son falsas.
                    \item Hay 2 ciertas y 1 falsa.
                    \item Hay 1 cierta y 2 falsas.
                    \item Todas son ciertas.
                \end{enumerate}

            \item Dados los siguientes recorridos Preorden y Postorden:
                \begin{equation*}
                    Pre = \{A,Z,X,Q,V,Y,L,W,T,R\} \quad Post = \{Q,V,X,Y,L,Z,T,R,W,A\}
                \end{equation*}
                \begin{enumerate}[label=(c\arabic*)]
                    \item Hay exactamente 2 árboles binarios con esos recorridos.
                    \item No hay ningún árbol binario con esos recorridos.
                    \item Hay exactamente 1 árbol binario con esos recorridos.
                    \item Hay más de 2 árboles binarios con esos recorridos.
                \end{enumerate}
                \textbf{Razona la respuesta}

            \item Dados dos nodos $n_1$ y $n_2$ en un árbol binario $T$ y dadas las distancias (longitudes de los camino) $m_1$ y $m_2$ de ambos nodos a su antecesor común más cercano (nodo más profundo que tiene tanto a $n_1$ como a $n_2$ como descendientes):
                \begin{enumerate}[label=(d\arabic*)]
                    \item Si $m_1=m_2=1$ los nodos son el mismo nodo.
                    \item Si $m_1=0$ y $m_2>0$: $n_2$ es sucesor de $n_1$.
                    \item Si $m_1=m_2=2$ los nodos no son hermanos.
                    \item Todo lo anterior es cierto.
                \end{enumerate}
        \end{enumerate}
    \end{ejercicio}

    \begin{ejercicio}[1 punto]
        Supongamos que respresentamos una lista usando un vector de la siguiente forma:
        \begin{listing}[H]
        \begin{minted}[xleftmargin=4cm, linenos]{c++}
class listacursores{
    private:
    struct dato{char elem; int siguiente;};

    vector<dato> elementos;
    int primero;
    int nelems;

    public:
    // ...
};
        \end{minted}
        \end{listing}
    \end{ejercicio}
    donde el campo \verb|elem| es el elemento de cada posición de la lista, y \verb|siguiente| indica la posición dentro del vector en que está el siguiente elemento de la lista. Ejemplo: El vector:
    \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        0 & 1 & 2 & 3 & 4 \\
        \hline
        a,4 & d,5 & b,3 & e,1 & c,2 \\
        \hline
    \end{tabular}
    \end{table}
    con: \verb|nelems = 5| \verb|primero = 0|, representa la lista (en orden) \verb|L: <a, c, b, e, d>|.

    Dada dicha representación de listas donde la posición de cada elemento viene determinada por un número entero, \textbf{construir una clase iteradora}, de forma que los elementos listados por el iterador deben aparecer en el orden en que están en la lista (independientemente de cómo estén almacenados en el vector). Para hacerlo correctamente, deben implementarse constructor, \verb|*|, \verb|==|, \verb|!=|, \verb|++|, junto con las funciones \verb|begin()| y \verb|end()| de la clase \verb|listacursores|.
    
    \begin{ejercicio}[1 punto]
        Implementar una función:
        \begin{minted}[xleftmargin=1cm]{c++}
void divide_por_signo(list<int> &L, vector<list<int> > &VL);
        \end{minted}
        que dada una lista \verb|L|, devuelve en el vector de listas \verb|VL| las sublistas contiguas del mismo signo (el 0 se considera junto con los positivos). El algoritmo puede modificar a \verb|L|.

        Ejemplos:
        \begin{gather*}
            L=\{4,-3,-5,-4,-5,-1,4,-1,-5,-5\} \Rightarrow \\ 
            \Rightarrow VL=[\{4\}, \{-3,-5,-4,-5,-1\}, \{4\}, \{-1,-5,-5\}] \\ \\
            L=\{0,4,-2,4,1,-1,-4,-4,-3,-1,-4,4,1\} \Rightarrow \\ 
            \Rightarrow VL=[\{0,4\},\{-2\},\{4,1\},\{-1,-4,-4,-3,-1,-4\},\{4,1\}] \\ \\
            L=\{2,-1,3,-3,3,-3,0,-1,0\} \Rightarrow \\ 
            \Rightarrow VL=[\{2\},\{-1\},\{3\},\{-3\},\{3\},\{-3\},\{0\},\{-1\},\{0\}] \\
        \end{gather*}
        
    \end{ejercicio}

    \begin{ejercicio}[1 punto]
        Implementar la función
        \begin{minted}[xleftmargin=1cm]{c++}
void Fibonacci_Trees(vector<bintree<int>> &v, int n);
        \end{minted}
        que construye la sucesión de árboles binarios de Fibonacci y los almacena en un vector de árboles. La sucesión comienza con un árbol con 1 solo nodo ($T_0$) y un árbol con un solo hijo a la derecha ($T_1$). A partir de ellos, se construye la sucesión construyendo cada árbol binario $T_i$ insertando $T_{i-1}$ a la derecha y $T_{i-2}$ a la izquierda (para $i=2,\ldots,n$). La etiqueta de la raíz del nuevo árbol se obtiene como la suma de las etiquetas de las raíces de los árboles izquierdo y derecho.

        Ejemplo: 
    \begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node[draw, circle] (A) at (0,0) {5};
        \end{tikzpicture}
        \caption{T0}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node[draw, circle] (A) at (0,1) {2};
            \node[draw, circle] (B) at (1,0) {4};
            \draw (A) -- (B);
        \end{tikzpicture}
        \caption{T1}
    \end{minipage}
\end{figure}

% Segunda fila de figuras
\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node[draw, circle] (A) at (0,2) {7};
            \node[draw, circle] (B) at (-1,1) {5};
            \node[draw, circle] (C) at (1,1) {2};
            \node[draw, circle] (D) at (2,0) {4};
            \draw (A) -- (B);
            \draw (A) -- (C);
            \draw (C) -- (D);
        \end{tikzpicture}
        \caption{T2}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node[draw, circle] (A) at (1,3) {9};
            \node[draw, circle] (B) at (0,2) {2};
            \node[draw, circle] (C) at (0.5,1) {4};
            \node[draw, circle] (D) at (2,2) {7};
            \node[draw, circle] (E) at (1.5,1) {5};
            \node[draw, circle] (F) at (3,1) {2};
            \node[draw, circle] (G) at (4,0) {4};
            \draw (A) -- (B);
            \draw (B) -- (C);
            \draw (A) -- (D);
            \draw (D) -- (E);
            \draw (D) -- (F);
            \draw (F) -- (G);
        \end{tikzpicture}
        \caption{T3}
    \end{minipage}
\end{figure}
    \end{ejercicio}

    \begin{ejercicio}[1 punto]
        Dados dos \verb|map|, \verb|M1| y \verb|M2|, definidos como:
        \begin{minted}[xleftmargin=5cm]{c++}
map<string,int> M1, M2;
        \end{minted}
        con el primer campo representando el nombre de una \textbf{persona} (\verb|string|) y el segundo campo su \textbf{número de seguidores} (\verb|int|) en una red social, \textbf{implementar una función:}
        \begin{minted}{c++}
map<string,int> Union (const map<string,int> &M1, const map<string,int> &M2);
        \end{minted}
        que obtenga el \verb|map| correspondiente a la unión de los dos \verb|map| de entrada, en el que el número de seguidores será la suma de los seguidores en \verb|M1| y los seguidores en \verb|M2| para la misma persona que aparece en \verb|M1| y \verb|M2|. En el caso que solamente aparezca en uno de los dos se queda tal cual en el \verb|map| resultado.
        
    \end{ejercicio}

    \begin{ejercicio}[1 punto]\ 
        \begin{enumerate}[label=(\alph*)]
            \item Insertar en el orden indicado (detallando los pasos) los siguientes claves en un \textbf{AVL}: $\{45,30,48,65,49,51,81,37,6,62,52,73\}$. Borrar el elemento $49$ del árbol.
            \item Insertar (detallando los pasos) las claves $\{8,16,12,41,10,62,27,65,13\}$ en una \textbf{Tabla Hash cerrada} de tamaño $13$. A continuación, borrar el $10$ y finalmente insertar el valor $51$. Resolver las colisiones usando hashing doble.
        \end{enumerate}
    \end{ejercicio}

\end{document}
